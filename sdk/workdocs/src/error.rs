// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type UpdateUserErrorKind = UpdateUserError;
/// Error type for the `UpdateUserError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateUserError {
    /// <p>The last user in the organization is being deactivated.</p>
    DeactivatingLastSystemUserException(crate::error::DeactivatingLastSystemUserException),
    /// <p>The resource does not exist.</p>
    EntityNotExistsException(crate::error::EntityNotExistsException),
    /// <p>The AWS Directory Service cannot reach an on-premises instance. Or a dependency under the control of the organization is failing, such as a connected Active Directory.</p>
    FailedDependencyException(crate::error::FailedDependencyException),
    /// <p>The user is undergoing transfer of ownership.</p>
    IllegalUserStateException(crate::error::IllegalUserStateException),
    /// <p>The pagination marker or limit fields are not valid.</p>
    InvalidArgumentException(crate::error::InvalidArgumentException),
    /// <p>The specified document version is not in the INITIALIZED state.</p>
    ProhibitedStateException(crate::error::ProhibitedStateException),
    /// <p>One or more of the dependencies is unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The operation is not permitted.</p>
    UnauthorizedOperationException(crate::error::UnauthorizedOperationException),
    /// <p>The caller does not have access to perform the action on the resource.</p>
    UnauthorizedResourceAccessException(crate::error::UnauthorizedResourceAccessException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for UpdateUserError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for UpdateUserError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::DeactivatingLastSystemUserException(_inner) => _inner.fmt(f),
            Self::EntityNotExistsException(_inner) => _inner.fmt(f),
            Self::FailedDependencyException(_inner) => _inner.fmt(f),
            Self::IllegalUserStateException(_inner) => _inner.fmt(f),
            Self::InvalidArgumentException(_inner) => _inner.fmt(f),
            Self::ProhibitedStateException(_inner) => _inner.fmt(f),
            Self::ServiceUnavailableException(_inner) => _inner.fmt(f),
            Self::UnauthorizedOperationException(_inner) => _inner.fmt(f),
            Self::UnauthorizedResourceAccessException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for UpdateUserError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::DeactivatingLastSystemUserException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EntityNotExistsException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::FailedDependencyException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::IllegalUserStateException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidArgumentException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ProhibitedStateException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedResourceAccessException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::UpdateUserError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateUserError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateUserError {
    /// Creates the `UpdateUserError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `UpdateUserError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::DeactivatingLastSystemUserException(e) => e.meta(),
            Self::EntityNotExistsException(e) => e.meta(),
            Self::FailedDependencyException(e) => e.meta(),
            Self::IllegalUserStateException(e) => e.meta(),
            Self::InvalidArgumentException(e) => e.meta(),
            Self::ProhibitedStateException(e) => e.meta(),
            Self::ServiceUnavailableException(e) => e.meta(),
            Self::UnauthorizedOperationException(e) => e.meta(),
            Self::UnauthorizedResourceAccessException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `UpdateUserError::DeactivatingLastSystemUserException`.
    pub fn is_deactivating_last_system_user_exception(&self) -> bool {
        matches!(self, Self::DeactivatingLastSystemUserException(_))
    }
    /// Returns `true` if the error kind is `UpdateUserError::EntityNotExistsException`.
    pub fn is_entity_not_exists_exception(&self) -> bool {
        matches!(self, Self::EntityNotExistsException(_))
    }
    /// Returns `true` if the error kind is `UpdateUserError::FailedDependencyException`.
    pub fn is_failed_dependency_exception(&self) -> bool {
        matches!(self, Self::FailedDependencyException(_))
    }
    /// Returns `true` if the error kind is `UpdateUserError::IllegalUserStateException`.
    pub fn is_illegal_user_state_exception(&self) -> bool {
        matches!(self, Self::IllegalUserStateException(_))
    }
    /// Returns `true` if the error kind is `UpdateUserError::InvalidArgumentException`.
    pub fn is_invalid_argument_exception(&self) -> bool {
        matches!(self, Self::InvalidArgumentException(_))
    }
    /// Returns `true` if the error kind is `UpdateUserError::ProhibitedStateException`.
    pub fn is_prohibited_state_exception(&self) -> bool {
        matches!(self, Self::ProhibitedStateException(_))
    }
    /// Returns `true` if the error kind is `UpdateUserError::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(self, Self::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `UpdateUserError::UnauthorizedOperationException`.
    pub fn is_unauthorized_operation_exception(&self) -> bool {
        matches!(self, Self::UnauthorizedOperationException(_))
    }
    /// Returns `true` if the error kind is `UpdateUserError::UnauthorizedResourceAccessException`.
    pub fn is_unauthorized_resource_access_exception(&self) -> bool {
        matches!(self, Self::UnauthorizedResourceAccessException(_))
    }
}
impl std::error::Error for UpdateUserError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::DeactivatingLastSystemUserException(_inner) => Some(_inner),
            Self::EntityNotExistsException(_inner) => Some(_inner),
            Self::FailedDependencyException(_inner) => Some(_inner),
            Self::IllegalUserStateException(_inner) => Some(_inner),
            Self::InvalidArgumentException(_inner) => Some(_inner),
            Self::ProhibitedStateException(_inner) => Some(_inner),
            Self::ServiceUnavailableException(_inner) => Some(_inner),
            Self::UnauthorizedOperationException(_inner) => Some(_inner),
            Self::UnauthorizedResourceAccessException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The caller does not have access to perform the action on the resource.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UnauthorizedResourceAccessException {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl UnauthorizedResourceAccessException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for UnauthorizedResourceAccessException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "UnauthorizedResourceAccessException")?;
        if let Some(inner_1) = &self.message {
            {
                write!(f, ": {}", inner_1)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for UnauthorizedResourceAccessException {}
impl aws_http::request_id::RequestId for crate::error::UnauthorizedResourceAccessException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for UnauthorizedResourceAccessException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl UnauthorizedResourceAccessException {
    /// Creates a new builder-style object to manufacture [`UnauthorizedResourceAccessException`](crate::error::UnauthorizedResourceAccessException).
    pub fn builder() -> crate::error::unauthorized_resource_access_exception::Builder {
        crate::error::unauthorized_resource_access_exception::Builder::default()
    }
}

/// See [`UnauthorizedResourceAccessException`](crate::error::UnauthorizedResourceAccessException).
pub mod unauthorized_resource_access_exception {

    /// A builder for [`UnauthorizedResourceAccessException`](crate::error::UnauthorizedResourceAccessException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`UnauthorizedResourceAccessException`](crate::error::UnauthorizedResourceAccessException).
        pub fn build(self) -> crate::error::UnauthorizedResourceAccessException {
            crate::error::UnauthorizedResourceAccessException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The operation is not permitted.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UnauthorizedOperationException {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub code: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl UnauthorizedOperationException {
    #[allow(missing_docs)] // documentation missing in model
    pub fn code(&self) -> std::option::Option<&str> {
        self.code.as_deref()
    }
}
impl UnauthorizedOperationException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for UnauthorizedOperationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "UnauthorizedOperationException")?;
        if let Some(inner_2) = &self.message {
            {
                write!(f, ": {}", inner_2)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for UnauthorizedOperationException {}
impl aws_http::request_id::RequestId for crate::error::UnauthorizedOperationException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for UnauthorizedOperationException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl UnauthorizedOperationException {
    /// Creates a new builder-style object to manufacture [`UnauthorizedOperationException`](crate::error::UnauthorizedOperationException).
    pub fn builder() -> crate::error::unauthorized_operation_exception::Builder {
        crate::error::unauthorized_operation_exception::Builder::default()
    }
}

/// See [`UnauthorizedOperationException`](crate::error::UnauthorizedOperationException).
pub mod unauthorized_operation_exception {

    /// A builder for [`UnauthorizedOperationException`](crate::error::UnauthorizedOperationException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) code: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`UnauthorizedOperationException`](crate::error::UnauthorizedOperationException).
        pub fn build(self) -> crate::error::UnauthorizedOperationException {
            crate::error::UnauthorizedOperationException {
                message: self.message,
                code: self.code,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>One or more of the dependencies is unavailable.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ServiceUnavailableException {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ServiceUnavailableException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ServiceUnavailableException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ServiceUnavailableException")?;
        if let Some(inner_3) = &self.message {
            {
                write!(f, ": {}", inner_3)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ServiceUnavailableException {}
impl aws_http::request_id::RequestId for crate::error::ServiceUnavailableException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ServiceUnavailableException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl ServiceUnavailableException {
    /// Creates a new builder-style object to manufacture [`ServiceUnavailableException`](crate::error::ServiceUnavailableException).
    pub fn builder() -> crate::error::service_unavailable_exception::Builder {
        crate::error::service_unavailable_exception::Builder::default()
    }
}

/// See [`ServiceUnavailableException`](crate::error::ServiceUnavailableException).
pub mod service_unavailable_exception {

    /// A builder for [`ServiceUnavailableException`](crate::error::ServiceUnavailableException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`ServiceUnavailableException`](crate::error::ServiceUnavailableException).
        pub fn build(self) -> crate::error::ServiceUnavailableException {
            crate::error::ServiceUnavailableException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The specified document version is not in the INITIALIZED state.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ProhibitedStateException {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ProhibitedStateException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ProhibitedStateException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ProhibitedStateException")?;
        if let Some(inner_4) = &self.message {
            {
                write!(f, ": {}", inner_4)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ProhibitedStateException {}
impl aws_http::request_id::RequestId for crate::error::ProhibitedStateException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ProhibitedStateException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl ProhibitedStateException {
    /// Creates a new builder-style object to manufacture [`ProhibitedStateException`](crate::error::ProhibitedStateException).
    pub fn builder() -> crate::error::prohibited_state_exception::Builder {
        crate::error::prohibited_state_exception::Builder::default()
    }
}

/// See [`ProhibitedStateException`](crate::error::ProhibitedStateException).
pub mod prohibited_state_exception {

    /// A builder for [`ProhibitedStateException`](crate::error::ProhibitedStateException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`ProhibitedStateException`](crate::error::ProhibitedStateException).
        pub fn build(self) -> crate::error::ProhibitedStateException {
            crate::error::ProhibitedStateException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The pagination marker or limit fields are not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidArgumentException {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidArgumentException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidArgumentException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidArgumentException")?;
        if let Some(inner_5) = &self.message {
            {
                write!(f, ": {}", inner_5)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidArgumentException {}
impl aws_http::request_id::RequestId for crate::error::InvalidArgumentException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidArgumentException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidArgumentException {
    /// Creates a new builder-style object to manufacture [`InvalidArgumentException`](crate::error::InvalidArgumentException).
    pub fn builder() -> crate::error::invalid_argument_exception::Builder {
        crate::error::invalid_argument_exception::Builder::default()
    }
}

/// See [`InvalidArgumentException`](crate::error::InvalidArgumentException).
pub mod invalid_argument_exception {

    /// A builder for [`InvalidArgumentException`](crate::error::InvalidArgumentException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidArgumentException`](crate::error::InvalidArgumentException).
        pub fn build(self) -> crate::error::InvalidArgumentException {
            crate::error::InvalidArgumentException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The user is undergoing transfer of ownership.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct IllegalUserStateException {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl IllegalUserStateException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for IllegalUserStateException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "IllegalUserStateException")?;
        if let Some(inner_6) = &self.message {
            {
                write!(f, ": {}", inner_6)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for IllegalUserStateException {}
impl aws_http::request_id::RequestId for crate::error::IllegalUserStateException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for IllegalUserStateException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl IllegalUserStateException {
    /// Creates a new builder-style object to manufacture [`IllegalUserStateException`](crate::error::IllegalUserStateException).
    pub fn builder() -> crate::error::illegal_user_state_exception::Builder {
        crate::error::illegal_user_state_exception::Builder::default()
    }
}

/// See [`IllegalUserStateException`](crate::error::IllegalUserStateException).
pub mod illegal_user_state_exception {

    /// A builder for [`IllegalUserStateException`](crate::error::IllegalUserStateException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`IllegalUserStateException`](crate::error::IllegalUserStateException).
        pub fn build(self) -> crate::error::IllegalUserStateException {
            crate::error::IllegalUserStateException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The AWS Directory Service cannot reach an on-premises instance. Or a dependency under the control of the organization is failing, such as a connected Active Directory.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FailedDependencyException {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl FailedDependencyException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for FailedDependencyException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "FailedDependencyException")?;
        if let Some(inner_7) = &self.message {
            {
                write!(f, ": {}", inner_7)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for FailedDependencyException {}
impl aws_http::request_id::RequestId for crate::error::FailedDependencyException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for FailedDependencyException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl FailedDependencyException {
    /// Creates a new builder-style object to manufacture [`FailedDependencyException`](crate::error::FailedDependencyException).
    pub fn builder() -> crate::error::failed_dependency_exception::Builder {
        crate::error::failed_dependency_exception::Builder::default()
    }
}

/// See [`FailedDependencyException`](crate::error::FailedDependencyException).
pub mod failed_dependency_exception {

    /// A builder for [`FailedDependencyException`](crate::error::FailedDependencyException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`FailedDependencyException`](crate::error::FailedDependencyException).
        pub fn build(self) -> crate::error::FailedDependencyException {
            crate::error::FailedDependencyException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The resource does not exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EntityNotExistsException {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    /// <p>The IDs of the non-existent resources.</p>
    #[doc(hidden)]
    pub entity_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl EntityNotExistsException {
    /// <p>The IDs of the non-existent resources.</p>
    pub fn entity_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.entity_ids.as_deref()
    }
}
impl EntityNotExistsException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for EntityNotExistsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "EntityNotExistsException")?;
        if let Some(inner_8) = &self.message {
            {
                write!(f, ": {}", inner_8)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for EntityNotExistsException {}
impl aws_http::request_id::RequestId for crate::error::EntityNotExistsException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for EntityNotExistsException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl EntityNotExistsException {
    /// Creates a new builder-style object to manufacture [`EntityNotExistsException`](crate::error::EntityNotExistsException).
    pub fn builder() -> crate::error::entity_not_exists_exception::Builder {
        crate::error::entity_not_exists_exception::Builder::default()
    }
}

/// See [`EntityNotExistsException`](crate::error::EntityNotExistsException).
pub mod entity_not_exists_exception {

    /// A builder for [`EntityNotExistsException`](crate::error::EntityNotExistsException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) entity_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Appends an item to `entity_ids`.
        ///
        /// To override the contents of this collection use [`set_entity_ids`](Self::set_entity_ids).
        ///
        /// <p>The IDs of the non-existent resources.</p>
        pub fn entity_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.entity_ids.unwrap_or_default();
            v.push(input.into());
            self.entity_ids = Some(v);
            self
        }
        /// <p>The IDs of the non-existent resources.</p>
        pub fn set_entity_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.entity_ids = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`EntityNotExistsException`](crate::error::EntityNotExistsException).
        pub fn build(self) -> crate::error::EntityNotExistsException {
            crate::error::EntityNotExistsException {
                message: self.message,
                entity_ids: self.entity_ids,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The last user in the organization is being deactivated.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeactivatingLastSystemUserException {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub code: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl DeactivatingLastSystemUserException {
    #[allow(missing_docs)] // documentation missing in model
    pub fn code(&self) -> std::option::Option<&str> {
        self.code.as_deref()
    }
}
impl DeactivatingLastSystemUserException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DeactivatingLastSystemUserException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DeactivatingLastSystemUserException")?;
        if let Some(inner_9) = &self.message {
            {
                write!(f, ": {}", inner_9)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for DeactivatingLastSystemUserException {}
impl aws_http::request_id::RequestId for crate::error::DeactivatingLastSystemUserException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for DeactivatingLastSystemUserException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl DeactivatingLastSystemUserException {
    /// Creates a new builder-style object to manufacture [`DeactivatingLastSystemUserException`](crate::error::DeactivatingLastSystemUserException).
    pub fn builder() -> crate::error::deactivating_last_system_user_exception::Builder {
        crate::error::deactivating_last_system_user_exception::Builder::default()
    }
}

/// See [`DeactivatingLastSystemUserException`](crate::error::DeactivatingLastSystemUserException).
pub mod deactivating_last_system_user_exception {

    /// A builder for [`DeactivatingLastSystemUserException`](crate::error::DeactivatingLastSystemUserException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) code: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`DeactivatingLastSystemUserException`](crate::error::DeactivatingLastSystemUserException).
        pub fn build(self) -> crate::error::DeactivatingLastSystemUserException {
            crate::error::DeactivatingLastSystemUserException {
                message: self.message,
                code: self.code,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type UpdateFolderErrorKind = UpdateFolderError;
/// Error type for the `UpdateFolderError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateFolderError {
    /// <p>The resource hierarchy is changing.</p>
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    /// <p>Another operation is in progress on the resource that conflicts with the current operation.</p>
    ConflictingOperationException(crate::error::ConflictingOperationException),
    /// <p>The resource already exists.</p>
    EntityAlreadyExistsException(crate::error::EntityAlreadyExistsException),
    /// <p>The resource does not exist.</p>
    EntityNotExistsException(crate::error::EntityNotExistsException),
    /// <p>The AWS Directory Service cannot reach an on-premises instance. Or a dependency under the control of the organization is failing, such as a connected Active Directory.</p>
    FailedDependencyException(crate::error::FailedDependencyException),
    /// <p>The maximum of 100,000 files and folders under the parent folder has been exceeded.</p>
    LimitExceededException(crate::error::LimitExceededException),
    /// <p>The specified document version is not in the INITIALIZED state.</p>
    ProhibitedStateException(crate::error::ProhibitedStateException),
    /// <p>One or more of the dependencies is unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The operation is not permitted.</p>
    UnauthorizedOperationException(crate::error::UnauthorizedOperationException),
    /// <p>The caller does not have access to perform the action on the resource.</p>
    UnauthorizedResourceAccessException(crate::error::UnauthorizedResourceAccessException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for UpdateFolderError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for UpdateFolderError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ConcurrentModificationException(_inner) => _inner.fmt(f),
            Self::ConflictingOperationException(_inner) => _inner.fmt(f),
            Self::EntityAlreadyExistsException(_inner) => _inner.fmt(f),
            Self::EntityNotExistsException(_inner) => _inner.fmt(f),
            Self::FailedDependencyException(_inner) => _inner.fmt(f),
            Self::LimitExceededException(_inner) => _inner.fmt(f),
            Self::ProhibitedStateException(_inner) => _inner.fmt(f),
            Self::ServiceUnavailableException(_inner) => _inner.fmt(f),
            Self::UnauthorizedOperationException(_inner) => _inner.fmt(f),
            Self::UnauthorizedResourceAccessException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for UpdateFolderError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ConcurrentModificationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ConflictingOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EntityAlreadyExistsException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EntityNotExistsException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::FailedDependencyException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::LimitExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ProhibitedStateException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedResourceAccessException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::UpdateFolderError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateFolderError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateFolderError {
    /// Creates the `UpdateFolderError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `UpdateFolderError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ConcurrentModificationException(e) => e.meta(),
            Self::ConflictingOperationException(e) => e.meta(),
            Self::EntityAlreadyExistsException(e) => e.meta(),
            Self::EntityNotExistsException(e) => e.meta(),
            Self::FailedDependencyException(e) => e.meta(),
            Self::LimitExceededException(e) => e.meta(),
            Self::ProhibitedStateException(e) => e.meta(),
            Self::ServiceUnavailableException(e) => e.meta(),
            Self::UnauthorizedOperationException(e) => e.meta(),
            Self::UnauthorizedResourceAccessException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `UpdateFolderError::ConcurrentModificationException`.
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(self, Self::ConcurrentModificationException(_))
    }
    /// Returns `true` if the error kind is `UpdateFolderError::ConflictingOperationException`.
    pub fn is_conflicting_operation_exception(&self) -> bool {
        matches!(self, Self::ConflictingOperationException(_))
    }
    /// Returns `true` if the error kind is `UpdateFolderError::EntityAlreadyExistsException`.
    pub fn is_entity_already_exists_exception(&self) -> bool {
        matches!(self, Self::EntityAlreadyExistsException(_))
    }
    /// Returns `true` if the error kind is `UpdateFolderError::EntityNotExistsException`.
    pub fn is_entity_not_exists_exception(&self) -> bool {
        matches!(self, Self::EntityNotExistsException(_))
    }
    /// Returns `true` if the error kind is `UpdateFolderError::FailedDependencyException`.
    pub fn is_failed_dependency_exception(&self) -> bool {
        matches!(self, Self::FailedDependencyException(_))
    }
    /// Returns `true` if the error kind is `UpdateFolderError::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(self, Self::LimitExceededException(_))
    }
    /// Returns `true` if the error kind is `UpdateFolderError::ProhibitedStateException`.
    pub fn is_prohibited_state_exception(&self) -> bool {
        matches!(self, Self::ProhibitedStateException(_))
    }
    /// Returns `true` if the error kind is `UpdateFolderError::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(self, Self::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `UpdateFolderError::UnauthorizedOperationException`.
    pub fn is_unauthorized_operation_exception(&self) -> bool {
        matches!(self, Self::UnauthorizedOperationException(_))
    }
    /// Returns `true` if the error kind is `UpdateFolderError::UnauthorizedResourceAccessException`.
    pub fn is_unauthorized_resource_access_exception(&self) -> bool {
        matches!(self, Self::UnauthorizedResourceAccessException(_))
    }
}
impl std::error::Error for UpdateFolderError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ConcurrentModificationException(_inner) => Some(_inner),
            Self::ConflictingOperationException(_inner) => Some(_inner),
            Self::EntityAlreadyExistsException(_inner) => Some(_inner),
            Self::EntityNotExistsException(_inner) => Some(_inner),
            Self::FailedDependencyException(_inner) => Some(_inner),
            Self::LimitExceededException(_inner) => Some(_inner),
            Self::ProhibitedStateException(_inner) => Some(_inner),
            Self::ServiceUnavailableException(_inner) => Some(_inner),
            Self::UnauthorizedOperationException(_inner) => Some(_inner),
            Self::UnauthorizedResourceAccessException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The maximum of 100,000 files and folders under the parent folder has been exceeded.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LimitExceededException {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl LimitExceededException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for LimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "LimitExceededException")?;
        if let Some(inner_10) = &self.message {
            {
                write!(f, ": {}", inner_10)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for LimitExceededException {}
impl aws_http::request_id::RequestId for crate::error::LimitExceededException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for LimitExceededException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl LimitExceededException {
    /// Creates a new builder-style object to manufacture [`LimitExceededException`](crate::error::LimitExceededException).
    pub fn builder() -> crate::error::limit_exceeded_exception::Builder {
        crate::error::limit_exceeded_exception::Builder::default()
    }
}

/// See [`LimitExceededException`](crate::error::LimitExceededException).
pub mod limit_exceeded_exception {

    /// A builder for [`LimitExceededException`](crate::error::LimitExceededException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`LimitExceededException`](crate::error::LimitExceededException).
        pub fn build(self) -> crate::error::LimitExceededException {
            crate::error::LimitExceededException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The resource already exists.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EntityAlreadyExistsException {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl EntityAlreadyExistsException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for EntityAlreadyExistsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "EntityAlreadyExistsException")?;
        if let Some(inner_11) = &self.message {
            {
                write!(f, ": {}", inner_11)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for EntityAlreadyExistsException {}
impl aws_http::request_id::RequestId for crate::error::EntityAlreadyExistsException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for EntityAlreadyExistsException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl EntityAlreadyExistsException {
    /// Creates a new builder-style object to manufacture [`EntityAlreadyExistsException`](crate::error::EntityAlreadyExistsException).
    pub fn builder() -> crate::error::entity_already_exists_exception::Builder {
        crate::error::entity_already_exists_exception::Builder::default()
    }
}

/// See [`EntityAlreadyExistsException`](crate::error::EntityAlreadyExistsException).
pub mod entity_already_exists_exception {

    /// A builder for [`EntityAlreadyExistsException`](crate::error::EntityAlreadyExistsException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`EntityAlreadyExistsException`](crate::error::EntityAlreadyExistsException).
        pub fn build(self) -> crate::error::EntityAlreadyExistsException {
            crate::error::EntityAlreadyExistsException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>Another operation is in progress on the resource that conflicts with the current operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ConflictingOperationException {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ConflictingOperationException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ConflictingOperationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ConflictingOperationException")?;
        if let Some(inner_12) = &self.message {
            {
                write!(f, ": {}", inner_12)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ConflictingOperationException {}
impl aws_http::request_id::RequestId for crate::error::ConflictingOperationException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ConflictingOperationException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl ConflictingOperationException {
    /// Creates a new builder-style object to manufacture [`ConflictingOperationException`](crate::error::ConflictingOperationException).
    pub fn builder() -> crate::error::conflicting_operation_exception::Builder {
        crate::error::conflicting_operation_exception::Builder::default()
    }
}

/// See [`ConflictingOperationException`](crate::error::ConflictingOperationException).
pub mod conflicting_operation_exception {

    /// A builder for [`ConflictingOperationException`](crate::error::ConflictingOperationException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`ConflictingOperationException`](crate::error::ConflictingOperationException).
        pub fn build(self) -> crate::error::ConflictingOperationException {
            crate::error::ConflictingOperationException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The resource hierarchy is changing.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ConcurrentModificationException {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ConcurrentModificationException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ConcurrentModificationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ConcurrentModificationException")?;
        if let Some(inner_13) = &self.message {
            {
                write!(f, ": {}", inner_13)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ConcurrentModificationException {}
impl aws_http::request_id::RequestId for crate::error::ConcurrentModificationException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ConcurrentModificationException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl ConcurrentModificationException {
    /// Creates a new builder-style object to manufacture [`ConcurrentModificationException`](crate::error::ConcurrentModificationException).
    pub fn builder() -> crate::error::concurrent_modification_exception::Builder {
        crate::error::concurrent_modification_exception::Builder::default()
    }
}

/// See [`ConcurrentModificationException`](crate::error::ConcurrentModificationException).
pub mod concurrent_modification_exception {

    /// A builder for [`ConcurrentModificationException`](crate::error::ConcurrentModificationException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`ConcurrentModificationException`](crate::error::ConcurrentModificationException).
        pub fn build(self) -> crate::error::ConcurrentModificationException {
            crate::error::ConcurrentModificationException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type UpdateDocumentVersionErrorKind = UpdateDocumentVersionError;
/// Error type for the `UpdateDocumentVersionError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateDocumentVersionError {
    /// <p>The resource hierarchy is changing.</p>
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    /// <p>The resource does not exist.</p>
    EntityNotExistsException(crate::error::EntityNotExistsException),
    /// <p>The AWS Directory Service cannot reach an on-premises instance. Or a dependency under the control of the organization is failing, such as a connected Active Directory.</p>
    FailedDependencyException(crate::error::FailedDependencyException),
    /// <p>The operation is invalid.</p>
    InvalidOperationException(crate::error::InvalidOperationException),
    /// <p>The specified document version is not in the INITIALIZED state.</p>
    ProhibitedStateException(crate::error::ProhibitedStateException),
    /// <p>One or more of the dependencies is unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The operation is not permitted.</p>
    UnauthorizedOperationException(crate::error::UnauthorizedOperationException),
    /// <p>The caller does not have access to perform the action on the resource.</p>
    UnauthorizedResourceAccessException(crate::error::UnauthorizedResourceAccessException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for UpdateDocumentVersionError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for UpdateDocumentVersionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ConcurrentModificationException(_inner) => _inner.fmt(f),
            Self::EntityNotExistsException(_inner) => _inner.fmt(f),
            Self::FailedDependencyException(_inner) => _inner.fmt(f),
            Self::InvalidOperationException(_inner) => _inner.fmt(f),
            Self::ProhibitedStateException(_inner) => _inner.fmt(f),
            Self::ServiceUnavailableException(_inner) => _inner.fmt(f),
            Self::UnauthorizedOperationException(_inner) => _inner.fmt(f),
            Self::UnauthorizedResourceAccessException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for UpdateDocumentVersionError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ConcurrentModificationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EntityNotExistsException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::FailedDependencyException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ProhibitedStateException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedResourceAccessException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::UpdateDocumentVersionError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateDocumentVersionError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateDocumentVersionError {
    /// Creates the `UpdateDocumentVersionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `UpdateDocumentVersionError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ConcurrentModificationException(e) => e.meta(),
            Self::EntityNotExistsException(e) => e.meta(),
            Self::FailedDependencyException(e) => e.meta(),
            Self::InvalidOperationException(e) => e.meta(),
            Self::ProhibitedStateException(e) => e.meta(),
            Self::ServiceUnavailableException(e) => e.meta(),
            Self::UnauthorizedOperationException(e) => e.meta(),
            Self::UnauthorizedResourceAccessException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `UpdateDocumentVersionError::ConcurrentModificationException`.
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(self, Self::ConcurrentModificationException(_))
    }
    /// Returns `true` if the error kind is `UpdateDocumentVersionError::EntityNotExistsException`.
    pub fn is_entity_not_exists_exception(&self) -> bool {
        matches!(self, Self::EntityNotExistsException(_))
    }
    /// Returns `true` if the error kind is `UpdateDocumentVersionError::FailedDependencyException`.
    pub fn is_failed_dependency_exception(&self) -> bool {
        matches!(self, Self::FailedDependencyException(_))
    }
    /// Returns `true` if the error kind is `UpdateDocumentVersionError::InvalidOperationException`.
    pub fn is_invalid_operation_exception(&self) -> bool {
        matches!(self, Self::InvalidOperationException(_))
    }
    /// Returns `true` if the error kind is `UpdateDocumentVersionError::ProhibitedStateException`.
    pub fn is_prohibited_state_exception(&self) -> bool {
        matches!(self, Self::ProhibitedStateException(_))
    }
    /// Returns `true` if the error kind is `UpdateDocumentVersionError::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(self, Self::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `UpdateDocumentVersionError::UnauthorizedOperationException`.
    pub fn is_unauthorized_operation_exception(&self) -> bool {
        matches!(self, Self::UnauthorizedOperationException(_))
    }
    /// Returns `true` if the error kind is `UpdateDocumentVersionError::UnauthorizedResourceAccessException`.
    pub fn is_unauthorized_resource_access_exception(&self) -> bool {
        matches!(self, Self::UnauthorizedResourceAccessException(_))
    }
}
impl std::error::Error for UpdateDocumentVersionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ConcurrentModificationException(_inner) => Some(_inner),
            Self::EntityNotExistsException(_inner) => Some(_inner),
            Self::FailedDependencyException(_inner) => Some(_inner),
            Self::InvalidOperationException(_inner) => Some(_inner),
            Self::ProhibitedStateException(_inner) => Some(_inner),
            Self::ServiceUnavailableException(_inner) => Some(_inner),
            Self::UnauthorizedOperationException(_inner) => Some(_inner),
            Self::UnauthorizedResourceAccessException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The operation is invalid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidOperationException {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidOperationException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidOperationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidOperationException")?;
        if let Some(inner_14) = &self.message {
            {
                write!(f, ": {}", inner_14)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidOperationException {}
impl aws_http::request_id::RequestId for crate::error::InvalidOperationException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidOperationException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidOperationException {
    /// Creates a new builder-style object to manufacture [`InvalidOperationException`](crate::error::InvalidOperationException).
    pub fn builder() -> crate::error::invalid_operation_exception::Builder {
        crate::error::invalid_operation_exception::Builder::default()
    }
}

/// See [`InvalidOperationException`](crate::error::InvalidOperationException).
pub mod invalid_operation_exception {

    /// A builder for [`InvalidOperationException`](crate::error::InvalidOperationException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidOperationException`](crate::error::InvalidOperationException).
        pub fn build(self) -> crate::error::InvalidOperationException {
            crate::error::InvalidOperationException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type UpdateDocumentErrorKind = UpdateDocumentError;
/// Error type for the `UpdateDocumentError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateDocumentError {
    /// <p>The resource hierarchy is changing.</p>
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    /// <p>Another operation is in progress on the resource that conflicts with the current operation.</p>
    ConflictingOperationException(crate::error::ConflictingOperationException),
    /// <p>The resource already exists.</p>
    EntityAlreadyExistsException(crate::error::EntityAlreadyExistsException),
    /// <p>The resource does not exist.</p>
    EntityNotExistsException(crate::error::EntityNotExistsException),
    /// <p>The AWS Directory Service cannot reach an on-premises instance. Or a dependency under the control of the organization is failing, such as a connected Active Directory.</p>
    FailedDependencyException(crate::error::FailedDependencyException),
    /// <p>The maximum of 100,000 files and folders under the parent folder has been exceeded.</p>
    LimitExceededException(crate::error::LimitExceededException),
    /// <p>The specified document version is not in the INITIALIZED state.</p>
    ProhibitedStateException(crate::error::ProhibitedStateException),
    /// <p>One or more of the dependencies is unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The operation is not permitted.</p>
    UnauthorizedOperationException(crate::error::UnauthorizedOperationException),
    /// <p>The caller does not have access to perform the action on the resource.</p>
    UnauthorizedResourceAccessException(crate::error::UnauthorizedResourceAccessException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for UpdateDocumentError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for UpdateDocumentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ConcurrentModificationException(_inner) => _inner.fmt(f),
            Self::ConflictingOperationException(_inner) => _inner.fmt(f),
            Self::EntityAlreadyExistsException(_inner) => _inner.fmt(f),
            Self::EntityNotExistsException(_inner) => _inner.fmt(f),
            Self::FailedDependencyException(_inner) => _inner.fmt(f),
            Self::LimitExceededException(_inner) => _inner.fmt(f),
            Self::ProhibitedStateException(_inner) => _inner.fmt(f),
            Self::ServiceUnavailableException(_inner) => _inner.fmt(f),
            Self::UnauthorizedOperationException(_inner) => _inner.fmt(f),
            Self::UnauthorizedResourceAccessException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for UpdateDocumentError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ConcurrentModificationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ConflictingOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EntityAlreadyExistsException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EntityNotExistsException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::FailedDependencyException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::LimitExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ProhibitedStateException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedResourceAccessException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::UpdateDocumentError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateDocumentError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateDocumentError {
    /// Creates the `UpdateDocumentError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `UpdateDocumentError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ConcurrentModificationException(e) => e.meta(),
            Self::ConflictingOperationException(e) => e.meta(),
            Self::EntityAlreadyExistsException(e) => e.meta(),
            Self::EntityNotExistsException(e) => e.meta(),
            Self::FailedDependencyException(e) => e.meta(),
            Self::LimitExceededException(e) => e.meta(),
            Self::ProhibitedStateException(e) => e.meta(),
            Self::ServiceUnavailableException(e) => e.meta(),
            Self::UnauthorizedOperationException(e) => e.meta(),
            Self::UnauthorizedResourceAccessException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `UpdateDocumentError::ConcurrentModificationException`.
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(self, Self::ConcurrentModificationException(_))
    }
    /// Returns `true` if the error kind is `UpdateDocumentError::ConflictingOperationException`.
    pub fn is_conflicting_operation_exception(&self) -> bool {
        matches!(self, Self::ConflictingOperationException(_))
    }
    /// Returns `true` if the error kind is `UpdateDocumentError::EntityAlreadyExistsException`.
    pub fn is_entity_already_exists_exception(&self) -> bool {
        matches!(self, Self::EntityAlreadyExistsException(_))
    }
    /// Returns `true` if the error kind is `UpdateDocumentError::EntityNotExistsException`.
    pub fn is_entity_not_exists_exception(&self) -> bool {
        matches!(self, Self::EntityNotExistsException(_))
    }
    /// Returns `true` if the error kind is `UpdateDocumentError::FailedDependencyException`.
    pub fn is_failed_dependency_exception(&self) -> bool {
        matches!(self, Self::FailedDependencyException(_))
    }
    /// Returns `true` if the error kind is `UpdateDocumentError::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(self, Self::LimitExceededException(_))
    }
    /// Returns `true` if the error kind is `UpdateDocumentError::ProhibitedStateException`.
    pub fn is_prohibited_state_exception(&self) -> bool {
        matches!(self, Self::ProhibitedStateException(_))
    }
    /// Returns `true` if the error kind is `UpdateDocumentError::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(self, Self::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `UpdateDocumentError::UnauthorizedOperationException`.
    pub fn is_unauthorized_operation_exception(&self) -> bool {
        matches!(self, Self::UnauthorizedOperationException(_))
    }
    /// Returns `true` if the error kind is `UpdateDocumentError::UnauthorizedResourceAccessException`.
    pub fn is_unauthorized_resource_access_exception(&self) -> bool {
        matches!(self, Self::UnauthorizedResourceAccessException(_))
    }
}
impl std::error::Error for UpdateDocumentError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ConcurrentModificationException(_inner) => Some(_inner),
            Self::ConflictingOperationException(_inner) => Some(_inner),
            Self::EntityAlreadyExistsException(_inner) => Some(_inner),
            Self::EntityNotExistsException(_inner) => Some(_inner),
            Self::FailedDependencyException(_inner) => Some(_inner),
            Self::LimitExceededException(_inner) => Some(_inner),
            Self::ProhibitedStateException(_inner) => Some(_inner),
            Self::ServiceUnavailableException(_inner) => Some(_inner),
            Self::UnauthorizedOperationException(_inner) => Some(_inner),
            Self::UnauthorizedResourceAccessException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type RestoreDocumentVersionsErrorKind = RestoreDocumentVersionsError;
/// Error type for the `RestoreDocumentVersionsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RestoreDocumentVersionsError {
    /// <p>The resource hierarchy is changing.</p>
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    /// <p>Another operation is in progress on the resource that conflicts with the current operation.</p>
    ConflictingOperationException(crate::error::ConflictingOperationException),
    /// <p>The resource does not exist.</p>
    EntityNotExistsException(crate::error::EntityNotExistsException),
    /// <p>The AWS Directory Service cannot reach an on-premises instance. Or a dependency under the control of the organization is failing, such as a connected Active Directory.</p>
    FailedDependencyException(crate::error::FailedDependencyException),
    /// <p>The operation is invalid.</p>
    InvalidOperationException(crate::error::InvalidOperationException),
    /// <p>The specified document version is not in the INITIALIZED state.</p>
    ProhibitedStateException(crate::error::ProhibitedStateException),
    /// <p>The operation is not permitted.</p>
    UnauthorizedOperationException(crate::error::UnauthorizedOperationException),
    /// <p>The caller does not have access to perform the action on the resource.</p>
    UnauthorizedResourceAccessException(crate::error::UnauthorizedResourceAccessException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for RestoreDocumentVersionsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for RestoreDocumentVersionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ConcurrentModificationException(_inner) => _inner.fmt(f),
            Self::ConflictingOperationException(_inner) => _inner.fmt(f),
            Self::EntityNotExistsException(_inner) => _inner.fmt(f),
            Self::FailedDependencyException(_inner) => _inner.fmt(f),
            Self::InvalidOperationException(_inner) => _inner.fmt(f),
            Self::ProhibitedStateException(_inner) => _inner.fmt(f),
            Self::UnauthorizedOperationException(_inner) => _inner.fmt(f),
            Self::UnauthorizedResourceAccessException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for RestoreDocumentVersionsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ConcurrentModificationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ConflictingOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EntityNotExistsException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::FailedDependencyException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ProhibitedStateException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedResourceAccessException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::RestoreDocumentVersionsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for RestoreDocumentVersionsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl RestoreDocumentVersionsError {
    /// Creates the `RestoreDocumentVersionsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `RestoreDocumentVersionsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ConcurrentModificationException(e) => e.meta(),
            Self::ConflictingOperationException(e) => e.meta(),
            Self::EntityNotExistsException(e) => e.meta(),
            Self::FailedDependencyException(e) => e.meta(),
            Self::InvalidOperationException(e) => e.meta(),
            Self::ProhibitedStateException(e) => e.meta(),
            Self::UnauthorizedOperationException(e) => e.meta(),
            Self::UnauthorizedResourceAccessException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `RestoreDocumentVersionsError::ConcurrentModificationException`.
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(self, Self::ConcurrentModificationException(_))
    }
    /// Returns `true` if the error kind is `RestoreDocumentVersionsError::ConflictingOperationException`.
    pub fn is_conflicting_operation_exception(&self) -> bool {
        matches!(self, Self::ConflictingOperationException(_))
    }
    /// Returns `true` if the error kind is `RestoreDocumentVersionsError::EntityNotExistsException`.
    pub fn is_entity_not_exists_exception(&self) -> bool {
        matches!(self, Self::EntityNotExistsException(_))
    }
    /// Returns `true` if the error kind is `RestoreDocumentVersionsError::FailedDependencyException`.
    pub fn is_failed_dependency_exception(&self) -> bool {
        matches!(self, Self::FailedDependencyException(_))
    }
    /// Returns `true` if the error kind is `RestoreDocumentVersionsError::InvalidOperationException`.
    pub fn is_invalid_operation_exception(&self) -> bool {
        matches!(self, Self::InvalidOperationException(_))
    }
    /// Returns `true` if the error kind is `RestoreDocumentVersionsError::ProhibitedStateException`.
    pub fn is_prohibited_state_exception(&self) -> bool {
        matches!(self, Self::ProhibitedStateException(_))
    }
    /// Returns `true` if the error kind is `RestoreDocumentVersionsError::UnauthorizedOperationException`.
    pub fn is_unauthorized_operation_exception(&self) -> bool {
        matches!(self, Self::UnauthorizedOperationException(_))
    }
    /// Returns `true` if the error kind is `RestoreDocumentVersionsError::UnauthorizedResourceAccessException`.
    pub fn is_unauthorized_resource_access_exception(&self) -> bool {
        matches!(self, Self::UnauthorizedResourceAccessException(_))
    }
}
impl std::error::Error for RestoreDocumentVersionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ConcurrentModificationException(_inner) => Some(_inner),
            Self::ConflictingOperationException(_inner) => Some(_inner),
            Self::EntityNotExistsException(_inner) => Some(_inner),
            Self::FailedDependencyException(_inner) => Some(_inner),
            Self::InvalidOperationException(_inner) => Some(_inner),
            Self::ProhibitedStateException(_inner) => Some(_inner),
            Self::UnauthorizedOperationException(_inner) => Some(_inner),
            Self::UnauthorizedResourceAccessException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type RemoveResourcePermissionErrorKind = RemoveResourcePermissionError;
/// Error type for the `RemoveResourcePermissionError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RemoveResourcePermissionError {
    /// <p>The AWS Directory Service cannot reach an on-premises instance. Or a dependency under the control of the organization is failing, such as a connected Active Directory.</p>
    FailedDependencyException(crate::error::FailedDependencyException),
    /// <p>One or more of the dependencies is unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The operation is not permitted.</p>
    UnauthorizedOperationException(crate::error::UnauthorizedOperationException),
    /// <p>The caller does not have access to perform the action on the resource.</p>
    UnauthorizedResourceAccessException(crate::error::UnauthorizedResourceAccessException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for RemoveResourcePermissionError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for RemoveResourcePermissionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::FailedDependencyException(_inner) => _inner.fmt(f),
            Self::ServiceUnavailableException(_inner) => _inner.fmt(f),
            Self::UnauthorizedOperationException(_inner) => _inner.fmt(f),
            Self::UnauthorizedResourceAccessException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for RemoveResourcePermissionError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::FailedDependencyException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedResourceAccessException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::RemoveResourcePermissionError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for RemoveResourcePermissionError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl RemoveResourcePermissionError {
    /// Creates the `RemoveResourcePermissionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `RemoveResourcePermissionError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::FailedDependencyException(e) => e.meta(),
            Self::ServiceUnavailableException(e) => e.meta(),
            Self::UnauthorizedOperationException(e) => e.meta(),
            Self::UnauthorizedResourceAccessException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `RemoveResourcePermissionError::FailedDependencyException`.
    pub fn is_failed_dependency_exception(&self) -> bool {
        matches!(self, Self::FailedDependencyException(_))
    }
    /// Returns `true` if the error kind is `RemoveResourcePermissionError::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(self, Self::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `RemoveResourcePermissionError::UnauthorizedOperationException`.
    pub fn is_unauthorized_operation_exception(&self) -> bool {
        matches!(self, Self::UnauthorizedOperationException(_))
    }
    /// Returns `true` if the error kind is `RemoveResourcePermissionError::UnauthorizedResourceAccessException`.
    pub fn is_unauthorized_resource_access_exception(&self) -> bool {
        matches!(self, Self::UnauthorizedResourceAccessException(_))
    }
}
impl std::error::Error for RemoveResourcePermissionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::FailedDependencyException(_inner) => Some(_inner),
            Self::ServiceUnavailableException(_inner) => Some(_inner),
            Self::UnauthorizedOperationException(_inner) => Some(_inner),
            Self::UnauthorizedResourceAccessException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type RemoveAllResourcePermissionsErrorKind = RemoveAllResourcePermissionsError;
/// Error type for the `RemoveAllResourcePermissionsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RemoveAllResourcePermissionsError {
    /// <p>The AWS Directory Service cannot reach an on-premises instance. Or a dependency under the control of the organization is failing, such as a connected Active Directory.</p>
    FailedDependencyException(crate::error::FailedDependencyException),
    /// <p>One or more of the dependencies is unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The operation is not permitted.</p>
    UnauthorizedOperationException(crate::error::UnauthorizedOperationException),
    /// <p>The caller does not have access to perform the action on the resource.</p>
    UnauthorizedResourceAccessException(crate::error::UnauthorizedResourceAccessException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for RemoveAllResourcePermissionsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for RemoveAllResourcePermissionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::FailedDependencyException(_inner) => _inner.fmt(f),
            Self::ServiceUnavailableException(_inner) => _inner.fmt(f),
            Self::UnauthorizedOperationException(_inner) => _inner.fmt(f),
            Self::UnauthorizedResourceAccessException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for RemoveAllResourcePermissionsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::FailedDependencyException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedResourceAccessException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::RemoveAllResourcePermissionsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for RemoveAllResourcePermissionsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl RemoveAllResourcePermissionsError {
    /// Creates the `RemoveAllResourcePermissionsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `RemoveAllResourcePermissionsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::FailedDependencyException(e) => e.meta(),
            Self::ServiceUnavailableException(e) => e.meta(),
            Self::UnauthorizedOperationException(e) => e.meta(),
            Self::UnauthorizedResourceAccessException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `RemoveAllResourcePermissionsError::FailedDependencyException`.
    pub fn is_failed_dependency_exception(&self) -> bool {
        matches!(self, Self::FailedDependencyException(_))
    }
    /// Returns `true` if the error kind is `RemoveAllResourcePermissionsError::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(self, Self::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `RemoveAllResourcePermissionsError::UnauthorizedOperationException`.
    pub fn is_unauthorized_operation_exception(&self) -> bool {
        matches!(self, Self::UnauthorizedOperationException(_))
    }
    /// Returns `true` if the error kind is `RemoveAllResourcePermissionsError::UnauthorizedResourceAccessException`.
    pub fn is_unauthorized_resource_access_exception(&self) -> bool {
        matches!(self, Self::UnauthorizedResourceAccessException(_))
    }
}
impl std::error::Error for RemoveAllResourcePermissionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::FailedDependencyException(_inner) => Some(_inner),
            Self::ServiceUnavailableException(_inner) => Some(_inner),
            Self::UnauthorizedOperationException(_inner) => Some(_inner),
            Self::UnauthorizedResourceAccessException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type InitiateDocumentVersionUploadErrorKind = InitiateDocumentVersionUploadError;
/// Error type for the `InitiateDocumentVersionUploadError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum InitiateDocumentVersionUploadError {
    /// <p>This exception is thrown when a valid checkout ID is not presented on document version upload calls for a document that has been checked out from Web client.</p>
    DraftUploadOutOfSyncException(crate::error::DraftUploadOutOfSyncException),
    /// <p>The resource already exists.</p>
    EntityAlreadyExistsException(crate::error::EntityAlreadyExistsException),
    /// <p>The resource does not exist.</p>
    EntityNotExistsException(crate::error::EntityNotExistsException),
    /// <p>The AWS Directory Service cannot reach an on-premises instance. Or a dependency under the control of the organization is failing, such as a connected Active Directory.</p>
    FailedDependencyException(crate::error::FailedDependencyException),
    /// <p>The password is invalid.</p>
    InvalidPasswordException(crate::error::InvalidPasswordException),
    /// <p>The maximum of 100,000 files and folders under the parent folder has been exceeded.</p>
    LimitExceededException(crate::error::LimitExceededException),
    /// <p>The specified document version is not in the INITIALIZED state.</p>
    ProhibitedStateException(crate::error::ProhibitedStateException),
    /// <p>The resource is already checked out.</p>
    ResourceAlreadyCheckedOutException(crate::error::ResourceAlreadyCheckedOutException),
    /// <p>One or more of the dependencies is unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The storage limit has been exceeded.</p>
    StorageLimitExceededException(crate::error::StorageLimitExceededException),
    /// <p>The storage limit will be exceeded.</p>
    StorageLimitWillExceedException(crate::error::StorageLimitWillExceedException),
    /// <p>The operation is not permitted.</p>
    UnauthorizedOperationException(crate::error::UnauthorizedOperationException),
    /// <p>The caller does not have access to perform the action on the resource.</p>
    UnauthorizedResourceAccessException(crate::error::UnauthorizedResourceAccessException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for InitiateDocumentVersionUploadError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for InitiateDocumentVersionUploadError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::DraftUploadOutOfSyncException(_inner) => _inner.fmt(f),
            Self::EntityAlreadyExistsException(_inner) => _inner.fmt(f),
            Self::EntityNotExistsException(_inner) => _inner.fmt(f),
            Self::FailedDependencyException(_inner) => _inner.fmt(f),
            Self::InvalidPasswordException(_inner) => _inner.fmt(f),
            Self::LimitExceededException(_inner) => _inner.fmt(f),
            Self::ProhibitedStateException(_inner) => _inner.fmt(f),
            Self::ResourceAlreadyCheckedOutException(_inner) => _inner.fmt(f),
            Self::ServiceUnavailableException(_inner) => _inner.fmt(f),
            Self::StorageLimitExceededException(_inner) => _inner.fmt(f),
            Self::StorageLimitWillExceedException(_inner) => _inner.fmt(f),
            Self::UnauthorizedOperationException(_inner) => _inner.fmt(f),
            Self::UnauthorizedResourceAccessException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for InitiateDocumentVersionUploadError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::DraftUploadOutOfSyncException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EntityAlreadyExistsException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EntityNotExistsException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::FailedDependencyException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidPasswordException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::LimitExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ProhibitedStateException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ResourceAlreadyCheckedOutException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::StorageLimitExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::StorageLimitWillExceedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedResourceAccessException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::InitiateDocumentVersionUploadError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for InitiateDocumentVersionUploadError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl InitiateDocumentVersionUploadError {
    /// Creates the `InitiateDocumentVersionUploadError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `InitiateDocumentVersionUploadError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::DraftUploadOutOfSyncException(e) => e.meta(),
            Self::EntityAlreadyExistsException(e) => e.meta(),
            Self::EntityNotExistsException(e) => e.meta(),
            Self::FailedDependencyException(e) => e.meta(),
            Self::InvalidPasswordException(e) => e.meta(),
            Self::LimitExceededException(e) => e.meta(),
            Self::ProhibitedStateException(e) => e.meta(),
            Self::ResourceAlreadyCheckedOutException(e) => e.meta(),
            Self::ServiceUnavailableException(e) => e.meta(),
            Self::StorageLimitExceededException(e) => e.meta(),
            Self::StorageLimitWillExceedException(e) => e.meta(),
            Self::UnauthorizedOperationException(e) => e.meta(),
            Self::UnauthorizedResourceAccessException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `InitiateDocumentVersionUploadError::DraftUploadOutOfSyncException`.
    pub fn is_draft_upload_out_of_sync_exception(&self) -> bool {
        matches!(self, Self::DraftUploadOutOfSyncException(_))
    }
    /// Returns `true` if the error kind is `InitiateDocumentVersionUploadError::EntityAlreadyExistsException`.
    pub fn is_entity_already_exists_exception(&self) -> bool {
        matches!(self, Self::EntityAlreadyExistsException(_))
    }
    /// Returns `true` if the error kind is `InitiateDocumentVersionUploadError::EntityNotExistsException`.
    pub fn is_entity_not_exists_exception(&self) -> bool {
        matches!(self, Self::EntityNotExistsException(_))
    }
    /// Returns `true` if the error kind is `InitiateDocumentVersionUploadError::FailedDependencyException`.
    pub fn is_failed_dependency_exception(&self) -> bool {
        matches!(self, Self::FailedDependencyException(_))
    }
    /// Returns `true` if the error kind is `InitiateDocumentVersionUploadError::InvalidPasswordException`.
    pub fn is_invalid_password_exception(&self) -> bool {
        matches!(self, Self::InvalidPasswordException(_))
    }
    /// Returns `true` if the error kind is `InitiateDocumentVersionUploadError::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(self, Self::LimitExceededException(_))
    }
    /// Returns `true` if the error kind is `InitiateDocumentVersionUploadError::ProhibitedStateException`.
    pub fn is_prohibited_state_exception(&self) -> bool {
        matches!(self, Self::ProhibitedStateException(_))
    }
    /// Returns `true` if the error kind is `InitiateDocumentVersionUploadError::ResourceAlreadyCheckedOutException`.
    pub fn is_resource_already_checked_out_exception(&self) -> bool {
        matches!(self, Self::ResourceAlreadyCheckedOutException(_))
    }
    /// Returns `true` if the error kind is `InitiateDocumentVersionUploadError::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(self, Self::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `InitiateDocumentVersionUploadError::StorageLimitExceededException`.
    pub fn is_storage_limit_exceeded_exception(&self) -> bool {
        matches!(self, Self::StorageLimitExceededException(_))
    }
    /// Returns `true` if the error kind is `InitiateDocumentVersionUploadError::StorageLimitWillExceedException`.
    pub fn is_storage_limit_will_exceed_exception(&self) -> bool {
        matches!(self, Self::StorageLimitWillExceedException(_))
    }
    /// Returns `true` if the error kind is `InitiateDocumentVersionUploadError::UnauthorizedOperationException`.
    pub fn is_unauthorized_operation_exception(&self) -> bool {
        matches!(self, Self::UnauthorizedOperationException(_))
    }
    /// Returns `true` if the error kind is `InitiateDocumentVersionUploadError::UnauthorizedResourceAccessException`.
    pub fn is_unauthorized_resource_access_exception(&self) -> bool {
        matches!(self, Self::UnauthorizedResourceAccessException(_))
    }
}
impl std::error::Error for InitiateDocumentVersionUploadError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::DraftUploadOutOfSyncException(_inner) => Some(_inner),
            Self::EntityAlreadyExistsException(_inner) => Some(_inner),
            Self::EntityNotExistsException(_inner) => Some(_inner),
            Self::FailedDependencyException(_inner) => Some(_inner),
            Self::InvalidPasswordException(_inner) => Some(_inner),
            Self::LimitExceededException(_inner) => Some(_inner),
            Self::ProhibitedStateException(_inner) => Some(_inner),
            Self::ResourceAlreadyCheckedOutException(_inner) => Some(_inner),
            Self::ServiceUnavailableException(_inner) => Some(_inner),
            Self::StorageLimitExceededException(_inner) => Some(_inner),
            Self::StorageLimitWillExceedException(_inner) => Some(_inner),
            Self::UnauthorizedOperationException(_inner) => Some(_inner),
            Self::UnauthorizedResourceAccessException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The storage limit will be exceeded.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct StorageLimitWillExceedException {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl StorageLimitWillExceedException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for StorageLimitWillExceedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "StorageLimitWillExceedException")?;
        if let Some(inner_15) = &self.message {
            {
                write!(f, ": {}", inner_15)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for StorageLimitWillExceedException {}
impl aws_http::request_id::RequestId for crate::error::StorageLimitWillExceedException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for StorageLimitWillExceedException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl StorageLimitWillExceedException {
    /// Creates a new builder-style object to manufacture [`StorageLimitWillExceedException`](crate::error::StorageLimitWillExceedException).
    pub fn builder() -> crate::error::storage_limit_will_exceed_exception::Builder {
        crate::error::storage_limit_will_exceed_exception::Builder::default()
    }
}

/// See [`StorageLimitWillExceedException`](crate::error::StorageLimitWillExceedException).
pub mod storage_limit_will_exceed_exception {

    /// A builder for [`StorageLimitWillExceedException`](crate::error::StorageLimitWillExceedException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`StorageLimitWillExceedException`](crate::error::StorageLimitWillExceedException).
        pub fn build(self) -> crate::error::StorageLimitWillExceedException {
            crate::error::StorageLimitWillExceedException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The storage limit has been exceeded.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct StorageLimitExceededException {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl StorageLimitExceededException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for StorageLimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "StorageLimitExceededException")?;
        if let Some(inner_16) = &self.message {
            {
                write!(f, ": {}", inner_16)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for StorageLimitExceededException {}
impl aws_http::request_id::RequestId for crate::error::StorageLimitExceededException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for StorageLimitExceededException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl StorageLimitExceededException {
    /// Creates a new builder-style object to manufacture [`StorageLimitExceededException`](crate::error::StorageLimitExceededException).
    pub fn builder() -> crate::error::storage_limit_exceeded_exception::Builder {
        crate::error::storage_limit_exceeded_exception::Builder::default()
    }
}

/// See [`StorageLimitExceededException`](crate::error::StorageLimitExceededException).
pub mod storage_limit_exceeded_exception {

    /// A builder for [`StorageLimitExceededException`](crate::error::StorageLimitExceededException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`StorageLimitExceededException`](crate::error::StorageLimitExceededException).
        pub fn build(self) -> crate::error::StorageLimitExceededException {
            crate::error::StorageLimitExceededException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The resource is already checked out.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ResourceAlreadyCheckedOutException {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ResourceAlreadyCheckedOutException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceAlreadyCheckedOutException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceAlreadyCheckedOutException")?;
        if let Some(inner_17) = &self.message {
            {
                write!(f, ": {}", inner_17)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ResourceAlreadyCheckedOutException {}
impl aws_http::request_id::RequestId for crate::error::ResourceAlreadyCheckedOutException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for ResourceAlreadyCheckedOutException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl ResourceAlreadyCheckedOutException {
    /// Creates a new builder-style object to manufacture [`ResourceAlreadyCheckedOutException`](crate::error::ResourceAlreadyCheckedOutException).
    pub fn builder() -> crate::error::resource_already_checked_out_exception::Builder {
        crate::error::resource_already_checked_out_exception::Builder::default()
    }
}

/// See [`ResourceAlreadyCheckedOutException`](crate::error::ResourceAlreadyCheckedOutException).
pub mod resource_already_checked_out_exception {

    /// A builder for [`ResourceAlreadyCheckedOutException`](crate::error::ResourceAlreadyCheckedOutException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`ResourceAlreadyCheckedOutException`](crate::error::ResourceAlreadyCheckedOutException).
        pub fn build(self) -> crate::error::ResourceAlreadyCheckedOutException {
            crate::error::ResourceAlreadyCheckedOutException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The password is invalid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidPasswordException {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidPasswordException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidPasswordException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidPasswordException")?;
        if let Some(inner_18) = &self.message {
            {
                write!(f, ": {}", inner_18)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidPasswordException {}
impl aws_http::request_id::RequestId for crate::error::InvalidPasswordException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidPasswordException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidPasswordException {
    /// Creates a new builder-style object to manufacture [`InvalidPasswordException`](crate::error::InvalidPasswordException).
    pub fn builder() -> crate::error::invalid_password_exception::Builder {
        crate::error::invalid_password_exception::Builder::default()
    }
}

/// See [`InvalidPasswordException`](crate::error::InvalidPasswordException).
pub mod invalid_password_exception {

    /// A builder for [`InvalidPasswordException`](crate::error::InvalidPasswordException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidPasswordException`](crate::error::InvalidPasswordException).
        pub fn build(self) -> crate::error::InvalidPasswordException {
            crate::error::InvalidPasswordException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>This exception is thrown when a valid checkout ID is not presented on document version upload calls for a document that has been checked out from Web client.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DraftUploadOutOfSyncException {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl DraftUploadOutOfSyncException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DraftUploadOutOfSyncException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DraftUploadOutOfSyncException")?;
        if let Some(inner_19) = &self.message {
            {
                write!(f, ": {}", inner_19)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for DraftUploadOutOfSyncException {}
impl aws_http::request_id::RequestId for crate::error::DraftUploadOutOfSyncException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DraftUploadOutOfSyncException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl DraftUploadOutOfSyncException {
    /// Creates a new builder-style object to manufacture [`DraftUploadOutOfSyncException`](crate::error::DraftUploadOutOfSyncException).
    pub fn builder() -> crate::error::draft_upload_out_of_sync_exception::Builder {
        crate::error::draft_upload_out_of_sync_exception::Builder::default()
    }
}

/// See [`DraftUploadOutOfSyncException`](crate::error::DraftUploadOutOfSyncException).
pub mod draft_upload_out_of_sync_exception {

    /// A builder for [`DraftUploadOutOfSyncException`](crate::error::DraftUploadOutOfSyncException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`DraftUploadOutOfSyncException`](crate::error::DraftUploadOutOfSyncException).
        pub fn build(self) -> crate::error::DraftUploadOutOfSyncException {
            crate::error::DraftUploadOutOfSyncException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type GetResourcesErrorKind = GetResourcesError;
/// Error type for the `GetResourcesError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetResourcesError {
    /// <p>The AWS Directory Service cannot reach an on-premises instance. Or a dependency under the control of the organization is failing, such as a connected Active Directory.</p>
    FailedDependencyException(crate::error::FailedDependencyException),
    /// <p>The pagination marker or limit fields are not valid.</p>
    InvalidArgumentException(crate::error::InvalidArgumentException),
    /// <p>One or more of the dependencies is unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The operation is not permitted.</p>
    UnauthorizedOperationException(crate::error::UnauthorizedOperationException),
    /// <p>The caller does not have access to perform the action on the resource.</p>
    UnauthorizedResourceAccessException(crate::error::UnauthorizedResourceAccessException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for GetResourcesError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for GetResourcesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::FailedDependencyException(_inner) => _inner.fmt(f),
            Self::InvalidArgumentException(_inner) => _inner.fmt(f),
            Self::ServiceUnavailableException(_inner) => _inner.fmt(f),
            Self::UnauthorizedOperationException(_inner) => _inner.fmt(f),
            Self::UnauthorizedResourceAccessException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for GetResourcesError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::FailedDependencyException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidArgumentException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedResourceAccessException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::GetResourcesError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetResourcesError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetResourcesError {
    /// Creates the `GetResourcesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `GetResourcesError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::FailedDependencyException(e) => e.meta(),
            Self::InvalidArgumentException(e) => e.meta(),
            Self::ServiceUnavailableException(e) => e.meta(),
            Self::UnauthorizedOperationException(e) => e.meta(),
            Self::UnauthorizedResourceAccessException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `GetResourcesError::FailedDependencyException`.
    pub fn is_failed_dependency_exception(&self) -> bool {
        matches!(self, Self::FailedDependencyException(_))
    }
    /// Returns `true` if the error kind is `GetResourcesError::InvalidArgumentException`.
    pub fn is_invalid_argument_exception(&self) -> bool {
        matches!(self, Self::InvalidArgumentException(_))
    }
    /// Returns `true` if the error kind is `GetResourcesError::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(self, Self::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `GetResourcesError::UnauthorizedOperationException`.
    pub fn is_unauthorized_operation_exception(&self) -> bool {
        matches!(self, Self::UnauthorizedOperationException(_))
    }
    /// Returns `true` if the error kind is `GetResourcesError::UnauthorizedResourceAccessException`.
    pub fn is_unauthorized_resource_access_exception(&self) -> bool {
        matches!(self, Self::UnauthorizedResourceAccessException(_))
    }
}
impl std::error::Error for GetResourcesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::FailedDependencyException(_inner) => Some(_inner),
            Self::InvalidArgumentException(_inner) => Some(_inner),
            Self::ServiceUnavailableException(_inner) => Some(_inner),
            Self::UnauthorizedOperationException(_inner) => Some(_inner),
            Self::UnauthorizedResourceAccessException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type GetFolderPathErrorKind = GetFolderPathError;
/// Error type for the `GetFolderPathError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetFolderPathError {
    /// <p>The resource does not exist.</p>
    EntityNotExistsException(crate::error::EntityNotExistsException),
    /// <p>The AWS Directory Service cannot reach an on-premises instance. Or a dependency under the control of the organization is failing, such as a connected Active Directory.</p>
    FailedDependencyException(crate::error::FailedDependencyException),
    /// <p>One or more of the dependencies is unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The operation is not permitted.</p>
    UnauthorizedOperationException(crate::error::UnauthorizedOperationException),
    /// <p>The caller does not have access to perform the action on the resource.</p>
    UnauthorizedResourceAccessException(crate::error::UnauthorizedResourceAccessException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for GetFolderPathError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for GetFolderPathError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::EntityNotExistsException(_inner) => _inner.fmt(f),
            Self::FailedDependencyException(_inner) => _inner.fmt(f),
            Self::ServiceUnavailableException(_inner) => _inner.fmt(f),
            Self::UnauthorizedOperationException(_inner) => _inner.fmt(f),
            Self::UnauthorizedResourceAccessException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for GetFolderPathError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::EntityNotExistsException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::FailedDependencyException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedResourceAccessException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::GetFolderPathError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetFolderPathError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetFolderPathError {
    /// Creates the `GetFolderPathError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `GetFolderPathError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::EntityNotExistsException(e) => e.meta(),
            Self::FailedDependencyException(e) => e.meta(),
            Self::ServiceUnavailableException(e) => e.meta(),
            Self::UnauthorizedOperationException(e) => e.meta(),
            Self::UnauthorizedResourceAccessException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `GetFolderPathError::EntityNotExistsException`.
    pub fn is_entity_not_exists_exception(&self) -> bool {
        matches!(self, Self::EntityNotExistsException(_))
    }
    /// Returns `true` if the error kind is `GetFolderPathError::FailedDependencyException`.
    pub fn is_failed_dependency_exception(&self) -> bool {
        matches!(self, Self::FailedDependencyException(_))
    }
    /// Returns `true` if the error kind is `GetFolderPathError::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(self, Self::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `GetFolderPathError::UnauthorizedOperationException`.
    pub fn is_unauthorized_operation_exception(&self) -> bool {
        matches!(self, Self::UnauthorizedOperationException(_))
    }
    /// Returns `true` if the error kind is `GetFolderPathError::UnauthorizedResourceAccessException`.
    pub fn is_unauthorized_resource_access_exception(&self) -> bool {
        matches!(self, Self::UnauthorizedResourceAccessException(_))
    }
}
impl std::error::Error for GetFolderPathError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::EntityNotExistsException(_inner) => Some(_inner),
            Self::FailedDependencyException(_inner) => Some(_inner),
            Self::ServiceUnavailableException(_inner) => Some(_inner),
            Self::UnauthorizedOperationException(_inner) => Some(_inner),
            Self::UnauthorizedResourceAccessException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type GetFolderErrorKind = GetFolderError;
/// Error type for the `GetFolderError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetFolderError {
    /// <p>The resource does not exist.</p>
    EntityNotExistsException(crate::error::EntityNotExistsException),
    /// <p>The AWS Directory Service cannot reach an on-premises instance. Or a dependency under the control of the organization is failing, such as a connected Active Directory.</p>
    FailedDependencyException(crate::error::FailedDependencyException),
    /// <p>The pagination marker or limit fields are not valid.</p>
    InvalidArgumentException(crate::error::InvalidArgumentException),
    /// <p>The specified document version is not in the INITIALIZED state.</p>
    ProhibitedStateException(crate::error::ProhibitedStateException),
    /// <p>One or more of the dependencies is unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The operation is not permitted.</p>
    UnauthorizedOperationException(crate::error::UnauthorizedOperationException),
    /// <p>The caller does not have access to perform the action on the resource.</p>
    UnauthorizedResourceAccessException(crate::error::UnauthorizedResourceAccessException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for GetFolderError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for GetFolderError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::EntityNotExistsException(_inner) => _inner.fmt(f),
            Self::FailedDependencyException(_inner) => _inner.fmt(f),
            Self::InvalidArgumentException(_inner) => _inner.fmt(f),
            Self::ProhibitedStateException(_inner) => _inner.fmt(f),
            Self::ServiceUnavailableException(_inner) => _inner.fmt(f),
            Self::UnauthorizedOperationException(_inner) => _inner.fmt(f),
            Self::UnauthorizedResourceAccessException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for GetFolderError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::EntityNotExistsException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::FailedDependencyException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidArgumentException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ProhibitedStateException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedResourceAccessException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::GetFolderError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetFolderError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetFolderError {
    /// Creates the `GetFolderError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `GetFolderError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::EntityNotExistsException(e) => e.meta(),
            Self::FailedDependencyException(e) => e.meta(),
            Self::InvalidArgumentException(e) => e.meta(),
            Self::ProhibitedStateException(e) => e.meta(),
            Self::ServiceUnavailableException(e) => e.meta(),
            Self::UnauthorizedOperationException(e) => e.meta(),
            Self::UnauthorizedResourceAccessException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `GetFolderError::EntityNotExistsException`.
    pub fn is_entity_not_exists_exception(&self) -> bool {
        matches!(self, Self::EntityNotExistsException(_))
    }
    /// Returns `true` if the error kind is `GetFolderError::FailedDependencyException`.
    pub fn is_failed_dependency_exception(&self) -> bool {
        matches!(self, Self::FailedDependencyException(_))
    }
    /// Returns `true` if the error kind is `GetFolderError::InvalidArgumentException`.
    pub fn is_invalid_argument_exception(&self) -> bool {
        matches!(self, Self::InvalidArgumentException(_))
    }
    /// Returns `true` if the error kind is `GetFolderError::ProhibitedStateException`.
    pub fn is_prohibited_state_exception(&self) -> bool {
        matches!(self, Self::ProhibitedStateException(_))
    }
    /// Returns `true` if the error kind is `GetFolderError::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(self, Self::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `GetFolderError::UnauthorizedOperationException`.
    pub fn is_unauthorized_operation_exception(&self) -> bool {
        matches!(self, Self::UnauthorizedOperationException(_))
    }
    /// Returns `true` if the error kind is `GetFolderError::UnauthorizedResourceAccessException`.
    pub fn is_unauthorized_resource_access_exception(&self) -> bool {
        matches!(self, Self::UnauthorizedResourceAccessException(_))
    }
}
impl std::error::Error for GetFolderError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::EntityNotExistsException(_inner) => Some(_inner),
            Self::FailedDependencyException(_inner) => Some(_inner),
            Self::InvalidArgumentException(_inner) => Some(_inner),
            Self::ProhibitedStateException(_inner) => Some(_inner),
            Self::ServiceUnavailableException(_inner) => Some(_inner),
            Self::UnauthorizedOperationException(_inner) => Some(_inner),
            Self::UnauthorizedResourceAccessException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type GetDocumentVersionErrorKind = GetDocumentVersionError;
/// Error type for the `GetDocumentVersionError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetDocumentVersionError {
    /// <p>The resource does not exist.</p>
    EntityNotExistsException(crate::error::EntityNotExistsException),
    /// <p>The AWS Directory Service cannot reach an on-premises instance. Or a dependency under the control of the organization is failing, such as a connected Active Directory.</p>
    FailedDependencyException(crate::error::FailedDependencyException),
    /// <p>The password is invalid.</p>
    InvalidPasswordException(crate::error::InvalidPasswordException),
    /// <p>The specified document version is not in the INITIALIZED state.</p>
    ProhibitedStateException(crate::error::ProhibitedStateException),
    /// <p>One or more of the dependencies is unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The operation is not permitted.</p>
    UnauthorizedOperationException(crate::error::UnauthorizedOperationException),
    /// <p>The caller does not have access to perform the action on the resource.</p>
    UnauthorizedResourceAccessException(crate::error::UnauthorizedResourceAccessException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for GetDocumentVersionError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for GetDocumentVersionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::EntityNotExistsException(_inner) => _inner.fmt(f),
            Self::FailedDependencyException(_inner) => _inner.fmt(f),
            Self::InvalidPasswordException(_inner) => _inner.fmt(f),
            Self::ProhibitedStateException(_inner) => _inner.fmt(f),
            Self::ServiceUnavailableException(_inner) => _inner.fmt(f),
            Self::UnauthorizedOperationException(_inner) => _inner.fmt(f),
            Self::UnauthorizedResourceAccessException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for GetDocumentVersionError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::EntityNotExistsException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::FailedDependencyException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidPasswordException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ProhibitedStateException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedResourceAccessException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::GetDocumentVersionError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetDocumentVersionError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetDocumentVersionError {
    /// Creates the `GetDocumentVersionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `GetDocumentVersionError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::EntityNotExistsException(e) => e.meta(),
            Self::FailedDependencyException(e) => e.meta(),
            Self::InvalidPasswordException(e) => e.meta(),
            Self::ProhibitedStateException(e) => e.meta(),
            Self::ServiceUnavailableException(e) => e.meta(),
            Self::UnauthorizedOperationException(e) => e.meta(),
            Self::UnauthorizedResourceAccessException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `GetDocumentVersionError::EntityNotExistsException`.
    pub fn is_entity_not_exists_exception(&self) -> bool {
        matches!(self, Self::EntityNotExistsException(_))
    }
    /// Returns `true` if the error kind is `GetDocumentVersionError::FailedDependencyException`.
    pub fn is_failed_dependency_exception(&self) -> bool {
        matches!(self, Self::FailedDependencyException(_))
    }
    /// Returns `true` if the error kind is `GetDocumentVersionError::InvalidPasswordException`.
    pub fn is_invalid_password_exception(&self) -> bool {
        matches!(self, Self::InvalidPasswordException(_))
    }
    /// Returns `true` if the error kind is `GetDocumentVersionError::ProhibitedStateException`.
    pub fn is_prohibited_state_exception(&self) -> bool {
        matches!(self, Self::ProhibitedStateException(_))
    }
    /// Returns `true` if the error kind is `GetDocumentVersionError::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(self, Self::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `GetDocumentVersionError::UnauthorizedOperationException`.
    pub fn is_unauthorized_operation_exception(&self) -> bool {
        matches!(self, Self::UnauthorizedOperationException(_))
    }
    /// Returns `true` if the error kind is `GetDocumentVersionError::UnauthorizedResourceAccessException`.
    pub fn is_unauthorized_resource_access_exception(&self) -> bool {
        matches!(self, Self::UnauthorizedResourceAccessException(_))
    }
}
impl std::error::Error for GetDocumentVersionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::EntityNotExistsException(_inner) => Some(_inner),
            Self::FailedDependencyException(_inner) => Some(_inner),
            Self::InvalidPasswordException(_inner) => Some(_inner),
            Self::ProhibitedStateException(_inner) => Some(_inner),
            Self::ServiceUnavailableException(_inner) => Some(_inner),
            Self::UnauthorizedOperationException(_inner) => Some(_inner),
            Self::UnauthorizedResourceAccessException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type GetDocumentPathErrorKind = GetDocumentPathError;
/// Error type for the `GetDocumentPathError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetDocumentPathError {
    /// <p>The resource does not exist.</p>
    EntityNotExistsException(crate::error::EntityNotExistsException),
    /// <p>The AWS Directory Service cannot reach an on-premises instance. Or a dependency under the control of the organization is failing, such as a connected Active Directory.</p>
    FailedDependencyException(crate::error::FailedDependencyException),
    /// <p>One or more of the dependencies is unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The operation is not permitted.</p>
    UnauthorizedOperationException(crate::error::UnauthorizedOperationException),
    /// <p>The caller does not have access to perform the action on the resource.</p>
    UnauthorizedResourceAccessException(crate::error::UnauthorizedResourceAccessException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for GetDocumentPathError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for GetDocumentPathError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::EntityNotExistsException(_inner) => _inner.fmt(f),
            Self::FailedDependencyException(_inner) => _inner.fmt(f),
            Self::ServiceUnavailableException(_inner) => _inner.fmt(f),
            Self::UnauthorizedOperationException(_inner) => _inner.fmt(f),
            Self::UnauthorizedResourceAccessException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for GetDocumentPathError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::EntityNotExistsException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::FailedDependencyException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedResourceAccessException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::GetDocumentPathError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetDocumentPathError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetDocumentPathError {
    /// Creates the `GetDocumentPathError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `GetDocumentPathError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::EntityNotExistsException(e) => e.meta(),
            Self::FailedDependencyException(e) => e.meta(),
            Self::ServiceUnavailableException(e) => e.meta(),
            Self::UnauthorizedOperationException(e) => e.meta(),
            Self::UnauthorizedResourceAccessException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `GetDocumentPathError::EntityNotExistsException`.
    pub fn is_entity_not_exists_exception(&self) -> bool {
        matches!(self, Self::EntityNotExistsException(_))
    }
    /// Returns `true` if the error kind is `GetDocumentPathError::FailedDependencyException`.
    pub fn is_failed_dependency_exception(&self) -> bool {
        matches!(self, Self::FailedDependencyException(_))
    }
    /// Returns `true` if the error kind is `GetDocumentPathError::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(self, Self::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `GetDocumentPathError::UnauthorizedOperationException`.
    pub fn is_unauthorized_operation_exception(&self) -> bool {
        matches!(self, Self::UnauthorizedOperationException(_))
    }
    /// Returns `true` if the error kind is `GetDocumentPathError::UnauthorizedResourceAccessException`.
    pub fn is_unauthorized_resource_access_exception(&self) -> bool {
        matches!(self, Self::UnauthorizedResourceAccessException(_))
    }
}
impl std::error::Error for GetDocumentPathError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::EntityNotExistsException(_inner) => Some(_inner),
            Self::FailedDependencyException(_inner) => Some(_inner),
            Self::ServiceUnavailableException(_inner) => Some(_inner),
            Self::UnauthorizedOperationException(_inner) => Some(_inner),
            Self::UnauthorizedResourceAccessException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type GetDocumentErrorKind = GetDocumentError;
/// Error type for the `GetDocumentError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetDocumentError {
    /// <p>The resource does not exist.</p>
    EntityNotExistsException(crate::error::EntityNotExistsException),
    /// <p>The AWS Directory Service cannot reach an on-premises instance. Or a dependency under the control of the organization is failing, such as a connected Active Directory.</p>
    FailedDependencyException(crate::error::FailedDependencyException),
    /// <p>The pagination marker or limit fields are not valid.</p>
    InvalidArgumentException(crate::error::InvalidArgumentException),
    /// <p>The password is invalid.</p>
    InvalidPasswordException(crate::error::InvalidPasswordException),
    /// <p>One or more of the dependencies is unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The operation is not permitted.</p>
    UnauthorizedOperationException(crate::error::UnauthorizedOperationException),
    /// <p>The caller does not have access to perform the action on the resource.</p>
    UnauthorizedResourceAccessException(crate::error::UnauthorizedResourceAccessException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for GetDocumentError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for GetDocumentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::EntityNotExistsException(_inner) => _inner.fmt(f),
            Self::FailedDependencyException(_inner) => _inner.fmt(f),
            Self::InvalidArgumentException(_inner) => _inner.fmt(f),
            Self::InvalidPasswordException(_inner) => _inner.fmt(f),
            Self::ServiceUnavailableException(_inner) => _inner.fmt(f),
            Self::UnauthorizedOperationException(_inner) => _inner.fmt(f),
            Self::UnauthorizedResourceAccessException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for GetDocumentError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::EntityNotExistsException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::FailedDependencyException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidArgumentException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidPasswordException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedResourceAccessException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::GetDocumentError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetDocumentError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetDocumentError {
    /// Creates the `GetDocumentError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `GetDocumentError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::EntityNotExistsException(e) => e.meta(),
            Self::FailedDependencyException(e) => e.meta(),
            Self::InvalidArgumentException(e) => e.meta(),
            Self::InvalidPasswordException(e) => e.meta(),
            Self::ServiceUnavailableException(e) => e.meta(),
            Self::UnauthorizedOperationException(e) => e.meta(),
            Self::UnauthorizedResourceAccessException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `GetDocumentError::EntityNotExistsException`.
    pub fn is_entity_not_exists_exception(&self) -> bool {
        matches!(self, Self::EntityNotExistsException(_))
    }
    /// Returns `true` if the error kind is `GetDocumentError::FailedDependencyException`.
    pub fn is_failed_dependency_exception(&self) -> bool {
        matches!(self, Self::FailedDependencyException(_))
    }
    /// Returns `true` if the error kind is `GetDocumentError::InvalidArgumentException`.
    pub fn is_invalid_argument_exception(&self) -> bool {
        matches!(self, Self::InvalidArgumentException(_))
    }
    /// Returns `true` if the error kind is `GetDocumentError::InvalidPasswordException`.
    pub fn is_invalid_password_exception(&self) -> bool {
        matches!(self, Self::InvalidPasswordException(_))
    }
    /// Returns `true` if the error kind is `GetDocumentError::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(self, Self::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `GetDocumentError::UnauthorizedOperationException`.
    pub fn is_unauthorized_operation_exception(&self) -> bool {
        matches!(self, Self::UnauthorizedOperationException(_))
    }
    /// Returns `true` if the error kind is `GetDocumentError::UnauthorizedResourceAccessException`.
    pub fn is_unauthorized_resource_access_exception(&self) -> bool {
        matches!(self, Self::UnauthorizedResourceAccessException(_))
    }
}
impl std::error::Error for GetDocumentError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::EntityNotExistsException(_inner) => Some(_inner),
            Self::FailedDependencyException(_inner) => Some(_inner),
            Self::InvalidArgumentException(_inner) => Some(_inner),
            Self::InvalidPasswordException(_inner) => Some(_inner),
            Self::ServiceUnavailableException(_inner) => Some(_inner),
            Self::UnauthorizedOperationException(_inner) => Some(_inner),
            Self::UnauthorizedResourceAccessException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type GetCurrentUserErrorKind = GetCurrentUserError;
/// Error type for the `GetCurrentUserError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetCurrentUserError {
    /// <p>The resource does not exist.</p>
    EntityNotExistsException(crate::error::EntityNotExistsException),
    /// <p>The AWS Directory Service cannot reach an on-premises instance. Or a dependency under the control of the organization is failing, such as a connected Active Directory.</p>
    FailedDependencyException(crate::error::FailedDependencyException),
    /// <p>One or more of the dependencies is unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The operation is not permitted.</p>
    UnauthorizedOperationException(crate::error::UnauthorizedOperationException),
    /// <p>The caller does not have access to perform the action on the resource.</p>
    UnauthorizedResourceAccessException(crate::error::UnauthorizedResourceAccessException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for GetCurrentUserError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for GetCurrentUserError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::EntityNotExistsException(_inner) => _inner.fmt(f),
            Self::FailedDependencyException(_inner) => _inner.fmt(f),
            Self::ServiceUnavailableException(_inner) => _inner.fmt(f),
            Self::UnauthorizedOperationException(_inner) => _inner.fmt(f),
            Self::UnauthorizedResourceAccessException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for GetCurrentUserError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::EntityNotExistsException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::FailedDependencyException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedResourceAccessException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::GetCurrentUserError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetCurrentUserError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetCurrentUserError {
    /// Creates the `GetCurrentUserError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `GetCurrentUserError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::EntityNotExistsException(e) => e.meta(),
            Self::FailedDependencyException(e) => e.meta(),
            Self::ServiceUnavailableException(e) => e.meta(),
            Self::UnauthorizedOperationException(e) => e.meta(),
            Self::UnauthorizedResourceAccessException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `GetCurrentUserError::EntityNotExistsException`.
    pub fn is_entity_not_exists_exception(&self) -> bool {
        matches!(self, Self::EntityNotExistsException(_))
    }
    /// Returns `true` if the error kind is `GetCurrentUserError::FailedDependencyException`.
    pub fn is_failed_dependency_exception(&self) -> bool {
        matches!(self, Self::FailedDependencyException(_))
    }
    /// Returns `true` if the error kind is `GetCurrentUserError::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(self, Self::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `GetCurrentUserError::UnauthorizedOperationException`.
    pub fn is_unauthorized_operation_exception(&self) -> bool {
        matches!(self, Self::UnauthorizedOperationException(_))
    }
    /// Returns `true` if the error kind is `GetCurrentUserError::UnauthorizedResourceAccessException`.
    pub fn is_unauthorized_resource_access_exception(&self) -> bool {
        matches!(self, Self::UnauthorizedResourceAccessException(_))
    }
}
impl std::error::Error for GetCurrentUserError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::EntityNotExistsException(_inner) => Some(_inner),
            Self::FailedDependencyException(_inner) => Some(_inner),
            Self::ServiceUnavailableException(_inner) => Some(_inner),
            Self::UnauthorizedOperationException(_inner) => Some(_inner),
            Self::UnauthorizedResourceAccessException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribeUsersErrorKind = DescribeUsersError;
/// Error type for the `DescribeUsersError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeUsersError {
    /// <p>The resource does not exist.</p>
    EntityNotExistsException(crate::error::EntityNotExistsException),
    /// <p>The AWS Directory Service cannot reach an on-premises instance. Or a dependency under the control of the organization is failing, such as a connected Active Directory.</p>
    FailedDependencyException(crate::error::FailedDependencyException),
    /// <p>The pagination marker or limit fields are not valid.</p>
    InvalidArgumentException(crate::error::InvalidArgumentException),
    /// <p>The response is too large to return. The request must include a filter to reduce the size of the response.</p>
    RequestedEntityTooLargeException(crate::error::RequestedEntityTooLargeException),
    /// <p>One or more of the dependencies is unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The operation is not permitted.</p>
    UnauthorizedOperationException(crate::error::UnauthorizedOperationException),
    /// <p>The caller does not have access to perform the action on the resource.</p>
    UnauthorizedResourceAccessException(crate::error::UnauthorizedResourceAccessException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeUsersError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribeUsersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::EntityNotExistsException(_inner) => _inner.fmt(f),
            Self::FailedDependencyException(_inner) => _inner.fmt(f),
            Self::InvalidArgumentException(_inner) => _inner.fmt(f),
            Self::RequestedEntityTooLargeException(_inner) => _inner.fmt(f),
            Self::ServiceUnavailableException(_inner) => _inner.fmt(f),
            Self::UnauthorizedOperationException(_inner) => _inner.fmt(f),
            Self::UnauthorizedResourceAccessException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DescribeUsersError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::EntityNotExistsException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::FailedDependencyException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidArgumentException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RequestedEntityTooLargeException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedResourceAccessException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeUsersError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeUsersError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeUsersError {
    /// Creates the `DescribeUsersError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribeUsersError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::EntityNotExistsException(e) => e.meta(),
            Self::FailedDependencyException(e) => e.meta(),
            Self::InvalidArgumentException(e) => e.meta(),
            Self::RequestedEntityTooLargeException(e) => e.meta(),
            Self::ServiceUnavailableException(e) => e.meta(),
            Self::UnauthorizedOperationException(e) => e.meta(),
            Self::UnauthorizedResourceAccessException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribeUsersError::EntityNotExistsException`.
    pub fn is_entity_not_exists_exception(&self) -> bool {
        matches!(self, Self::EntityNotExistsException(_))
    }
    /// Returns `true` if the error kind is `DescribeUsersError::FailedDependencyException`.
    pub fn is_failed_dependency_exception(&self) -> bool {
        matches!(self, Self::FailedDependencyException(_))
    }
    /// Returns `true` if the error kind is `DescribeUsersError::InvalidArgumentException`.
    pub fn is_invalid_argument_exception(&self) -> bool {
        matches!(self, Self::InvalidArgumentException(_))
    }
    /// Returns `true` if the error kind is `DescribeUsersError::RequestedEntityTooLargeException`.
    pub fn is_requested_entity_too_large_exception(&self) -> bool {
        matches!(self, Self::RequestedEntityTooLargeException(_))
    }
    /// Returns `true` if the error kind is `DescribeUsersError::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(self, Self::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `DescribeUsersError::UnauthorizedOperationException`.
    pub fn is_unauthorized_operation_exception(&self) -> bool {
        matches!(self, Self::UnauthorizedOperationException(_))
    }
    /// Returns `true` if the error kind is `DescribeUsersError::UnauthorizedResourceAccessException`.
    pub fn is_unauthorized_resource_access_exception(&self) -> bool {
        matches!(self, Self::UnauthorizedResourceAccessException(_))
    }
}
impl std::error::Error for DescribeUsersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::EntityNotExistsException(_inner) => Some(_inner),
            Self::FailedDependencyException(_inner) => Some(_inner),
            Self::InvalidArgumentException(_inner) => Some(_inner),
            Self::RequestedEntityTooLargeException(_inner) => Some(_inner),
            Self::ServiceUnavailableException(_inner) => Some(_inner),
            Self::UnauthorizedOperationException(_inner) => Some(_inner),
            Self::UnauthorizedResourceAccessException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The response is too large to return. The request must include a filter to reduce the size of the response.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RequestedEntityTooLargeException {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl RequestedEntityTooLargeException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for RequestedEntityTooLargeException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "RequestedEntityTooLargeException")?;
        if let Some(inner_20) = &self.message {
            {
                write!(f, ": {}", inner_20)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for RequestedEntityTooLargeException {}
impl aws_http::request_id::RequestId for crate::error::RequestedEntityTooLargeException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for RequestedEntityTooLargeException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl RequestedEntityTooLargeException {
    /// Creates a new builder-style object to manufacture [`RequestedEntityTooLargeException`](crate::error::RequestedEntityTooLargeException).
    pub fn builder() -> crate::error::requested_entity_too_large_exception::Builder {
        crate::error::requested_entity_too_large_exception::Builder::default()
    }
}

/// See [`RequestedEntityTooLargeException`](crate::error::RequestedEntityTooLargeException).
pub mod requested_entity_too_large_exception {

    /// A builder for [`RequestedEntityTooLargeException`](crate::error::RequestedEntityTooLargeException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`RequestedEntityTooLargeException`](crate::error::RequestedEntityTooLargeException).
        pub fn build(self) -> crate::error::RequestedEntityTooLargeException {
            crate::error::RequestedEntityTooLargeException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribeRootFoldersErrorKind = DescribeRootFoldersError;
/// Error type for the `DescribeRootFoldersError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeRootFoldersError {
    /// <p>The AWS Directory Service cannot reach an on-premises instance. Or a dependency under the control of the organization is failing, such as a connected Active Directory.</p>
    FailedDependencyException(crate::error::FailedDependencyException),
    /// <p>The pagination marker or limit fields are not valid.</p>
    InvalidArgumentException(crate::error::InvalidArgumentException),
    /// <p>One or more of the dependencies is unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The operation is not permitted.</p>
    UnauthorizedOperationException(crate::error::UnauthorizedOperationException),
    /// <p>The caller does not have access to perform the action on the resource.</p>
    UnauthorizedResourceAccessException(crate::error::UnauthorizedResourceAccessException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeRootFoldersError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribeRootFoldersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::FailedDependencyException(_inner) => _inner.fmt(f),
            Self::InvalidArgumentException(_inner) => _inner.fmt(f),
            Self::ServiceUnavailableException(_inner) => _inner.fmt(f),
            Self::UnauthorizedOperationException(_inner) => _inner.fmt(f),
            Self::UnauthorizedResourceAccessException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DescribeRootFoldersError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::FailedDependencyException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidArgumentException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedResourceAccessException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeRootFoldersError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeRootFoldersError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeRootFoldersError {
    /// Creates the `DescribeRootFoldersError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribeRootFoldersError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::FailedDependencyException(e) => e.meta(),
            Self::InvalidArgumentException(e) => e.meta(),
            Self::ServiceUnavailableException(e) => e.meta(),
            Self::UnauthorizedOperationException(e) => e.meta(),
            Self::UnauthorizedResourceAccessException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribeRootFoldersError::FailedDependencyException`.
    pub fn is_failed_dependency_exception(&self) -> bool {
        matches!(self, Self::FailedDependencyException(_))
    }
    /// Returns `true` if the error kind is `DescribeRootFoldersError::InvalidArgumentException`.
    pub fn is_invalid_argument_exception(&self) -> bool {
        matches!(self, Self::InvalidArgumentException(_))
    }
    /// Returns `true` if the error kind is `DescribeRootFoldersError::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(self, Self::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `DescribeRootFoldersError::UnauthorizedOperationException`.
    pub fn is_unauthorized_operation_exception(&self) -> bool {
        matches!(self, Self::UnauthorizedOperationException(_))
    }
    /// Returns `true` if the error kind is `DescribeRootFoldersError::UnauthorizedResourceAccessException`.
    pub fn is_unauthorized_resource_access_exception(&self) -> bool {
        matches!(self, Self::UnauthorizedResourceAccessException(_))
    }
}
impl std::error::Error for DescribeRootFoldersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::FailedDependencyException(_inner) => Some(_inner),
            Self::InvalidArgumentException(_inner) => Some(_inner),
            Self::ServiceUnavailableException(_inner) => Some(_inner),
            Self::UnauthorizedOperationException(_inner) => Some(_inner),
            Self::UnauthorizedResourceAccessException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribeResourcePermissionsErrorKind = DescribeResourcePermissionsError;
/// Error type for the `DescribeResourcePermissionsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeResourcePermissionsError {
    /// <p>The AWS Directory Service cannot reach an on-premises instance. Or a dependency under the control of the organization is failing, such as a connected Active Directory.</p>
    FailedDependencyException(crate::error::FailedDependencyException),
    /// <p>The pagination marker or limit fields are not valid.</p>
    InvalidArgumentException(crate::error::InvalidArgumentException),
    /// <p>One or more of the dependencies is unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The operation is not permitted.</p>
    UnauthorizedOperationException(crate::error::UnauthorizedOperationException),
    /// <p>The caller does not have access to perform the action on the resource.</p>
    UnauthorizedResourceAccessException(crate::error::UnauthorizedResourceAccessException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeResourcePermissionsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribeResourcePermissionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::FailedDependencyException(_inner) => _inner.fmt(f),
            Self::InvalidArgumentException(_inner) => _inner.fmt(f),
            Self::ServiceUnavailableException(_inner) => _inner.fmt(f),
            Self::UnauthorizedOperationException(_inner) => _inner.fmt(f),
            Self::UnauthorizedResourceAccessException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DescribeResourcePermissionsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::FailedDependencyException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidArgumentException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedResourceAccessException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeResourcePermissionsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeResourcePermissionsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeResourcePermissionsError {
    /// Creates the `DescribeResourcePermissionsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribeResourcePermissionsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::FailedDependencyException(e) => e.meta(),
            Self::InvalidArgumentException(e) => e.meta(),
            Self::ServiceUnavailableException(e) => e.meta(),
            Self::UnauthorizedOperationException(e) => e.meta(),
            Self::UnauthorizedResourceAccessException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribeResourcePermissionsError::FailedDependencyException`.
    pub fn is_failed_dependency_exception(&self) -> bool {
        matches!(self, Self::FailedDependencyException(_))
    }
    /// Returns `true` if the error kind is `DescribeResourcePermissionsError::InvalidArgumentException`.
    pub fn is_invalid_argument_exception(&self) -> bool {
        matches!(self, Self::InvalidArgumentException(_))
    }
    /// Returns `true` if the error kind is `DescribeResourcePermissionsError::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(self, Self::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `DescribeResourcePermissionsError::UnauthorizedOperationException`.
    pub fn is_unauthorized_operation_exception(&self) -> bool {
        matches!(self, Self::UnauthorizedOperationException(_))
    }
    /// Returns `true` if the error kind is `DescribeResourcePermissionsError::UnauthorizedResourceAccessException`.
    pub fn is_unauthorized_resource_access_exception(&self) -> bool {
        matches!(self, Self::UnauthorizedResourceAccessException(_))
    }
}
impl std::error::Error for DescribeResourcePermissionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::FailedDependencyException(_inner) => Some(_inner),
            Self::InvalidArgumentException(_inner) => Some(_inner),
            Self::ServiceUnavailableException(_inner) => Some(_inner),
            Self::UnauthorizedOperationException(_inner) => Some(_inner),
            Self::UnauthorizedResourceAccessException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribeNotificationSubscriptionsErrorKind = DescribeNotificationSubscriptionsError;
/// Error type for the `DescribeNotificationSubscriptionsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeNotificationSubscriptionsError {
    /// <p>The resource does not exist.</p>
    EntityNotExistsException(crate::error::EntityNotExistsException),
    /// <p>One or more of the dependencies is unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The caller does not have access to perform the action on the resource.</p>
    UnauthorizedResourceAccessException(crate::error::UnauthorizedResourceAccessException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeNotificationSubscriptionsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribeNotificationSubscriptionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::EntityNotExistsException(_inner) => _inner.fmt(f),
            Self::ServiceUnavailableException(_inner) => _inner.fmt(f),
            Self::UnauthorizedResourceAccessException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for DescribeNotificationSubscriptionsError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::EntityNotExistsException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedResourceAccessException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeNotificationSubscriptionsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeNotificationSubscriptionsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeNotificationSubscriptionsError {
    /// Creates the `DescribeNotificationSubscriptionsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribeNotificationSubscriptionsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::EntityNotExistsException(e) => e.meta(),
            Self::ServiceUnavailableException(e) => e.meta(),
            Self::UnauthorizedResourceAccessException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribeNotificationSubscriptionsError::EntityNotExistsException`.
    pub fn is_entity_not_exists_exception(&self) -> bool {
        matches!(self, Self::EntityNotExistsException(_))
    }
    /// Returns `true` if the error kind is `DescribeNotificationSubscriptionsError::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(self, Self::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `DescribeNotificationSubscriptionsError::UnauthorizedResourceAccessException`.
    pub fn is_unauthorized_resource_access_exception(&self) -> bool {
        matches!(self, Self::UnauthorizedResourceAccessException(_))
    }
}
impl std::error::Error for DescribeNotificationSubscriptionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::EntityNotExistsException(_inner) => Some(_inner),
            Self::ServiceUnavailableException(_inner) => Some(_inner),
            Self::UnauthorizedResourceAccessException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribeGroupsErrorKind = DescribeGroupsError;
/// Error type for the `DescribeGroupsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeGroupsError {
    /// <p>The AWS Directory Service cannot reach an on-premises instance. Or a dependency under the control of the organization is failing, such as a connected Active Directory.</p>
    FailedDependencyException(crate::error::FailedDependencyException),
    /// <p>One or more of the dependencies is unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The operation is not permitted.</p>
    UnauthorizedOperationException(crate::error::UnauthorizedOperationException),
    /// <p>The caller does not have access to perform the action on the resource.</p>
    UnauthorizedResourceAccessException(crate::error::UnauthorizedResourceAccessException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeGroupsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribeGroupsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::FailedDependencyException(_inner) => _inner.fmt(f),
            Self::ServiceUnavailableException(_inner) => _inner.fmt(f),
            Self::UnauthorizedOperationException(_inner) => _inner.fmt(f),
            Self::UnauthorizedResourceAccessException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DescribeGroupsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::FailedDependencyException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedResourceAccessException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeGroupsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeGroupsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeGroupsError {
    /// Creates the `DescribeGroupsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribeGroupsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::FailedDependencyException(e) => e.meta(),
            Self::ServiceUnavailableException(e) => e.meta(),
            Self::UnauthorizedOperationException(e) => e.meta(),
            Self::UnauthorizedResourceAccessException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribeGroupsError::FailedDependencyException`.
    pub fn is_failed_dependency_exception(&self) -> bool {
        matches!(self, Self::FailedDependencyException(_))
    }
    /// Returns `true` if the error kind is `DescribeGroupsError::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(self, Self::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `DescribeGroupsError::UnauthorizedOperationException`.
    pub fn is_unauthorized_operation_exception(&self) -> bool {
        matches!(self, Self::UnauthorizedOperationException(_))
    }
    /// Returns `true` if the error kind is `DescribeGroupsError::UnauthorizedResourceAccessException`.
    pub fn is_unauthorized_resource_access_exception(&self) -> bool {
        matches!(self, Self::UnauthorizedResourceAccessException(_))
    }
}
impl std::error::Error for DescribeGroupsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::FailedDependencyException(_inner) => Some(_inner),
            Self::ServiceUnavailableException(_inner) => Some(_inner),
            Self::UnauthorizedOperationException(_inner) => Some(_inner),
            Self::UnauthorizedResourceAccessException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribeFolderContentsErrorKind = DescribeFolderContentsError;
/// Error type for the `DescribeFolderContentsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeFolderContentsError {
    /// <p>The resource does not exist.</p>
    EntityNotExistsException(crate::error::EntityNotExistsException),
    /// <p>The AWS Directory Service cannot reach an on-premises instance. Or a dependency under the control of the organization is failing, such as a connected Active Directory.</p>
    FailedDependencyException(crate::error::FailedDependencyException),
    /// <p>The pagination marker or limit fields are not valid.</p>
    InvalidArgumentException(crate::error::InvalidArgumentException),
    /// <p>The specified document version is not in the INITIALIZED state.</p>
    ProhibitedStateException(crate::error::ProhibitedStateException),
    /// <p>One or more of the dependencies is unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The caller does not have access to perform the action on the resource.</p>
    UnauthorizedResourceAccessException(crate::error::UnauthorizedResourceAccessException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeFolderContentsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribeFolderContentsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::EntityNotExistsException(_inner) => _inner.fmt(f),
            Self::FailedDependencyException(_inner) => _inner.fmt(f),
            Self::InvalidArgumentException(_inner) => _inner.fmt(f),
            Self::ProhibitedStateException(_inner) => _inner.fmt(f),
            Self::ServiceUnavailableException(_inner) => _inner.fmt(f),
            Self::UnauthorizedResourceAccessException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DescribeFolderContentsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::EntityNotExistsException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::FailedDependencyException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidArgumentException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ProhibitedStateException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedResourceAccessException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeFolderContentsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeFolderContentsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeFolderContentsError {
    /// Creates the `DescribeFolderContentsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribeFolderContentsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::EntityNotExistsException(e) => e.meta(),
            Self::FailedDependencyException(e) => e.meta(),
            Self::InvalidArgumentException(e) => e.meta(),
            Self::ProhibitedStateException(e) => e.meta(),
            Self::ServiceUnavailableException(e) => e.meta(),
            Self::UnauthorizedResourceAccessException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribeFolderContentsError::EntityNotExistsException`.
    pub fn is_entity_not_exists_exception(&self) -> bool {
        matches!(self, Self::EntityNotExistsException(_))
    }
    /// Returns `true` if the error kind is `DescribeFolderContentsError::FailedDependencyException`.
    pub fn is_failed_dependency_exception(&self) -> bool {
        matches!(self, Self::FailedDependencyException(_))
    }
    /// Returns `true` if the error kind is `DescribeFolderContentsError::InvalidArgumentException`.
    pub fn is_invalid_argument_exception(&self) -> bool {
        matches!(self, Self::InvalidArgumentException(_))
    }
    /// Returns `true` if the error kind is `DescribeFolderContentsError::ProhibitedStateException`.
    pub fn is_prohibited_state_exception(&self) -> bool {
        matches!(self, Self::ProhibitedStateException(_))
    }
    /// Returns `true` if the error kind is `DescribeFolderContentsError::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(self, Self::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `DescribeFolderContentsError::UnauthorizedResourceAccessException`.
    pub fn is_unauthorized_resource_access_exception(&self) -> bool {
        matches!(self, Self::UnauthorizedResourceAccessException(_))
    }
}
impl std::error::Error for DescribeFolderContentsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::EntityNotExistsException(_inner) => Some(_inner),
            Self::FailedDependencyException(_inner) => Some(_inner),
            Self::InvalidArgumentException(_inner) => Some(_inner),
            Self::ProhibitedStateException(_inner) => Some(_inner),
            Self::ServiceUnavailableException(_inner) => Some(_inner),
            Self::UnauthorizedResourceAccessException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribeDocumentVersionsErrorKind = DescribeDocumentVersionsError;
/// Error type for the `DescribeDocumentVersionsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeDocumentVersionsError {
    /// <p>The resource does not exist.</p>
    EntityNotExistsException(crate::error::EntityNotExistsException),
    /// <p>The AWS Directory Service cannot reach an on-premises instance. Or a dependency under the control of the organization is failing, such as a connected Active Directory.</p>
    FailedDependencyException(crate::error::FailedDependencyException),
    /// <p>The pagination marker or limit fields are not valid.</p>
    InvalidArgumentException(crate::error::InvalidArgumentException),
    /// <p>The password is invalid.</p>
    InvalidPasswordException(crate::error::InvalidPasswordException),
    /// <p>The specified document version is not in the INITIALIZED state.</p>
    ProhibitedStateException(crate::error::ProhibitedStateException),
    /// <p>One or more of the dependencies is unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The operation is not permitted.</p>
    UnauthorizedOperationException(crate::error::UnauthorizedOperationException),
    /// <p>The caller does not have access to perform the action on the resource.</p>
    UnauthorizedResourceAccessException(crate::error::UnauthorizedResourceAccessException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeDocumentVersionsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribeDocumentVersionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::EntityNotExistsException(_inner) => _inner.fmt(f),
            Self::FailedDependencyException(_inner) => _inner.fmt(f),
            Self::InvalidArgumentException(_inner) => _inner.fmt(f),
            Self::InvalidPasswordException(_inner) => _inner.fmt(f),
            Self::ProhibitedStateException(_inner) => _inner.fmt(f),
            Self::ServiceUnavailableException(_inner) => _inner.fmt(f),
            Self::UnauthorizedOperationException(_inner) => _inner.fmt(f),
            Self::UnauthorizedResourceAccessException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DescribeDocumentVersionsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::EntityNotExistsException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::FailedDependencyException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidArgumentException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidPasswordException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ProhibitedStateException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedResourceAccessException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeDocumentVersionsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeDocumentVersionsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeDocumentVersionsError {
    /// Creates the `DescribeDocumentVersionsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribeDocumentVersionsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::EntityNotExistsException(e) => e.meta(),
            Self::FailedDependencyException(e) => e.meta(),
            Self::InvalidArgumentException(e) => e.meta(),
            Self::InvalidPasswordException(e) => e.meta(),
            Self::ProhibitedStateException(e) => e.meta(),
            Self::ServiceUnavailableException(e) => e.meta(),
            Self::UnauthorizedOperationException(e) => e.meta(),
            Self::UnauthorizedResourceAccessException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribeDocumentVersionsError::EntityNotExistsException`.
    pub fn is_entity_not_exists_exception(&self) -> bool {
        matches!(self, Self::EntityNotExistsException(_))
    }
    /// Returns `true` if the error kind is `DescribeDocumentVersionsError::FailedDependencyException`.
    pub fn is_failed_dependency_exception(&self) -> bool {
        matches!(self, Self::FailedDependencyException(_))
    }
    /// Returns `true` if the error kind is `DescribeDocumentVersionsError::InvalidArgumentException`.
    pub fn is_invalid_argument_exception(&self) -> bool {
        matches!(self, Self::InvalidArgumentException(_))
    }
    /// Returns `true` if the error kind is `DescribeDocumentVersionsError::InvalidPasswordException`.
    pub fn is_invalid_password_exception(&self) -> bool {
        matches!(self, Self::InvalidPasswordException(_))
    }
    /// Returns `true` if the error kind is `DescribeDocumentVersionsError::ProhibitedStateException`.
    pub fn is_prohibited_state_exception(&self) -> bool {
        matches!(self, Self::ProhibitedStateException(_))
    }
    /// Returns `true` if the error kind is `DescribeDocumentVersionsError::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(self, Self::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `DescribeDocumentVersionsError::UnauthorizedOperationException`.
    pub fn is_unauthorized_operation_exception(&self) -> bool {
        matches!(self, Self::UnauthorizedOperationException(_))
    }
    /// Returns `true` if the error kind is `DescribeDocumentVersionsError::UnauthorizedResourceAccessException`.
    pub fn is_unauthorized_resource_access_exception(&self) -> bool {
        matches!(self, Self::UnauthorizedResourceAccessException(_))
    }
}
impl std::error::Error for DescribeDocumentVersionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::EntityNotExistsException(_inner) => Some(_inner),
            Self::FailedDependencyException(_inner) => Some(_inner),
            Self::InvalidArgumentException(_inner) => Some(_inner),
            Self::InvalidPasswordException(_inner) => Some(_inner),
            Self::ProhibitedStateException(_inner) => Some(_inner),
            Self::ServiceUnavailableException(_inner) => Some(_inner),
            Self::UnauthorizedOperationException(_inner) => Some(_inner),
            Self::UnauthorizedResourceAccessException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribeCommentsErrorKind = DescribeCommentsError;
/// Error type for the `DescribeCommentsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeCommentsError {
    /// <p>The resource does not exist.</p>
    EntityNotExistsException(crate::error::EntityNotExistsException),
    /// <p>The AWS Directory Service cannot reach an on-premises instance. Or a dependency under the control of the organization is failing, such as a connected Active Directory.</p>
    FailedDependencyException(crate::error::FailedDependencyException),
    /// <p>The specified document version is not in the INITIALIZED state.</p>
    ProhibitedStateException(crate::error::ProhibitedStateException),
    /// <p>One or more of the dependencies is unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The operation is not permitted.</p>
    UnauthorizedOperationException(crate::error::UnauthorizedOperationException),
    /// <p>The caller does not have access to perform the action on the resource.</p>
    UnauthorizedResourceAccessException(crate::error::UnauthorizedResourceAccessException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeCommentsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribeCommentsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::EntityNotExistsException(_inner) => _inner.fmt(f),
            Self::FailedDependencyException(_inner) => _inner.fmt(f),
            Self::ProhibitedStateException(_inner) => _inner.fmt(f),
            Self::ServiceUnavailableException(_inner) => _inner.fmt(f),
            Self::UnauthorizedOperationException(_inner) => _inner.fmt(f),
            Self::UnauthorizedResourceAccessException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DescribeCommentsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::EntityNotExistsException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::FailedDependencyException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ProhibitedStateException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedResourceAccessException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeCommentsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeCommentsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeCommentsError {
    /// Creates the `DescribeCommentsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribeCommentsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::EntityNotExistsException(e) => e.meta(),
            Self::FailedDependencyException(e) => e.meta(),
            Self::ProhibitedStateException(e) => e.meta(),
            Self::ServiceUnavailableException(e) => e.meta(),
            Self::UnauthorizedOperationException(e) => e.meta(),
            Self::UnauthorizedResourceAccessException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribeCommentsError::EntityNotExistsException`.
    pub fn is_entity_not_exists_exception(&self) -> bool {
        matches!(self, Self::EntityNotExistsException(_))
    }
    /// Returns `true` if the error kind is `DescribeCommentsError::FailedDependencyException`.
    pub fn is_failed_dependency_exception(&self) -> bool {
        matches!(self, Self::FailedDependencyException(_))
    }
    /// Returns `true` if the error kind is `DescribeCommentsError::ProhibitedStateException`.
    pub fn is_prohibited_state_exception(&self) -> bool {
        matches!(self, Self::ProhibitedStateException(_))
    }
    /// Returns `true` if the error kind is `DescribeCommentsError::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(self, Self::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `DescribeCommentsError::UnauthorizedOperationException`.
    pub fn is_unauthorized_operation_exception(&self) -> bool {
        matches!(self, Self::UnauthorizedOperationException(_))
    }
    /// Returns `true` if the error kind is `DescribeCommentsError::UnauthorizedResourceAccessException`.
    pub fn is_unauthorized_resource_access_exception(&self) -> bool {
        matches!(self, Self::UnauthorizedResourceAccessException(_))
    }
}
impl std::error::Error for DescribeCommentsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::EntityNotExistsException(_inner) => Some(_inner),
            Self::FailedDependencyException(_inner) => Some(_inner),
            Self::ProhibitedStateException(_inner) => Some(_inner),
            Self::ServiceUnavailableException(_inner) => Some(_inner),
            Self::UnauthorizedOperationException(_inner) => Some(_inner),
            Self::UnauthorizedResourceAccessException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribeActivitiesErrorKind = DescribeActivitiesError;
/// Error type for the `DescribeActivitiesError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeActivitiesError {
    /// <p>The AWS Directory Service cannot reach an on-premises instance. Or a dependency under the control of the organization is failing, such as a connected Active Directory.</p>
    FailedDependencyException(crate::error::FailedDependencyException),
    /// <p>The pagination marker or limit fields are not valid.</p>
    InvalidArgumentException(crate::error::InvalidArgumentException),
    /// <p>One or more of the dependencies is unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The operation is not permitted.</p>
    UnauthorizedOperationException(crate::error::UnauthorizedOperationException),
    /// <p>The caller does not have access to perform the action on the resource.</p>
    UnauthorizedResourceAccessException(crate::error::UnauthorizedResourceAccessException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeActivitiesError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribeActivitiesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::FailedDependencyException(_inner) => _inner.fmt(f),
            Self::InvalidArgumentException(_inner) => _inner.fmt(f),
            Self::ServiceUnavailableException(_inner) => _inner.fmt(f),
            Self::UnauthorizedOperationException(_inner) => _inner.fmt(f),
            Self::UnauthorizedResourceAccessException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DescribeActivitiesError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::FailedDependencyException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidArgumentException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedResourceAccessException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeActivitiesError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeActivitiesError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeActivitiesError {
    /// Creates the `DescribeActivitiesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribeActivitiesError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::FailedDependencyException(e) => e.meta(),
            Self::InvalidArgumentException(e) => e.meta(),
            Self::ServiceUnavailableException(e) => e.meta(),
            Self::UnauthorizedOperationException(e) => e.meta(),
            Self::UnauthorizedResourceAccessException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribeActivitiesError::FailedDependencyException`.
    pub fn is_failed_dependency_exception(&self) -> bool {
        matches!(self, Self::FailedDependencyException(_))
    }
    /// Returns `true` if the error kind is `DescribeActivitiesError::InvalidArgumentException`.
    pub fn is_invalid_argument_exception(&self) -> bool {
        matches!(self, Self::InvalidArgumentException(_))
    }
    /// Returns `true` if the error kind is `DescribeActivitiesError::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(self, Self::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `DescribeActivitiesError::UnauthorizedOperationException`.
    pub fn is_unauthorized_operation_exception(&self) -> bool {
        matches!(self, Self::UnauthorizedOperationException(_))
    }
    /// Returns `true` if the error kind is `DescribeActivitiesError::UnauthorizedResourceAccessException`.
    pub fn is_unauthorized_resource_access_exception(&self) -> bool {
        matches!(self, Self::UnauthorizedResourceAccessException(_))
    }
}
impl std::error::Error for DescribeActivitiesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::FailedDependencyException(_inner) => Some(_inner),
            Self::InvalidArgumentException(_inner) => Some(_inner),
            Self::ServiceUnavailableException(_inner) => Some(_inner),
            Self::UnauthorizedOperationException(_inner) => Some(_inner),
            Self::UnauthorizedResourceAccessException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DeleteUserErrorKind = DeleteUserError;
/// Error type for the `DeleteUserError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteUserError {
    /// <p>The resource does not exist.</p>
    EntityNotExistsException(crate::error::EntityNotExistsException),
    /// <p>The AWS Directory Service cannot reach an on-premises instance. Or a dependency under the control of the organization is failing, such as a connected Active Directory.</p>
    FailedDependencyException(crate::error::FailedDependencyException),
    /// <p>One or more of the dependencies is unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The operation is not permitted.</p>
    UnauthorizedOperationException(crate::error::UnauthorizedOperationException),
    /// <p>The caller does not have access to perform the action on the resource.</p>
    UnauthorizedResourceAccessException(crate::error::UnauthorizedResourceAccessException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteUserError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DeleteUserError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::EntityNotExistsException(_inner) => _inner.fmt(f),
            Self::FailedDependencyException(_inner) => _inner.fmt(f),
            Self::ServiceUnavailableException(_inner) => _inner.fmt(f),
            Self::UnauthorizedOperationException(_inner) => _inner.fmt(f),
            Self::UnauthorizedResourceAccessException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeleteUserError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::EntityNotExistsException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::FailedDependencyException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedResourceAccessException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeleteUserError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteUserError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteUserError {
    /// Creates the `DeleteUserError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DeleteUserError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::EntityNotExistsException(e) => e.meta(),
            Self::FailedDependencyException(e) => e.meta(),
            Self::ServiceUnavailableException(e) => e.meta(),
            Self::UnauthorizedOperationException(e) => e.meta(),
            Self::UnauthorizedResourceAccessException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeleteUserError::EntityNotExistsException`.
    pub fn is_entity_not_exists_exception(&self) -> bool {
        matches!(self, Self::EntityNotExistsException(_))
    }
    /// Returns `true` if the error kind is `DeleteUserError::FailedDependencyException`.
    pub fn is_failed_dependency_exception(&self) -> bool {
        matches!(self, Self::FailedDependencyException(_))
    }
    /// Returns `true` if the error kind is `DeleteUserError::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(self, Self::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `DeleteUserError::UnauthorizedOperationException`.
    pub fn is_unauthorized_operation_exception(&self) -> bool {
        matches!(self, Self::UnauthorizedOperationException(_))
    }
    /// Returns `true` if the error kind is `DeleteUserError::UnauthorizedResourceAccessException`.
    pub fn is_unauthorized_resource_access_exception(&self) -> bool {
        matches!(self, Self::UnauthorizedResourceAccessException(_))
    }
}
impl std::error::Error for DeleteUserError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::EntityNotExistsException(_inner) => Some(_inner),
            Self::FailedDependencyException(_inner) => Some(_inner),
            Self::ServiceUnavailableException(_inner) => Some(_inner),
            Self::UnauthorizedOperationException(_inner) => Some(_inner),
            Self::UnauthorizedResourceAccessException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DeleteNotificationSubscriptionErrorKind = DeleteNotificationSubscriptionError;
/// Error type for the `DeleteNotificationSubscriptionError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteNotificationSubscriptionError {
    /// <p>The resource does not exist.</p>
    EntityNotExistsException(crate::error::EntityNotExistsException),
    /// <p>The specified document version is not in the INITIALIZED state.</p>
    ProhibitedStateException(crate::error::ProhibitedStateException),
    /// <p>One or more of the dependencies is unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The caller does not have access to perform the action on the resource.</p>
    UnauthorizedResourceAccessException(crate::error::UnauthorizedResourceAccessException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteNotificationSubscriptionError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DeleteNotificationSubscriptionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::EntityNotExistsException(_inner) => _inner.fmt(f),
            Self::ProhibitedStateException(_inner) => _inner.fmt(f),
            Self::ServiceUnavailableException(_inner) => _inner.fmt(f),
            Self::UnauthorizedResourceAccessException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for DeleteNotificationSubscriptionError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::EntityNotExistsException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ProhibitedStateException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedResourceAccessException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeleteNotificationSubscriptionError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteNotificationSubscriptionError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteNotificationSubscriptionError {
    /// Creates the `DeleteNotificationSubscriptionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DeleteNotificationSubscriptionError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::EntityNotExistsException(e) => e.meta(),
            Self::ProhibitedStateException(e) => e.meta(),
            Self::ServiceUnavailableException(e) => e.meta(),
            Self::UnauthorizedResourceAccessException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeleteNotificationSubscriptionError::EntityNotExistsException`.
    pub fn is_entity_not_exists_exception(&self) -> bool {
        matches!(self, Self::EntityNotExistsException(_))
    }
    /// Returns `true` if the error kind is `DeleteNotificationSubscriptionError::ProhibitedStateException`.
    pub fn is_prohibited_state_exception(&self) -> bool {
        matches!(self, Self::ProhibitedStateException(_))
    }
    /// Returns `true` if the error kind is `DeleteNotificationSubscriptionError::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(self, Self::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `DeleteNotificationSubscriptionError::UnauthorizedResourceAccessException`.
    pub fn is_unauthorized_resource_access_exception(&self) -> bool {
        matches!(self, Self::UnauthorizedResourceAccessException(_))
    }
}
impl std::error::Error for DeleteNotificationSubscriptionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::EntityNotExistsException(_inner) => Some(_inner),
            Self::ProhibitedStateException(_inner) => Some(_inner),
            Self::ServiceUnavailableException(_inner) => Some(_inner),
            Self::UnauthorizedResourceAccessException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DeleteLabelsErrorKind = DeleteLabelsError;
/// Error type for the `DeleteLabelsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteLabelsError {
    /// <p>The resource does not exist.</p>
    EntityNotExistsException(crate::error::EntityNotExistsException),
    /// <p>The AWS Directory Service cannot reach an on-premises instance. Or a dependency under the control of the organization is failing, such as a connected Active Directory.</p>
    FailedDependencyException(crate::error::FailedDependencyException),
    /// <p>The specified document version is not in the INITIALIZED state.</p>
    ProhibitedStateException(crate::error::ProhibitedStateException),
    /// <p>One or more of the dependencies is unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The operation is not permitted.</p>
    UnauthorizedOperationException(crate::error::UnauthorizedOperationException),
    /// <p>The caller does not have access to perform the action on the resource.</p>
    UnauthorizedResourceAccessException(crate::error::UnauthorizedResourceAccessException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteLabelsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DeleteLabelsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::EntityNotExistsException(_inner) => _inner.fmt(f),
            Self::FailedDependencyException(_inner) => _inner.fmt(f),
            Self::ProhibitedStateException(_inner) => _inner.fmt(f),
            Self::ServiceUnavailableException(_inner) => _inner.fmt(f),
            Self::UnauthorizedOperationException(_inner) => _inner.fmt(f),
            Self::UnauthorizedResourceAccessException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeleteLabelsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::EntityNotExistsException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::FailedDependencyException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ProhibitedStateException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedResourceAccessException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeleteLabelsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteLabelsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteLabelsError {
    /// Creates the `DeleteLabelsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DeleteLabelsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::EntityNotExistsException(e) => e.meta(),
            Self::FailedDependencyException(e) => e.meta(),
            Self::ProhibitedStateException(e) => e.meta(),
            Self::ServiceUnavailableException(e) => e.meta(),
            Self::UnauthorizedOperationException(e) => e.meta(),
            Self::UnauthorizedResourceAccessException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeleteLabelsError::EntityNotExistsException`.
    pub fn is_entity_not_exists_exception(&self) -> bool {
        matches!(self, Self::EntityNotExistsException(_))
    }
    /// Returns `true` if the error kind is `DeleteLabelsError::FailedDependencyException`.
    pub fn is_failed_dependency_exception(&self) -> bool {
        matches!(self, Self::FailedDependencyException(_))
    }
    /// Returns `true` if the error kind is `DeleteLabelsError::ProhibitedStateException`.
    pub fn is_prohibited_state_exception(&self) -> bool {
        matches!(self, Self::ProhibitedStateException(_))
    }
    /// Returns `true` if the error kind is `DeleteLabelsError::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(self, Self::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `DeleteLabelsError::UnauthorizedOperationException`.
    pub fn is_unauthorized_operation_exception(&self) -> bool {
        matches!(self, Self::UnauthorizedOperationException(_))
    }
    /// Returns `true` if the error kind is `DeleteLabelsError::UnauthorizedResourceAccessException`.
    pub fn is_unauthorized_resource_access_exception(&self) -> bool {
        matches!(self, Self::UnauthorizedResourceAccessException(_))
    }
}
impl std::error::Error for DeleteLabelsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::EntityNotExistsException(_inner) => Some(_inner),
            Self::FailedDependencyException(_inner) => Some(_inner),
            Self::ProhibitedStateException(_inner) => Some(_inner),
            Self::ServiceUnavailableException(_inner) => Some(_inner),
            Self::UnauthorizedOperationException(_inner) => Some(_inner),
            Self::UnauthorizedResourceAccessException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DeleteFolderContentsErrorKind = DeleteFolderContentsError;
/// Error type for the `DeleteFolderContentsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteFolderContentsError {
    /// <p>Another operation is in progress on the resource that conflicts with the current operation.</p>
    ConflictingOperationException(crate::error::ConflictingOperationException),
    /// <p>The resource does not exist.</p>
    EntityNotExistsException(crate::error::EntityNotExistsException),
    /// <p>The AWS Directory Service cannot reach an on-premises instance. Or a dependency under the control of the organization is failing, such as a connected Active Directory.</p>
    FailedDependencyException(crate::error::FailedDependencyException),
    /// <p>The specified document version is not in the INITIALIZED state.</p>
    ProhibitedStateException(crate::error::ProhibitedStateException),
    /// <p>One or more of the dependencies is unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The operation is not permitted.</p>
    UnauthorizedOperationException(crate::error::UnauthorizedOperationException),
    /// <p>The caller does not have access to perform the action on the resource.</p>
    UnauthorizedResourceAccessException(crate::error::UnauthorizedResourceAccessException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteFolderContentsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DeleteFolderContentsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ConflictingOperationException(_inner) => _inner.fmt(f),
            Self::EntityNotExistsException(_inner) => _inner.fmt(f),
            Self::FailedDependencyException(_inner) => _inner.fmt(f),
            Self::ProhibitedStateException(_inner) => _inner.fmt(f),
            Self::ServiceUnavailableException(_inner) => _inner.fmt(f),
            Self::UnauthorizedOperationException(_inner) => _inner.fmt(f),
            Self::UnauthorizedResourceAccessException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeleteFolderContentsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ConflictingOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EntityNotExistsException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::FailedDependencyException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ProhibitedStateException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedResourceAccessException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeleteFolderContentsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteFolderContentsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteFolderContentsError {
    /// Creates the `DeleteFolderContentsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DeleteFolderContentsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ConflictingOperationException(e) => e.meta(),
            Self::EntityNotExistsException(e) => e.meta(),
            Self::FailedDependencyException(e) => e.meta(),
            Self::ProhibitedStateException(e) => e.meta(),
            Self::ServiceUnavailableException(e) => e.meta(),
            Self::UnauthorizedOperationException(e) => e.meta(),
            Self::UnauthorizedResourceAccessException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeleteFolderContentsError::ConflictingOperationException`.
    pub fn is_conflicting_operation_exception(&self) -> bool {
        matches!(self, Self::ConflictingOperationException(_))
    }
    /// Returns `true` if the error kind is `DeleteFolderContentsError::EntityNotExistsException`.
    pub fn is_entity_not_exists_exception(&self) -> bool {
        matches!(self, Self::EntityNotExistsException(_))
    }
    /// Returns `true` if the error kind is `DeleteFolderContentsError::FailedDependencyException`.
    pub fn is_failed_dependency_exception(&self) -> bool {
        matches!(self, Self::FailedDependencyException(_))
    }
    /// Returns `true` if the error kind is `DeleteFolderContentsError::ProhibitedStateException`.
    pub fn is_prohibited_state_exception(&self) -> bool {
        matches!(self, Self::ProhibitedStateException(_))
    }
    /// Returns `true` if the error kind is `DeleteFolderContentsError::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(self, Self::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `DeleteFolderContentsError::UnauthorizedOperationException`.
    pub fn is_unauthorized_operation_exception(&self) -> bool {
        matches!(self, Self::UnauthorizedOperationException(_))
    }
    /// Returns `true` if the error kind is `DeleteFolderContentsError::UnauthorizedResourceAccessException`.
    pub fn is_unauthorized_resource_access_exception(&self) -> bool {
        matches!(self, Self::UnauthorizedResourceAccessException(_))
    }
}
impl std::error::Error for DeleteFolderContentsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ConflictingOperationException(_inner) => Some(_inner),
            Self::EntityNotExistsException(_inner) => Some(_inner),
            Self::FailedDependencyException(_inner) => Some(_inner),
            Self::ProhibitedStateException(_inner) => Some(_inner),
            Self::ServiceUnavailableException(_inner) => Some(_inner),
            Self::UnauthorizedOperationException(_inner) => Some(_inner),
            Self::UnauthorizedResourceAccessException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DeleteFolderErrorKind = DeleteFolderError;
/// Error type for the `DeleteFolderError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteFolderError {
    /// <p>The resource hierarchy is changing.</p>
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    /// <p>Another operation is in progress on the resource that conflicts with the current operation.</p>
    ConflictingOperationException(crate::error::ConflictingOperationException),
    /// <p>The resource does not exist.</p>
    EntityNotExistsException(crate::error::EntityNotExistsException),
    /// <p>The AWS Directory Service cannot reach an on-premises instance. Or a dependency under the control of the organization is failing, such as a connected Active Directory.</p>
    FailedDependencyException(crate::error::FailedDependencyException),
    /// <p>The maximum of 100,000 files and folders under the parent folder has been exceeded.</p>
    LimitExceededException(crate::error::LimitExceededException),
    /// <p>The specified document version is not in the INITIALIZED state.</p>
    ProhibitedStateException(crate::error::ProhibitedStateException),
    /// <p>One or more of the dependencies is unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The operation is not permitted.</p>
    UnauthorizedOperationException(crate::error::UnauthorizedOperationException),
    /// <p>The caller does not have access to perform the action on the resource.</p>
    UnauthorizedResourceAccessException(crate::error::UnauthorizedResourceAccessException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteFolderError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DeleteFolderError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ConcurrentModificationException(_inner) => _inner.fmt(f),
            Self::ConflictingOperationException(_inner) => _inner.fmt(f),
            Self::EntityNotExistsException(_inner) => _inner.fmt(f),
            Self::FailedDependencyException(_inner) => _inner.fmt(f),
            Self::LimitExceededException(_inner) => _inner.fmt(f),
            Self::ProhibitedStateException(_inner) => _inner.fmt(f),
            Self::ServiceUnavailableException(_inner) => _inner.fmt(f),
            Self::UnauthorizedOperationException(_inner) => _inner.fmt(f),
            Self::UnauthorizedResourceAccessException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeleteFolderError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ConcurrentModificationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ConflictingOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EntityNotExistsException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::FailedDependencyException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::LimitExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ProhibitedStateException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedResourceAccessException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeleteFolderError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteFolderError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteFolderError {
    /// Creates the `DeleteFolderError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DeleteFolderError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ConcurrentModificationException(e) => e.meta(),
            Self::ConflictingOperationException(e) => e.meta(),
            Self::EntityNotExistsException(e) => e.meta(),
            Self::FailedDependencyException(e) => e.meta(),
            Self::LimitExceededException(e) => e.meta(),
            Self::ProhibitedStateException(e) => e.meta(),
            Self::ServiceUnavailableException(e) => e.meta(),
            Self::UnauthorizedOperationException(e) => e.meta(),
            Self::UnauthorizedResourceAccessException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeleteFolderError::ConcurrentModificationException`.
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(self, Self::ConcurrentModificationException(_))
    }
    /// Returns `true` if the error kind is `DeleteFolderError::ConflictingOperationException`.
    pub fn is_conflicting_operation_exception(&self) -> bool {
        matches!(self, Self::ConflictingOperationException(_))
    }
    /// Returns `true` if the error kind is `DeleteFolderError::EntityNotExistsException`.
    pub fn is_entity_not_exists_exception(&self) -> bool {
        matches!(self, Self::EntityNotExistsException(_))
    }
    /// Returns `true` if the error kind is `DeleteFolderError::FailedDependencyException`.
    pub fn is_failed_dependency_exception(&self) -> bool {
        matches!(self, Self::FailedDependencyException(_))
    }
    /// Returns `true` if the error kind is `DeleteFolderError::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(self, Self::LimitExceededException(_))
    }
    /// Returns `true` if the error kind is `DeleteFolderError::ProhibitedStateException`.
    pub fn is_prohibited_state_exception(&self) -> bool {
        matches!(self, Self::ProhibitedStateException(_))
    }
    /// Returns `true` if the error kind is `DeleteFolderError::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(self, Self::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `DeleteFolderError::UnauthorizedOperationException`.
    pub fn is_unauthorized_operation_exception(&self) -> bool {
        matches!(self, Self::UnauthorizedOperationException(_))
    }
    /// Returns `true` if the error kind is `DeleteFolderError::UnauthorizedResourceAccessException`.
    pub fn is_unauthorized_resource_access_exception(&self) -> bool {
        matches!(self, Self::UnauthorizedResourceAccessException(_))
    }
}
impl std::error::Error for DeleteFolderError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ConcurrentModificationException(_inner) => Some(_inner),
            Self::ConflictingOperationException(_inner) => Some(_inner),
            Self::EntityNotExistsException(_inner) => Some(_inner),
            Self::FailedDependencyException(_inner) => Some(_inner),
            Self::LimitExceededException(_inner) => Some(_inner),
            Self::ProhibitedStateException(_inner) => Some(_inner),
            Self::ServiceUnavailableException(_inner) => Some(_inner),
            Self::UnauthorizedOperationException(_inner) => Some(_inner),
            Self::UnauthorizedResourceAccessException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DeleteDocumentVersionErrorKind = DeleteDocumentVersionError;
/// Error type for the `DeleteDocumentVersionError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteDocumentVersionError {
    /// <p>The resource hierarchy is changing.</p>
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    /// <p>Another operation is in progress on the resource that conflicts with the current operation.</p>
    ConflictingOperationException(crate::error::ConflictingOperationException),
    /// <p>The resource does not exist.</p>
    EntityNotExistsException(crate::error::EntityNotExistsException),
    /// <p>The AWS Directory Service cannot reach an on-premises instance. Or a dependency under the control of the organization is failing, such as a connected Active Directory.</p>
    FailedDependencyException(crate::error::FailedDependencyException),
    /// <p>The operation is invalid.</p>
    InvalidOperationException(crate::error::InvalidOperationException),
    /// <p>The specified document version is not in the INITIALIZED state.</p>
    ProhibitedStateException(crate::error::ProhibitedStateException),
    /// <p>The operation is not permitted.</p>
    UnauthorizedOperationException(crate::error::UnauthorizedOperationException),
    /// <p>The caller does not have access to perform the action on the resource.</p>
    UnauthorizedResourceAccessException(crate::error::UnauthorizedResourceAccessException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteDocumentVersionError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DeleteDocumentVersionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ConcurrentModificationException(_inner) => _inner.fmt(f),
            Self::ConflictingOperationException(_inner) => _inner.fmt(f),
            Self::EntityNotExistsException(_inner) => _inner.fmt(f),
            Self::FailedDependencyException(_inner) => _inner.fmt(f),
            Self::InvalidOperationException(_inner) => _inner.fmt(f),
            Self::ProhibitedStateException(_inner) => _inner.fmt(f),
            Self::UnauthorizedOperationException(_inner) => _inner.fmt(f),
            Self::UnauthorizedResourceAccessException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeleteDocumentVersionError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ConcurrentModificationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ConflictingOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EntityNotExistsException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::FailedDependencyException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ProhibitedStateException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedResourceAccessException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeleteDocumentVersionError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteDocumentVersionError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteDocumentVersionError {
    /// Creates the `DeleteDocumentVersionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DeleteDocumentVersionError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ConcurrentModificationException(e) => e.meta(),
            Self::ConflictingOperationException(e) => e.meta(),
            Self::EntityNotExistsException(e) => e.meta(),
            Self::FailedDependencyException(e) => e.meta(),
            Self::InvalidOperationException(e) => e.meta(),
            Self::ProhibitedStateException(e) => e.meta(),
            Self::UnauthorizedOperationException(e) => e.meta(),
            Self::UnauthorizedResourceAccessException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeleteDocumentVersionError::ConcurrentModificationException`.
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(self, Self::ConcurrentModificationException(_))
    }
    /// Returns `true` if the error kind is `DeleteDocumentVersionError::ConflictingOperationException`.
    pub fn is_conflicting_operation_exception(&self) -> bool {
        matches!(self, Self::ConflictingOperationException(_))
    }
    /// Returns `true` if the error kind is `DeleteDocumentVersionError::EntityNotExistsException`.
    pub fn is_entity_not_exists_exception(&self) -> bool {
        matches!(self, Self::EntityNotExistsException(_))
    }
    /// Returns `true` if the error kind is `DeleteDocumentVersionError::FailedDependencyException`.
    pub fn is_failed_dependency_exception(&self) -> bool {
        matches!(self, Self::FailedDependencyException(_))
    }
    /// Returns `true` if the error kind is `DeleteDocumentVersionError::InvalidOperationException`.
    pub fn is_invalid_operation_exception(&self) -> bool {
        matches!(self, Self::InvalidOperationException(_))
    }
    /// Returns `true` if the error kind is `DeleteDocumentVersionError::ProhibitedStateException`.
    pub fn is_prohibited_state_exception(&self) -> bool {
        matches!(self, Self::ProhibitedStateException(_))
    }
    /// Returns `true` if the error kind is `DeleteDocumentVersionError::UnauthorizedOperationException`.
    pub fn is_unauthorized_operation_exception(&self) -> bool {
        matches!(self, Self::UnauthorizedOperationException(_))
    }
    /// Returns `true` if the error kind is `DeleteDocumentVersionError::UnauthorizedResourceAccessException`.
    pub fn is_unauthorized_resource_access_exception(&self) -> bool {
        matches!(self, Self::UnauthorizedResourceAccessException(_))
    }
}
impl std::error::Error for DeleteDocumentVersionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ConcurrentModificationException(_inner) => Some(_inner),
            Self::ConflictingOperationException(_inner) => Some(_inner),
            Self::EntityNotExistsException(_inner) => Some(_inner),
            Self::FailedDependencyException(_inner) => Some(_inner),
            Self::InvalidOperationException(_inner) => Some(_inner),
            Self::ProhibitedStateException(_inner) => Some(_inner),
            Self::UnauthorizedOperationException(_inner) => Some(_inner),
            Self::UnauthorizedResourceAccessException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DeleteDocumentErrorKind = DeleteDocumentError;
/// Error type for the `DeleteDocumentError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteDocumentError {
    /// <p>The resource hierarchy is changing.</p>
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    /// <p>Another operation is in progress on the resource that conflicts with the current operation.</p>
    ConflictingOperationException(crate::error::ConflictingOperationException),
    /// <p>The resource does not exist.</p>
    EntityNotExistsException(crate::error::EntityNotExistsException),
    /// <p>The AWS Directory Service cannot reach an on-premises instance. Or a dependency under the control of the organization is failing, such as a connected Active Directory.</p>
    FailedDependencyException(crate::error::FailedDependencyException),
    /// <p>The maximum of 100,000 files and folders under the parent folder has been exceeded.</p>
    LimitExceededException(crate::error::LimitExceededException),
    /// <p>The specified document version is not in the INITIALIZED state.</p>
    ProhibitedStateException(crate::error::ProhibitedStateException),
    /// <p>One or more of the dependencies is unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The operation is not permitted.</p>
    UnauthorizedOperationException(crate::error::UnauthorizedOperationException),
    /// <p>The caller does not have access to perform the action on the resource.</p>
    UnauthorizedResourceAccessException(crate::error::UnauthorizedResourceAccessException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteDocumentError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DeleteDocumentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ConcurrentModificationException(_inner) => _inner.fmt(f),
            Self::ConflictingOperationException(_inner) => _inner.fmt(f),
            Self::EntityNotExistsException(_inner) => _inner.fmt(f),
            Self::FailedDependencyException(_inner) => _inner.fmt(f),
            Self::LimitExceededException(_inner) => _inner.fmt(f),
            Self::ProhibitedStateException(_inner) => _inner.fmt(f),
            Self::ServiceUnavailableException(_inner) => _inner.fmt(f),
            Self::UnauthorizedOperationException(_inner) => _inner.fmt(f),
            Self::UnauthorizedResourceAccessException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeleteDocumentError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ConcurrentModificationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ConflictingOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EntityNotExistsException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::FailedDependencyException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::LimitExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ProhibitedStateException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedResourceAccessException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeleteDocumentError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteDocumentError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteDocumentError {
    /// Creates the `DeleteDocumentError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DeleteDocumentError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ConcurrentModificationException(e) => e.meta(),
            Self::ConflictingOperationException(e) => e.meta(),
            Self::EntityNotExistsException(e) => e.meta(),
            Self::FailedDependencyException(e) => e.meta(),
            Self::LimitExceededException(e) => e.meta(),
            Self::ProhibitedStateException(e) => e.meta(),
            Self::ServiceUnavailableException(e) => e.meta(),
            Self::UnauthorizedOperationException(e) => e.meta(),
            Self::UnauthorizedResourceAccessException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeleteDocumentError::ConcurrentModificationException`.
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(self, Self::ConcurrentModificationException(_))
    }
    /// Returns `true` if the error kind is `DeleteDocumentError::ConflictingOperationException`.
    pub fn is_conflicting_operation_exception(&self) -> bool {
        matches!(self, Self::ConflictingOperationException(_))
    }
    /// Returns `true` if the error kind is `DeleteDocumentError::EntityNotExistsException`.
    pub fn is_entity_not_exists_exception(&self) -> bool {
        matches!(self, Self::EntityNotExistsException(_))
    }
    /// Returns `true` if the error kind is `DeleteDocumentError::FailedDependencyException`.
    pub fn is_failed_dependency_exception(&self) -> bool {
        matches!(self, Self::FailedDependencyException(_))
    }
    /// Returns `true` if the error kind is `DeleteDocumentError::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(self, Self::LimitExceededException(_))
    }
    /// Returns `true` if the error kind is `DeleteDocumentError::ProhibitedStateException`.
    pub fn is_prohibited_state_exception(&self) -> bool {
        matches!(self, Self::ProhibitedStateException(_))
    }
    /// Returns `true` if the error kind is `DeleteDocumentError::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(self, Self::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `DeleteDocumentError::UnauthorizedOperationException`.
    pub fn is_unauthorized_operation_exception(&self) -> bool {
        matches!(self, Self::UnauthorizedOperationException(_))
    }
    /// Returns `true` if the error kind is `DeleteDocumentError::UnauthorizedResourceAccessException`.
    pub fn is_unauthorized_resource_access_exception(&self) -> bool {
        matches!(self, Self::UnauthorizedResourceAccessException(_))
    }
}
impl std::error::Error for DeleteDocumentError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ConcurrentModificationException(_inner) => Some(_inner),
            Self::ConflictingOperationException(_inner) => Some(_inner),
            Self::EntityNotExistsException(_inner) => Some(_inner),
            Self::FailedDependencyException(_inner) => Some(_inner),
            Self::LimitExceededException(_inner) => Some(_inner),
            Self::ProhibitedStateException(_inner) => Some(_inner),
            Self::ServiceUnavailableException(_inner) => Some(_inner),
            Self::UnauthorizedOperationException(_inner) => Some(_inner),
            Self::UnauthorizedResourceAccessException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DeleteCustomMetadataErrorKind = DeleteCustomMetadataError;
/// Error type for the `DeleteCustomMetadataError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteCustomMetadataError {
    /// <p>The resource does not exist.</p>
    EntityNotExistsException(crate::error::EntityNotExistsException),
    /// <p>The AWS Directory Service cannot reach an on-premises instance. Or a dependency under the control of the organization is failing, such as a connected Active Directory.</p>
    FailedDependencyException(crate::error::FailedDependencyException),
    /// <p>The specified document version is not in the INITIALIZED state.</p>
    ProhibitedStateException(crate::error::ProhibitedStateException),
    /// <p>One or more of the dependencies is unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The operation is not permitted.</p>
    UnauthorizedOperationException(crate::error::UnauthorizedOperationException),
    /// <p>The caller does not have access to perform the action on the resource.</p>
    UnauthorizedResourceAccessException(crate::error::UnauthorizedResourceAccessException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteCustomMetadataError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DeleteCustomMetadataError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::EntityNotExistsException(_inner) => _inner.fmt(f),
            Self::FailedDependencyException(_inner) => _inner.fmt(f),
            Self::ProhibitedStateException(_inner) => _inner.fmt(f),
            Self::ServiceUnavailableException(_inner) => _inner.fmt(f),
            Self::UnauthorizedOperationException(_inner) => _inner.fmt(f),
            Self::UnauthorizedResourceAccessException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeleteCustomMetadataError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::EntityNotExistsException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::FailedDependencyException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ProhibitedStateException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedResourceAccessException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeleteCustomMetadataError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteCustomMetadataError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteCustomMetadataError {
    /// Creates the `DeleteCustomMetadataError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DeleteCustomMetadataError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::EntityNotExistsException(e) => e.meta(),
            Self::FailedDependencyException(e) => e.meta(),
            Self::ProhibitedStateException(e) => e.meta(),
            Self::ServiceUnavailableException(e) => e.meta(),
            Self::UnauthorizedOperationException(e) => e.meta(),
            Self::UnauthorizedResourceAccessException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeleteCustomMetadataError::EntityNotExistsException`.
    pub fn is_entity_not_exists_exception(&self) -> bool {
        matches!(self, Self::EntityNotExistsException(_))
    }
    /// Returns `true` if the error kind is `DeleteCustomMetadataError::FailedDependencyException`.
    pub fn is_failed_dependency_exception(&self) -> bool {
        matches!(self, Self::FailedDependencyException(_))
    }
    /// Returns `true` if the error kind is `DeleteCustomMetadataError::ProhibitedStateException`.
    pub fn is_prohibited_state_exception(&self) -> bool {
        matches!(self, Self::ProhibitedStateException(_))
    }
    /// Returns `true` if the error kind is `DeleteCustomMetadataError::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(self, Self::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `DeleteCustomMetadataError::UnauthorizedOperationException`.
    pub fn is_unauthorized_operation_exception(&self) -> bool {
        matches!(self, Self::UnauthorizedOperationException(_))
    }
    /// Returns `true` if the error kind is `DeleteCustomMetadataError::UnauthorizedResourceAccessException`.
    pub fn is_unauthorized_resource_access_exception(&self) -> bool {
        matches!(self, Self::UnauthorizedResourceAccessException(_))
    }
}
impl std::error::Error for DeleteCustomMetadataError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::EntityNotExistsException(_inner) => Some(_inner),
            Self::FailedDependencyException(_inner) => Some(_inner),
            Self::ProhibitedStateException(_inner) => Some(_inner),
            Self::ServiceUnavailableException(_inner) => Some(_inner),
            Self::UnauthorizedOperationException(_inner) => Some(_inner),
            Self::UnauthorizedResourceAccessException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DeleteCommentErrorKind = DeleteCommentError;
/// Error type for the `DeleteCommentError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteCommentError {
    /// <p>This exception is thrown when the document is locked for comments and user tries to create or delete a comment on that document.</p>
    DocumentLockedForCommentsException(crate::error::DocumentLockedForCommentsException),
    /// <p>The resource does not exist.</p>
    EntityNotExistsException(crate::error::EntityNotExistsException),
    /// <p>The AWS Directory Service cannot reach an on-premises instance. Or a dependency under the control of the organization is failing, such as a connected Active Directory.</p>
    FailedDependencyException(crate::error::FailedDependencyException),
    /// <p>The specified document version is not in the INITIALIZED state.</p>
    ProhibitedStateException(crate::error::ProhibitedStateException),
    /// <p>One or more of the dependencies is unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The operation is not permitted.</p>
    UnauthorizedOperationException(crate::error::UnauthorizedOperationException),
    /// <p>The caller does not have access to perform the action on the resource.</p>
    UnauthorizedResourceAccessException(crate::error::UnauthorizedResourceAccessException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteCommentError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DeleteCommentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::DocumentLockedForCommentsException(_inner) => _inner.fmt(f),
            Self::EntityNotExistsException(_inner) => _inner.fmt(f),
            Self::FailedDependencyException(_inner) => _inner.fmt(f),
            Self::ProhibitedStateException(_inner) => _inner.fmt(f),
            Self::ServiceUnavailableException(_inner) => _inner.fmt(f),
            Self::UnauthorizedOperationException(_inner) => _inner.fmt(f),
            Self::UnauthorizedResourceAccessException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeleteCommentError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::DocumentLockedForCommentsException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EntityNotExistsException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::FailedDependencyException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ProhibitedStateException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedResourceAccessException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeleteCommentError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteCommentError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteCommentError {
    /// Creates the `DeleteCommentError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DeleteCommentError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::DocumentLockedForCommentsException(e) => e.meta(),
            Self::EntityNotExistsException(e) => e.meta(),
            Self::FailedDependencyException(e) => e.meta(),
            Self::ProhibitedStateException(e) => e.meta(),
            Self::ServiceUnavailableException(e) => e.meta(),
            Self::UnauthorizedOperationException(e) => e.meta(),
            Self::UnauthorizedResourceAccessException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeleteCommentError::DocumentLockedForCommentsException`.
    pub fn is_document_locked_for_comments_exception(&self) -> bool {
        matches!(self, Self::DocumentLockedForCommentsException(_))
    }
    /// Returns `true` if the error kind is `DeleteCommentError::EntityNotExistsException`.
    pub fn is_entity_not_exists_exception(&self) -> bool {
        matches!(self, Self::EntityNotExistsException(_))
    }
    /// Returns `true` if the error kind is `DeleteCommentError::FailedDependencyException`.
    pub fn is_failed_dependency_exception(&self) -> bool {
        matches!(self, Self::FailedDependencyException(_))
    }
    /// Returns `true` if the error kind is `DeleteCommentError::ProhibitedStateException`.
    pub fn is_prohibited_state_exception(&self) -> bool {
        matches!(self, Self::ProhibitedStateException(_))
    }
    /// Returns `true` if the error kind is `DeleteCommentError::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(self, Self::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `DeleteCommentError::UnauthorizedOperationException`.
    pub fn is_unauthorized_operation_exception(&self) -> bool {
        matches!(self, Self::UnauthorizedOperationException(_))
    }
    /// Returns `true` if the error kind is `DeleteCommentError::UnauthorizedResourceAccessException`.
    pub fn is_unauthorized_resource_access_exception(&self) -> bool {
        matches!(self, Self::UnauthorizedResourceAccessException(_))
    }
}
impl std::error::Error for DeleteCommentError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::DocumentLockedForCommentsException(_inner) => Some(_inner),
            Self::EntityNotExistsException(_inner) => Some(_inner),
            Self::FailedDependencyException(_inner) => Some(_inner),
            Self::ProhibitedStateException(_inner) => Some(_inner),
            Self::ServiceUnavailableException(_inner) => Some(_inner),
            Self::UnauthorizedOperationException(_inner) => Some(_inner),
            Self::UnauthorizedResourceAccessException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>This exception is thrown when the document is locked for comments and user tries to create or delete a comment on that document.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DocumentLockedForCommentsException {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl DocumentLockedForCommentsException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DocumentLockedForCommentsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DocumentLockedForCommentsException")?;
        if let Some(inner_21) = &self.message {
            {
                write!(f, ": {}", inner_21)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for DocumentLockedForCommentsException {}
impl aws_http::request_id::RequestId for crate::error::DocumentLockedForCommentsException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for DocumentLockedForCommentsException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl DocumentLockedForCommentsException {
    /// Creates a new builder-style object to manufacture [`DocumentLockedForCommentsException`](crate::error::DocumentLockedForCommentsException).
    pub fn builder() -> crate::error::document_locked_for_comments_exception::Builder {
        crate::error::document_locked_for_comments_exception::Builder::default()
    }
}

/// See [`DocumentLockedForCommentsException`](crate::error::DocumentLockedForCommentsException).
pub mod document_locked_for_comments_exception {

    /// A builder for [`DocumentLockedForCommentsException`](crate::error::DocumentLockedForCommentsException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`DocumentLockedForCommentsException`](crate::error::DocumentLockedForCommentsException).
        pub fn build(self) -> crate::error::DocumentLockedForCommentsException {
            crate::error::DocumentLockedForCommentsException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DeactivateUserErrorKind = DeactivateUserError;
/// Error type for the `DeactivateUserError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeactivateUserError {
    /// <p>The resource does not exist.</p>
    EntityNotExistsException(crate::error::EntityNotExistsException),
    /// <p>The AWS Directory Service cannot reach an on-premises instance. Or a dependency under the control of the organization is failing, such as a connected Active Directory.</p>
    FailedDependencyException(crate::error::FailedDependencyException),
    /// <p>One or more of the dependencies is unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The operation is not permitted.</p>
    UnauthorizedOperationException(crate::error::UnauthorizedOperationException),
    /// <p>The caller does not have access to perform the action on the resource.</p>
    UnauthorizedResourceAccessException(crate::error::UnauthorizedResourceAccessException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeactivateUserError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DeactivateUserError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::EntityNotExistsException(_inner) => _inner.fmt(f),
            Self::FailedDependencyException(_inner) => _inner.fmt(f),
            Self::ServiceUnavailableException(_inner) => _inner.fmt(f),
            Self::UnauthorizedOperationException(_inner) => _inner.fmt(f),
            Self::UnauthorizedResourceAccessException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeactivateUserError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::EntityNotExistsException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::FailedDependencyException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedResourceAccessException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeactivateUserError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeactivateUserError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeactivateUserError {
    /// Creates the `DeactivateUserError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DeactivateUserError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::EntityNotExistsException(e) => e.meta(),
            Self::FailedDependencyException(e) => e.meta(),
            Self::ServiceUnavailableException(e) => e.meta(),
            Self::UnauthorizedOperationException(e) => e.meta(),
            Self::UnauthorizedResourceAccessException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeactivateUserError::EntityNotExistsException`.
    pub fn is_entity_not_exists_exception(&self) -> bool {
        matches!(self, Self::EntityNotExistsException(_))
    }
    /// Returns `true` if the error kind is `DeactivateUserError::FailedDependencyException`.
    pub fn is_failed_dependency_exception(&self) -> bool {
        matches!(self, Self::FailedDependencyException(_))
    }
    /// Returns `true` if the error kind is `DeactivateUserError::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(self, Self::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `DeactivateUserError::UnauthorizedOperationException`.
    pub fn is_unauthorized_operation_exception(&self) -> bool {
        matches!(self, Self::UnauthorizedOperationException(_))
    }
    /// Returns `true` if the error kind is `DeactivateUserError::UnauthorizedResourceAccessException`.
    pub fn is_unauthorized_resource_access_exception(&self) -> bool {
        matches!(self, Self::UnauthorizedResourceAccessException(_))
    }
}
impl std::error::Error for DeactivateUserError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::EntityNotExistsException(_inner) => Some(_inner),
            Self::FailedDependencyException(_inner) => Some(_inner),
            Self::ServiceUnavailableException(_inner) => Some(_inner),
            Self::UnauthorizedOperationException(_inner) => Some(_inner),
            Self::UnauthorizedResourceAccessException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreateUserErrorKind = CreateUserError;
/// Error type for the `CreateUserError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateUserError {
    /// <p>The resource already exists.</p>
    EntityAlreadyExistsException(crate::error::EntityAlreadyExistsException),
    /// <p>The AWS Directory Service cannot reach an on-premises instance. Or a dependency under the control of the organization is failing, such as a connected Active Directory.</p>
    FailedDependencyException(crate::error::FailedDependencyException),
    /// <p>One or more of the dependencies is unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The operation is not permitted.</p>
    UnauthorizedOperationException(crate::error::UnauthorizedOperationException),
    /// <p>The caller does not have access to perform the action on the resource.</p>
    UnauthorizedResourceAccessException(crate::error::UnauthorizedResourceAccessException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateUserError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CreateUserError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::EntityAlreadyExistsException(_inner) => _inner.fmt(f),
            Self::FailedDependencyException(_inner) => _inner.fmt(f),
            Self::ServiceUnavailableException(_inner) => _inner.fmt(f),
            Self::UnauthorizedOperationException(_inner) => _inner.fmt(f),
            Self::UnauthorizedResourceAccessException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CreateUserError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::EntityAlreadyExistsException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::FailedDependencyException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedResourceAccessException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CreateUserError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateUserError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateUserError {
    /// Creates the `CreateUserError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CreateUserError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::EntityAlreadyExistsException(e) => e.meta(),
            Self::FailedDependencyException(e) => e.meta(),
            Self::ServiceUnavailableException(e) => e.meta(),
            Self::UnauthorizedOperationException(e) => e.meta(),
            Self::UnauthorizedResourceAccessException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateUserError::EntityAlreadyExistsException`.
    pub fn is_entity_already_exists_exception(&self) -> bool {
        matches!(self, Self::EntityAlreadyExistsException(_))
    }
    /// Returns `true` if the error kind is `CreateUserError::FailedDependencyException`.
    pub fn is_failed_dependency_exception(&self) -> bool {
        matches!(self, Self::FailedDependencyException(_))
    }
    /// Returns `true` if the error kind is `CreateUserError::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(self, Self::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `CreateUserError::UnauthorizedOperationException`.
    pub fn is_unauthorized_operation_exception(&self) -> bool {
        matches!(self, Self::UnauthorizedOperationException(_))
    }
    /// Returns `true` if the error kind is `CreateUserError::UnauthorizedResourceAccessException`.
    pub fn is_unauthorized_resource_access_exception(&self) -> bool {
        matches!(self, Self::UnauthorizedResourceAccessException(_))
    }
}
impl std::error::Error for CreateUserError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::EntityAlreadyExistsException(_inner) => Some(_inner),
            Self::FailedDependencyException(_inner) => Some(_inner),
            Self::ServiceUnavailableException(_inner) => Some(_inner),
            Self::UnauthorizedOperationException(_inner) => Some(_inner),
            Self::UnauthorizedResourceAccessException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreateNotificationSubscriptionErrorKind = CreateNotificationSubscriptionError;
/// Error type for the `CreateNotificationSubscriptionError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateNotificationSubscriptionError {
    /// <p>The pagination marker or limit fields are not valid.</p>
    InvalidArgumentException(crate::error::InvalidArgumentException),
    /// <p>One or more of the dependencies is unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>You've reached the limit on the number of subscriptions for the WorkDocs instance.</p>
    TooManySubscriptionsException(crate::error::TooManySubscriptionsException),
    /// <p>The caller does not have access to perform the action on the resource.</p>
    UnauthorizedResourceAccessException(crate::error::UnauthorizedResourceAccessException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateNotificationSubscriptionError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CreateNotificationSubscriptionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::InvalidArgumentException(_inner) => _inner.fmt(f),
            Self::ServiceUnavailableException(_inner) => _inner.fmt(f),
            Self::TooManySubscriptionsException(_inner) => _inner.fmt(f),
            Self::UnauthorizedResourceAccessException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for CreateNotificationSubscriptionError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::InvalidArgumentException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManySubscriptionsException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedResourceAccessException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CreateNotificationSubscriptionError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateNotificationSubscriptionError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateNotificationSubscriptionError {
    /// Creates the `CreateNotificationSubscriptionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CreateNotificationSubscriptionError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::InvalidArgumentException(e) => e.meta(),
            Self::ServiceUnavailableException(e) => e.meta(),
            Self::TooManySubscriptionsException(e) => e.meta(),
            Self::UnauthorizedResourceAccessException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateNotificationSubscriptionError::InvalidArgumentException`.
    pub fn is_invalid_argument_exception(&self) -> bool {
        matches!(self, Self::InvalidArgumentException(_))
    }
    /// Returns `true` if the error kind is `CreateNotificationSubscriptionError::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(self, Self::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `CreateNotificationSubscriptionError::TooManySubscriptionsException`.
    pub fn is_too_many_subscriptions_exception(&self) -> bool {
        matches!(self, Self::TooManySubscriptionsException(_))
    }
    /// Returns `true` if the error kind is `CreateNotificationSubscriptionError::UnauthorizedResourceAccessException`.
    pub fn is_unauthorized_resource_access_exception(&self) -> bool {
        matches!(self, Self::UnauthorizedResourceAccessException(_))
    }
}
impl std::error::Error for CreateNotificationSubscriptionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::InvalidArgumentException(_inner) => Some(_inner),
            Self::ServiceUnavailableException(_inner) => Some(_inner),
            Self::TooManySubscriptionsException(_inner) => Some(_inner),
            Self::UnauthorizedResourceAccessException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>You've reached the limit on the number of subscriptions for the WorkDocs instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TooManySubscriptionsException {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl TooManySubscriptionsException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TooManySubscriptionsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TooManySubscriptionsException")?;
        if let Some(inner_22) = &self.message {
            {
                write!(f, ": {}", inner_22)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for TooManySubscriptionsException {}
impl aws_http::request_id::RequestId for crate::error::TooManySubscriptionsException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for TooManySubscriptionsException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl TooManySubscriptionsException {
    /// Creates a new builder-style object to manufacture [`TooManySubscriptionsException`](crate::error::TooManySubscriptionsException).
    pub fn builder() -> crate::error::too_many_subscriptions_exception::Builder {
        crate::error::too_many_subscriptions_exception::Builder::default()
    }
}

/// See [`TooManySubscriptionsException`](crate::error::TooManySubscriptionsException).
pub mod too_many_subscriptions_exception {

    /// A builder for [`TooManySubscriptionsException`](crate::error::TooManySubscriptionsException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`TooManySubscriptionsException`](crate::error::TooManySubscriptionsException).
        pub fn build(self) -> crate::error::TooManySubscriptionsException {
            crate::error::TooManySubscriptionsException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreateLabelsErrorKind = CreateLabelsError;
/// Error type for the `CreateLabelsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateLabelsError {
    /// <p>The resource does not exist.</p>
    EntityNotExistsException(crate::error::EntityNotExistsException),
    /// <p>The AWS Directory Service cannot reach an on-premises instance. Or a dependency under the control of the organization is failing, such as a connected Active Directory.</p>
    FailedDependencyException(crate::error::FailedDependencyException),
    /// <p>One or more of the dependencies is unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The limit has been reached on the number of labels for the specified resource.</p>
    TooManyLabelsException(crate::error::TooManyLabelsException),
    /// <p>The operation is not permitted.</p>
    UnauthorizedOperationException(crate::error::UnauthorizedOperationException),
    /// <p>The caller does not have access to perform the action on the resource.</p>
    UnauthorizedResourceAccessException(crate::error::UnauthorizedResourceAccessException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateLabelsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CreateLabelsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::EntityNotExistsException(_inner) => _inner.fmt(f),
            Self::FailedDependencyException(_inner) => _inner.fmt(f),
            Self::ServiceUnavailableException(_inner) => _inner.fmt(f),
            Self::TooManyLabelsException(_inner) => _inner.fmt(f),
            Self::UnauthorizedOperationException(_inner) => _inner.fmt(f),
            Self::UnauthorizedResourceAccessException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CreateLabelsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::EntityNotExistsException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::FailedDependencyException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyLabelsException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedResourceAccessException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CreateLabelsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateLabelsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateLabelsError {
    /// Creates the `CreateLabelsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CreateLabelsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::EntityNotExistsException(e) => e.meta(),
            Self::FailedDependencyException(e) => e.meta(),
            Self::ServiceUnavailableException(e) => e.meta(),
            Self::TooManyLabelsException(e) => e.meta(),
            Self::UnauthorizedOperationException(e) => e.meta(),
            Self::UnauthorizedResourceAccessException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateLabelsError::EntityNotExistsException`.
    pub fn is_entity_not_exists_exception(&self) -> bool {
        matches!(self, Self::EntityNotExistsException(_))
    }
    /// Returns `true` if the error kind is `CreateLabelsError::FailedDependencyException`.
    pub fn is_failed_dependency_exception(&self) -> bool {
        matches!(self, Self::FailedDependencyException(_))
    }
    /// Returns `true` if the error kind is `CreateLabelsError::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(self, Self::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `CreateLabelsError::TooManyLabelsException`.
    pub fn is_too_many_labels_exception(&self) -> bool {
        matches!(self, Self::TooManyLabelsException(_))
    }
    /// Returns `true` if the error kind is `CreateLabelsError::UnauthorizedOperationException`.
    pub fn is_unauthorized_operation_exception(&self) -> bool {
        matches!(self, Self::UnauthorizedOperationException(_))
    }
    /// Returns `true` if the error kind is `CreateLabelsError::UnauthorizedResourceAccessException`.
    pub fn is_unauthorized_resource_access_exception(&self) -> bool {
        matches!(self, Self::UnauthorizedResourceAccessException(_))
    }
}
impl std::error::Error for CreateLabelsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::EntityNotExistsException(_inner) => Some(_inner),
            Self::FailedDependencyException(_inner) => Some(_inner),
            Self::ServiceUnavailableException(_inner) => Some(_inner),
            Self::TooManyLabelsException(_inner) => Some(_inner),
            Self::UnauthorizedOperationException(_inner) => Some(_inner),
            Self::UnauthorizedResourceAccessException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The limit has been reached on the number of labels for the specified resource.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TooManyLabelsException {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl TooManyLabelsException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TooManyLabelsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TooManyLabelsException")?;
        if let Some(inner_23) = &self.message {
            {
                write!(f, ": {}", inner_23)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for TooManyLabelsException {}
impl aws_http::request_id::RequestId for crate::error::TooManyLabelsException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for TooManyLabelsException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl TooManyLabelsException {
    /// Creates a new builder-style object to manufacture [`TooManyLabelsException`](crate::error::TooManyLabelsException).
    pub fn builder() -> crate::error::too_many_labels_exception::Builder {
        crate::error::too_many_labels_exception::Builder::default()
    }
}

/// See [`TooManyLabelsException`](crate::error::TooManyLabelsException).
pub mod too_many_labels_exception {

    /// A builder for [`TooManyLabelsException`](crate::error::TooManyLabelsException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`TooManyLabelsException`](crate::error::TooManyLabelsException).
        pub fn build(self) -> crate::error::TooManyLabelsException {
            crate::error::TooManyLabelsException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreateFolderErrorKind = CreateFolderError;
/// Error type for the `CreateFolderError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateFolderError {
    /// <p>The resource hierarchy is changing.</p>
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    /// <p>Another operation is in progress on the resource that conflicts with the current operation.</p>
    ConflictingOperationException(crate::error::ConflictingOperationException),
    /// <p>The resource already exists.</p>
    EntityAlreadyExistsException(crate::error::EntityAlreadyExistsException),
    /// <p>The resource does not exist.</p>
    EntityNotExistsException(crate::error::EntityNotExistsException),
    /// <p>The AWS Directory Service cannot reach an on-premises instance. Or a dependency under the control of the organization is failing, such as a connected Active Directory.</p>
    FailedDependencyException(crate::error::FailedDependencyException),
    /// <p>The maximum of 100,000 files and folders under the parent folder has been exceeded.</p>
    LimitExceededException(crate::error::LimitExceededException),
    /// <p>The specified document version is not in the INITIALIZED state.</p>
    ProhibitedStateException(crate::error::ProhibitedStateException),
    /// <p>One or more of the dependencies is unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The operation is not permitted.</p>
    UnauthorizedOperationException(crate::error::UnauthorizedOperationException),
    /// <p>The caller does not have access to perform the action on the resource.</p>
    UnauthorizedResourceAccessException(crate::error::UnauthorizedResourceAccessException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateFolderError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CreateFolderError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ConcurrentModificationException(_inner) => _inner.fmt(f),
            Self::ConflictingOperationException(_inner) => _inner.fmt(f),
            Self::EntityAlreadyExistsException(_inner) => _inner.fmt(f),
            Self::EntityNotExistsException(_inner) => _inner.fmt(f),
            Self::FailedDependencyException(_inner) => _inner.fmt(f),
            Self::LimitExceededException(_inner) => _inner.fmt(f),
            Self::ProhibitedStateException(_inner) => _inner.fmt(f),
            Self::ServiceUnavailableException(_inner) => _inner.fmt(f),
            Self::UnauthorizedOperationException(_inner) => _inner.fmt(f),
            Self::UnauthorizedResourceAccessException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CreateFolderError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ConcurrentModificationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ConflictingOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EntityAlreadyExistsException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EntityNotExistsException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::FailedDependencyException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::LimitExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ProhibitedStateException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedResourceAccessException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CreateFolderError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateFolderError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateFolderError {
    /// Creates the `CreateFolderError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CreateFolderError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ConcurrentModificationException(e) => e.meta(),
            Self::ConflictingOperationException(e) => e.meta(),
            Self::EntityAlreadyExistsException(e) => e.meta(),
            Self::EntityNotExistsException(e) => e.meta(),
            Self::FailedDependencyException(e) => e.meta(),
            Self::LimitExceededException(e) => e.meta(),
            Self::ProhibitedStateException(e) => e.meta(),
            Self::ServiceUnavailableException(e) => e.meta(),
            Self::UnauthorizedOperationException(e) => e.meta(),
            Self::UnauthorizedResourceAccessException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateFolderError::ConcurrentModificationException`.
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(self, Self::ConcurrentModificationException(_))
    }
    /// Returns `true` if the error kind is `CreateFolderError::ConflictingOperationException`.
    pub fn is_conflicting_operation_exception(&self) -> bool {
        matches!(self, Self::ConflictingOperationException(_))
    }
    /// Returns `true` if the error kind is `CreateFolderError::EntityAlreadyExistsException`.
    pub fn is_entity_already_exists_exception(&self) -> bool {
        matches!(self, Self::EntityAlreadyExistsException(_))
    }
    /// Returns `true` if the error kind is `CreateFolderError::EntityNotExistsException`.
    pub fn is_entity_not_exists_exception(&self) -> bool {
        matches!(self, Self::EntityNotExistsException(_))
    }
    /// Returns `true` if the error kind is `CreateFolderError::FailedDependencyException`.
    pub fn is_failed_dependency_exception(&self) -> bool {
        matches!(self, Self::FailedDependencyException(_))
    }
    /// Returns `true` if the error kind is `CreateFolderError::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(self, Self::LimitExceededException(_))
    }
    /// Returns `true` if the error kind is `CreateFolderError::ProhibitedStateException`.
    pub fn is_prohibited_state_exception(&self) -> bool {
        matches!(self, Self::ProhibitedStateException(_))
    }
    /// Returns `true` if the error kind is `CreateFolderError::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(self, Self::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `CreateFolderError::UnauthorizedOperationException`.
    pub fn is_unauthorized_operation_exception(&self) -> bool {
        matches!(self, Self::UnauthorizedOperationException(_))
    }
    /// Returns `true` if the error kind is `CreateFolderError::UnauthorizedResourceAccessException`.
    pub fn is_unauthorized_resource_access_exception(&self) -> bool {
        matches!(self, Self::UnauthorizedResourceAccessException(_))
    }
}
impl std::error::Error for CreateFolderError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ConcurrentModificationException(_inner) => Some(_inner),
            Self::ConflictingOperationException(_inner) => Some(_inner),
            Self::EntityAlreadyExistsException(_inner) => Some(_inner),
            Self::EntityNotExistsException(_inner) => Some(_inner),
            Self::FailedDependencyException(_inner) => Some(_inner),
            Self::LimitExceededException(_inner) => Some(_inner),
            Self::ProhibitedStateException(_inner) => Some(_inner),
            Self::ServiceUnavailableException(_inner) => Some(_inner),
            Self::UnauthorizedOperationException(_inner) => Some(_inner),
            Self::UnauthorizedResourceAccessException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreateCustomMetadataErrorKind = CreateCustomMetadataError;
/// Error type for the `CreateCustomMetadataError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateCustomMetadataError {
    /// <p>The limit has been reached on the number of custom properties for the specified resource.</p>
    CustomMetadataLimitExceededException(crate::error::CustomMetadataLimitExceededException),
    /// <p>The resource does not exist.</p>
    EntityNotExistsException(crate::error::EntityNotExistsException),
    /// <p>The AWS Directory Service cannot reach an on-premises instance. Or a dependency under the control of the organization is failing, such as a connected Active Directory.</p>
    FailedDependencyException(crate::error::FailedDependencyException),
    /// <p>The specified document version is not in the INITIALIZED state.</p>
    ProhibitedStateException(crate::error::ProhibitedStateException),
    /// <p>One or more of the dependencies is unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The operation is not permitted.</p>
    UnauthorizedOperationException(crate::error::UnauthorizedOperationException),
    /// <p>The caller does not have access to perform the action on the resource.</p>
    UnauthorizedResourceAccessException(crate::error::UnauthorizedResourceAccessException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateCustomMetadataError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CreateCustomMetadataError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::CustomMetadataLimitExceededException(_inner) => _inner.fmt(f),
            Self::EntityNotExistsException(_inner) => _inner.fmt(f),
            Self::FailedDependencyException(_inner) => _inner.fmt(f),
            Self::ProhibitedStateException(_inner) => _inner.fmt(f),
            Self::ServiceUnavailableException(_inner) => _inner.fmt(f),
            Self::UnauthorizedOperationException(_inner) => _inner.fmt(f),
            Self::UnauthorizedResourceAccessException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CreateCustomMetadataError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::CustomMetadataLimitExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EntityNotExistsException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::FailedDependencyException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ProhibitedStateException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedResourceAccessException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CreateCustomMetadataError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateCustomMetadataError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateCustomMetadataError {
    /// Creates the `CreateCustomMetadataError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CreateCustomMetadataError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::CustomMetadataLimitExceededException(e) => e.meta(),
            Self::EntityNotExistsException(e) => e.meta(),
            Self::FailedDependencyException(e) => e.meta(),
            Self::ProhibitedStateException(e) => e.meta(),
            Self::ServiceUnavailableException(e) => e.meta(),
            Self::UnauthorizedOperationException(e) => e.meta(),
            Self::UnauthorizedResourceAccessException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateCustomMetadataError::CustomMetadataLimitExceededException`.
    pub fn is_custom_metadata_limit_exceeded_exception(&self) -> bool {
        matches!(self, Self::CustomMetadataLimitExceededException(_))
    }
    /// Returns `true` if the error kind is `CreateCustomMetadataError::EntityNotExistsException`.
    pub fn is_entity_not_exists_exception(&self) -> bool {
        matches!(self, Self::EntityNotExistsException(_))
    }
    /// Returns `true` if the error kind is `CreateCustomMetadataError::FailedDependencyException`.
    pub fn is_failed_dependency_exception(&self) -> bool {
        matches!(self, Self::FailedDependencyException(_))
    }
    /// Returns `true` if the error kind is `CreateCustomMetadataError::ProhibitedStateException`.
    pub fn is_prohibited_state_exception(&self) -> bool {
        matches!(self, Self::ProhibitedStateException(_))
    }
    /// Returns `true` if the error kind is `CreateCustomMetadataError::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(self, Self::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `CreateCustomMetadataError::UnauthorizedOperationException`.
    pub fn is_unauthorized_operation_exception(&self) -> bool {
        matches!(self, Self::UnauthorizedOperationException(_))
    }
    /// Returns `true` if the error kind is `CreateCustomMetadataError::UnauthorizedResourceAccessException`.
    pub fn is_unauthorized_resource_access_exception(&self) -> bool {
        matches!(self, Self::UnauthorizedResourceAccessException(_))
    }
}
impl std::error::Error for CreateCustomMetadataError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::CustomMetadataLimitExceededException(_inner) => Some(_inner),
            Self::EntityNotExistsException(_inner) => Some(_inner),
            Self::FailedDependencyException(_inner) => Some(_inner),
            Self::ProhibitedStateException(_inner) => Some(_inner),
            Self::ServiceUnavailableException(_inner) => Some(_inner),
            Self::UnauthorizedOperationException(_inner) => Some(_inner),
            Self::UnauthorizedResourceAccessException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The limit has been reached on the number of custom properties for the specified resource.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CustomMetadataLimitExceededException {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl CustomMetadataLimitExceededException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CustomMetadataLimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CustomMetadataLimitExceededException")?;
        if let Some(inner_24) = &self.message {
            {
                write!(f, ": {}", inner_24)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for CustomMetadataLimitExceededException {}
impl aws_http::request_id::RequestId for crate::error::CustomMetadataLimitExceededException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for CustomMetadataLimitExceededException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl CustomMetadataLimitExceededException {
    /// Creates a new builder-style object to manufacture [`CustomMetadataLimitExceededException`](crate::error::CustomMetadataLimitExceededException).
    pub fn builder() -> crate::error::custom_metadata_limit_exceeded_exception::Builder {
        crate::error::custom_metadata_limit_exceeded_exception::Builder::default()
    }
}

/// See [`CustomMetadataLimitExceededException`](crate::error::CustomMetadataLimitExceededException).
pub mod custom_metadata_limit_exceeded_exception {

    /// A builder for [`CustomMetadataLimitExceededException`](crate::error::CustomMetadataLimitExceededException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`CustomMetadataLimitExceededException`](crate::error::CustomMetadataLimitExceededException).
        pub fn build(self) -> crate::error::CustomMetadataLimitExceededException {
            crate::error::CustomMetadataLimitExceededException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreateCommentErrorKind = CreateCommentError;
/// Error type for the `CreateCommentError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateCommentError {
    /// <p>This exception is thrown when the document is locked for comments and user tries to create or delete a comment on that document.</p>
    DocumentLockedForCommentsException(crate::error::DocumentLockedForCommentsException),
    /// <p>The resource does not exist.</p>
    EntityNotExistsException(crate::error::EntityNotExistsException),
    /// <p>The AWS Directory Service cannot reach an on-premises instance. Or a dependency under the control of the organization is failing, such as a connected Active Directory.</p>
    FailedDependencyException(crate::error::FailedDependencyException),
    /// <p>The requested operation is not allowed on the specified comment object.</p>
    InvalidCommentOperationException(crate::error::InvalidCommentOperationException),
    /// <p>The specified document version is not in the INITIALIZED state.</p>
    ProhibitedStateException(crate::error::ProhibitedStateException),
    /// <p>One or more of the dependencies is unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The operation is not permitted.</p>
    UnauthorizedOperationException(crate::error::UnauthorizedOperationException),
    /// <p>The caller does not have access to perform the action on the resource.</p>
    UnauthorizedResourceAccessException(crate::error::UnauthorizedResourceAccessException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateCommentError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CreateCommentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::DocumentLockedForCommentsException(_inner) => _inner.fmt(f),
            Self::EntityNotExistsException(_inner) => _inner.fmt(f),
            Self::FailedDependencyException(_inner) => _inner.fmt(f),
            Self::InvalidCommentOperationException(_inner) => _inner.fmt(f),
            Self::ProhibitedStateException(_inner) => _inner.fmt(f),
            Self::ServiceUnavailableException(_inner) => _inner.fmt(f),
            Self::UnauthorizedOperationException(_inner) => _inner.fmt(f),
            Self::UnauthorizedResourceAccessException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CreateCommentError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::DocumentLockedForCommentsException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EntityNotExistsException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::FailedDependencyException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidCommentOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ProhibitedStateException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedResourceAccessException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CreateCommentError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateCommentError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateCommentError {
    /// Creates the `CreateCommentError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CreateCommentError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::DocumentLockedForCommentsException(e) => e.meta(),
            Self::EntityNotExistsException(e) => e.meta(),
            Self::FailedDependencyException(e) => e.meta(),
            Self::InvalidCommentOperationException(e) => e.meta(),
            Self::ProhibitedStateException(e) => e.meta(),
            Self::ServiceUnavailableException(e) => e.meta(),
            Self::UnauthorizedOperationException(e) => e.meta(),
            Self::UnauthorizedResourceAccessException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateCommentError::DocumentLockedForCommentsException`.
    pub fn is_document_locked_for_comments_exception(&self) -> bool {
        matches!(self, Self::DocumentLockedForCommentsException(_))
    }
    /// Returns `true` if the error kind is `CreateCommentError::EntityNotExistsException`.
    pub fn is_entity_not_exists_exception(&self) -> bool {
        matches!(self, Self::EntityNotExistsException(_))
    }
    /// Returns `true` if the error kind is `CreateCommentError::FailedDependencyException`.
    pub fn is_failed_dependency_exception(&self) -> bool {
        matches!(self, Self::FailedDependencyException(_))
    }
    /// Returns `true` if the error kind is `CreateCommentError::InvalidCommentOperationException`.
    pub fn is_invalid_comment_operation_exception(&self) -> bool {
        matches!(self, Self::InvalidCommentOperationException(_))
    }
    /// Returns `true` if the error kind is `CreateCommentError::ProhibitedStateException`.
    pub fn is_prohibited_state_exception(&self) -> bool {
        matches!(self, Self::ProhibitedStateException(_))
    }
    /// Returns `true` if the error kind is `CreateCommentError::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(self, Self::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `CreateCommentError::UnauthorizedOperationException`.
    pub fn is_unauthorized_operation_exception(&self) -> bool {
        matches!(self, Self::UnauthorizedOperationException(_))
    }
    /// Returns `true` if the error kind is `CreateCommentError::UnauthorizedResourceAccessException`.
    pub fn is_unauthorized_resource_access_exception(&self) -> bool {
        matches!(self, Self::UnauthorizedResourceAccessException(_))
    }
}
impl std::error::Error for CreateCommentError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::DocumentLockedForCommentsException(_inner) => Some(_inner),
            Self::EntityNotExistsException(_inner) => Some(_inner),
            Self::FailedDependencyException(_inner) => Some(_inner),
            Self::InvalidCommentOperationException(_inner) => Some(_inner),
            Self::ProhibitedStateException(_inner) => Some(_inner),
            Self::ServiceUnavailableException(_inner) => Some(_inner),
            Self::UnauthorizedOperationException(_inner) => Some(_inner),
            Self::UnauthorizedResourceAccessException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The requested operation is not allowed on the specified comment object.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidCommentOperationException {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidCommentOperationException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidCommentOperationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidCommentOperationException")?;
        if let Some(inner_25) = &self.message {
            {
                write!(f, ": {}", inner_25)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidCommentOperationException {}
impl aws_http::request_id::RequestId for crate::error::InvalidCommentOperationException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidCommentOperationException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidCommentOperationException {
    /// Creates a new builder-style object to manufacture [`InvalidCommentOperationException`](crate::error::InvalidCommentOperationException).
    pub fn builder() -> crate::error::invalid_comment_operation_exception::Builder {
        crate::error::invalid_comment_operation_exception::Builder::default()
    }
}

/// See [`InvalidCommentOperationException`](crate::error::InvalidCommentOperationException).
pub mod invalid_comment_operation_exception {

    /// A builder for [`InvalidCommentOperationException`](crate::error::InvalidCommentOperationException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidCommentOperationException`](crate::error::InvalidCommentOperationException).
        pub fn build(self) -> crate::error::InvalidCommentOperationException {
            crate::error::InvalidCommentOperationException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type AddResourcePermissionsErrorKind = AddResourcePermissionsError;
/// Error type for the `AddResourcePermissionsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AddResourcePermissionsError {
    /// <p>The AWS Directory Service cannot reach an on-premises instance. Or a dependency under the control of the organization is failing, such as a connected Active Directory.</p>
    FailedDependencyException(crate::error::FailedDependencyException),
    /// <p>The specified document version is not in the INITIALIZED state.</p>
    ProhibitedStateException(crate::error::ProhibitedStateException),
    /// <p>One or more of the dependencies is unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The operation is not permitted.</p>
    UnauthorizedOperationException(crate::error::UnauthorizedOperationException),
    /// <p>The caller does not have access to perform the action on the resource.</p>
    UnauthorizedResourceAccessException(crate::error::UnauthorizedResourceAccessException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for AddResourcePermissionsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for AddResourcePermissionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::FailedDependencyException(_inner) => _inner.fmt(f),
            Self::ProhibitedStateException(_inner) => _inner.fmt(f),
            Self::ServiceUnavailableException(_inner) => _inner.fmt(f),
            Self::UnauthorizedOperationException(_inner) => _inner.fmt(f),
            Self::UnauthorizedResourceAccessException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for AddResourcePermissionsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::FailedDependencyException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ProhibitedStateException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedResourceAccessException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::AddResourcePermissionsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for AddResourcePermissionsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl AddResourcePermissionsError {
    /// Creates the `AddResourcePermissionsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `AddResourcePermissionsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::FailedDependencyException(e) => e.meta(),
            Self::ProhibitedStateException(e) => e.meta(),
            Self::ServiceUnavailableException(e) => e.meta(),
            Self::UnauthorizedOperationException(e) => e.meta(),
            Self::UnauthorizedResourceAccessException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `AddResourcePermissionsError::FailedDependencyException`.
    pub fn is_failed_dependency_exception(&self) -> bool {
        matches!(self, Self::FailedDependencyException(_))
    }
    /// Returns `true` if the error kind is `AddResourcePermissionsError::ProhibitedStateException`.
    pub fn is_prohibited_state_exception(&self) -> bool {
        matches!(self, Self::ProhibitedStateException(_))
    }
    /// Returns `true` if the error kind is `AddResourcePermissionsError::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(self, Self::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `AddResourcePermissionsError::UnauthorizedOperationException`.
    pub fn is_unauthorized_operation_exception(&self) -> bool {
        matches!(self, Self::UnauthorizedOperationException(_))
    }
    /// Returns `true` if the error kind is `AddResourcePermissionsError::UnauthorizedResourceAccessException`.
    pub fn is_unauthorized_resource_access_exception(&self) -> bool {
        matches!(self, Self::UnauthorizedResourceAccessException(_))
    }
}
impl std::error::Error for AddResourcePermissionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::FailedDependencyException(_inner) => Some(_inner),
            Self::ProhibitedStateException(_inner) => Some(_inner),
            Self::ServiceUnavailableException(_inner) => Some(_inner),
            Self::UnauthorizedOperationException(_inner) => Some(_inner),
            Self::UnauthorizedResourceAccessException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ActivateUserErrorKind = ActivateUserError;
/// Error type for the `ActivateUserError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ActivateUserError {
    /// <p>The resource does not exist.</p>
    EntityNotExistsException(crate::error::EntityNotExistsException),
    /// <p>The AWS Directory Service cannot reach an on-premises instance. Or a dependency under the control of the organization is failing, such as a connected Active Directory.</p>
    FailedDependencyException(crate::error::FailedDependencyException),
    /// <p>One or more of the dependencies is unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The operation is not permitted.</p>
    UnauthorizedOperationException(crate::error::UnauthorizedOperationException),
    /// <p>The caller does not have access to perform the action on the resource.</p>
    UnauthorizedResourceAccessException(crate::error::UnauthorizedResourceAccessException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ActivateUserError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ActivateUserError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::EntityNotExistsException(_inner) => _inner.fmt(f),
            Self::FailedDependencyException(_inner) => _inner.fmt(f),
            Self::ServiceUnavailableException(_inner) => _inner.fmt(f),
            Self::UnauthorizedOperationException(_inner) => _inner.fmt(f),
            Self::UnauthorizedResourceAccessException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ActivateUserError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::EntityNotExistsException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::FailedDependencyException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedResourceAccessException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ActivateUserError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ActivateUserError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ActivateUserError {
    /// Creates the `ActivateUserError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ActivateUserError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::EntityNotExistsException(e) => e.meta(),
            Self::FailedDependencyException(e) => e.meta(),
            Self::ServiceUnavailableException(e) => e.meta(),
            Self::UnauthorizedOperationException(e) => e.meta(),
            Self::UnauthorizedResourceAccessException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ActivateUserError::EntityNotExistsException`.
    pub fn is_entity_not_exists_exception(&self) -> bool {
        matches!(self, Self::EntityNotExistsException(_))
    }
    /// Returns `true` if the error kind is `ActivateUserError::FailedDependencyException`.
    pub fn is_failed_dependency_exception(&self) -> bool {
        matches!(self, Self::FailedDependencyException(_))
    }
    /// Returns `true` if the error kind is `ActivateUserError::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(self, Self::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `ActivateUserError::UnauthorizedOperationException`.
    pub fn is_unauthorized_operation_exception(&self) -> bool {
        matches!(self, Self::UnauthorizedOperationException(_))
    }
    /// Returns `true` if the error kind is `ActivateUserError::UnauthorizedResourceAccessException`.
    pub fn is_unauthorized_resource_access_exception(&self) -> bool {
        matches!(self, Self::UnauthorizedResourceAccessException(_))
    }
}
impl std::error::Error for ActivateUserError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::EntityNotExistsException(_inner) => Some(_inner),
            Self::FailedDependencyException(_inner) => Some(_inner),
            Self::ServiceUnavailableException(_inner) => Some(_inner),
            Self::UnauthorizedOperationException(_inner) => Some(_inner),
            Self::UnauthorizedResourceAccessException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type AbortDocumentVersionUploadErrorKind = AbortDocumentVersionUploadError;
/// Error type for the `AbortDocumentVersionUploadError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AbortDocumentVersionUploadError {
    /// <p>The resource hierarchy is changing.</p>
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    /// <p>The resource does not exist.</p>
    EntityNotExistsException(crate::error::EntityNotExistsException),
    /// <p>The AWS Directory Service cannot reach an on-premises instance. Or a dependency under the control of the organization is failing, such as a connected Active Directory.</p>
    FailedDependencyException(crate::error::FailedDependencyException),
    /// <p>The specified document version is not in the INITIALIZED state.</p>
    ProhibitedStateException(crate::error::ProhibitedStateException),
    /// <p>One or more of the dependencies is unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The operation is not permitted.</p>
    UnauthorizedOperationException(crate::error::UnauthorizedOperationException),
    /// <p>The caller does not have access to perform the action on the resource.</p>
    UnauthorizedResourceAccessException(crate::error::UnauthorizedResourceAccessException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for AbortDocumentVersionUploadError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for AbortDocumentVersionUploadError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ConcurrentModificationException(_inner) => _inner.fmt(f),
            Self::EntityNotExistsException(_inner) => _inner.fmt(f),
            Self::FailedDependencyException(_inner) => _inner.fmt(f),
            Self::ProhibitedStateException(_inner) => _inner.fmt(f),
            Self::ServiceUnavailableException(_inner) => _inner.fmt(f),
            Self::UnauthorizedOperationException(_inner) => _inner.fmt(f),
            Self::UnauthorizedResourceAccessException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for AbortDocumentVersionUploadError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ConcurrentModificationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EntityNotExistsException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::FailedDependencyException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ProhibitedStateException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedResourceAccessException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::AbortDocumentVersionUploadError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for AbortDocumentVersionUploadError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl AbortDocumentVersionUploadError {
    /// Creates the `AbortDocumentVersionUploadError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `AbortDocumentVersionUploadError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ConcurrentModificationException(e) => e.meta(),
            Self::EntityNotExistsException(e) => e.meta(),
            Self::FailedDependencyException(e) => e.meta(),
            Self::ProhibitedStateException(e) => e.meta(),
            Self::ServiceUnavailableException(e) => e.meta(),
            Self::UnauthorizedOperationException(e) => e.meta(),
            Self::UnauthorizedResourceAccessException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `AbortDocumentVersionUploadError::ConcurrentModificationException`.
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(self, Self::ConcurrentModificationException(_))
    }
    /// Returns `true` if the error kind is `AbortDocumentVersionUploadError::EntityNotExistsException`.
    pub fn is_entity_not_exists_exception(&self) -> bool {
        matches!(self, Self::EntityNotExistsException(_))
    }
    /// Returns `true` if the error kind is `AbortDocumentVersionUploadError::FailedDependencyException`.
    pub fn is_failed_dependency_exception(&self) -> bool {
        matches!(self, Self::FailedDependencyException(_))
    }
    /// Returns `true` if the error kind is `AbortDocumentVersionUploadError::ProhibitedStateException`.
    pub fn is_prohibited_state_exception(&self) -> bool {
        matches!(self, Self::ProhibitedStateException(_))
    }
    /// Returns `true` if the error kind is `AbortDocumentVersionUploadError::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(self, Self::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `AbortDocumentVersionUploadError::UnauthorizedOperationException`.
    pub fn is_unauthorized_operation_exception(&self) -> bool {
        matches!(self, Self::UnauthorizedOperationException(_))
    }
    /// Returns `true` if the error kind is `AbortDocumentVersionUploadError::UnauthorizedResourceAccessException`.
    pub fn is_unauthorized_resource_access_exception(&self) -> bool {
        matches!(self, Self::UnauthorizedResourceAccessException(_))
    }
}
impl std::error::Error for AbortDocumentVersionUploadError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ConcurrentModificationException(_inner) => Some(_inner),
            Self::EntityNotExistsException(_inner) => Some(_inner),
            Self::FailedDependencyException(_inner) => Some(_inner),
            Self::ProhibitedStateException(_inner) => Some(_inner),
            Self::ServiceUnavailableException(_inner) => Some(_inner),
            Self::UnauthorizedOperationException(_inner) => Some(_inner),
            Self::UnauthorizedResourceAccessException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}
