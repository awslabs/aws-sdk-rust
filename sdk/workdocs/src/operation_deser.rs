// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(clippy::unnecessary_wraps)]
pub fn parse_abort_document_version_upload_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AbortDocumentVersionUploadOutput,
    crate::error::AbortDocumentVersionUploadError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::AbortDocumentVersionUploadError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::AbortDocumentVersionUploadError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "EntityNotExistsException" => crate::error::AbortDocumentVersionUploadError { meta: generic, kind: crate::error::AbortDocumentVersionUploadErrorKind::EntityNotExistsException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::entity_not_exists_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_entity_not_exists_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::AbortDocumentVersionUploadError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "FailedDependencyException" => crate::error::AbortDocumentVersionUploadError { meta: generic, kind: crate::error::AbortDocumentVersionUploadErrorKind::FailedDependencyException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::failed_dependency_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_failed_dependency_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::AbortDocumentVersionUploadError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ProhibitedStateException" => crate::error::AbortDocumentVersionUploadError { meta: generic, kind: crate::error::AbortDocumentVersionUploadErrorKind::ProhibitedStateException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::prohibited_state_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_prohibited_state_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::AbortDocumentVersionUploadError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ServiceUnavailableException" => crate::error::AbortDocumentVersionUploadError { meta: generic, kind: crate::error::AbortDocumentVersionUploadErrorKind::ServiceUnavailableException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::service_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_service_unavailable_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::AbortDocumentVersionUploadError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedOperationException" => crate::error::AbortDocumentVersionUploadError { meta: generic, kind: crate::error::AbortDocumentVersionUploadErrorKind::UnauthorizedOperationException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::unauthorized_operation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_unauthorized_operation_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::AbortDocumentVersionUploadError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedResourceAccessException" => crate::error::AbortDocumentVersionUploadError { meta: generic, kind: crate::error::AbortDocumentVersionUploadErrorKind::UnauthorizedResourceAccessException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::unauthorized_resource_access_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_unauthorized_resource_access_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::AbortDocumentVersionUploadError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::AbortDocumentVersionUploadError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_abort_document_version_upload_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AbortDocumentVersionUploadOutput,
    crate::error::AbortDocumentVersionUploadError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::abort_document_version_upload_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_activate_user_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ActivateUserOutput, crate::error::ActivateUserError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ActivateUserError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ActivateUserError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "EntityNotExistsException" => crate::error::ActivateUserError {
            meta: generic,
            kind: crate::error::ActivateUserErrorKind::EntityNotExistsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::entity_not_exists_exception::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_entity_not_exists_exceptionjson_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::ActivateUserError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "FailedDependencyException" => crate::error::ActivateUserError {
            meta: generic,
            kind: crate::error::ActivateUserErrorKind::FailedDependencyException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::failed_dependency_exception::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_failed_dependency_exceptionjson_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::ActivateUserError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceUnavailableException" => {
            crate::error::ActivateUserError {
                meta: generic,
                kind: crate::error::ActivateUserErrorKind::ServiceUnavailableException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::service_unavailable_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_service_unavailable_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::ActivateUserError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "UnauthorizedOperationException" => crate::error::ActivateUserError {
            meta: generic,
            kind: crate::error::ActivateUserErrorKind::UnauthorizedOperationException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::unauthorized_operation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_unauthorized_operation_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::ActivateUserError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "UnauthorizedResourceAccessException" => crate::error::ActivateUserError {
            meta: generic,
            kind: crate::error::ActivateUserErrorKind::UnauthorizedResourceAccessException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::unauthorized_resource_access_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_unauthorized_resource_access_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::ActivateUserError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ActivateUserError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_activate_user_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ActivateUserOutput, crate::error::ActivateUserError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::activate_user_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_activate_user(response.body().as_ref(), output)
            .map_err(crate::error::ActivateUserError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_add_resource_permissions_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AddResourcePermissionsOutput,
    crate::error::AddResourcePermissionsError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::AddResourcePermissionsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::AddResourcePermissionsError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "FailedDependencyException" => crate::error::AddResourcePermissionsError {
            meta: generic,
            kind: crate::error::AddResourcePermissionsErrorKind::FailedDependencyException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::failed_dependency_exception::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_failed_dependency_exceptionjson_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::AddResourcePermissionsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceUnavailableException" => {
            crate::error::AddResourcePermissionsError {
                meta: generic,
                kind: crate::error::AddResourcePermissionsErrorKind::ServiceUnavailableException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::service_unavailable_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_service_unavailable_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::AddResourcePermissionsError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "UnauthorizedOperationException" => crate::error::AddResourcePermissionsError {
            meta: generic,
            kind: crate::error::AddResourcePermissionsErrorKind::UnauthorizedOperationException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::unauthorized_operation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_unauthorized_operation_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::AddResourcePermissionsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "UnauthorizedResourceAccessException" => crate::error::AddResourcePermissionsError {
            meta: generic,
            kind:
                crate::error::AddResourcePermissionsErrorKind::UnauthorizedResourceAccessException(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]let mut output = crate::error::unauthorized_resource_access_exception::Builder::default();
                            let _ = response;
                            output = crate::json_deser::deser_structure_unauthorized_resource_access_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::AddResourcePermissionsError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        _ => crate::error::AddResourcePermissionsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_add_resource_permissions_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AddResourcePermissionsOutput,
    crate::error::AddResourcePermissionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::add_resource_permissions_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_add_resource_permissions(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::AddResourcePermissionsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_comment_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateCommentOutput, crate::error::CreateCommentError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateCommentError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateCommentError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DocumentLockedForCommentsException" => crate::error::CreateCommentError {
            meta: generic,
            kind: crate::error::CreateCommentErrorKind::DocumentLockedForCommentsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::document_locked_for_comments_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_document_locked_for_comments_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateCommentError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EntityNotExistsException" => crate::error::CreateCommentError {
            meta: generic,
            kind: crate::error::CreateCommentErrorKind::EntityNotExistsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::entity_not_exists_exception::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_entity_not_exists_exceptionjson_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::CreateCommentError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "FailedDependencyException" => crate::error::CreateCommentError {
            meta: generic,
            kind: crate::error::CreateCommentErrorKind::FailedDependencyException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::failed_dependency_exception::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_failed_dependency_exceptionjson_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::CreateCommentError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidCommentOperationException" => crate::error::CreateCommentError {
            meta: generic,
            kind: crate::error::CreateCommentErrorKind::InvalidCommentOperationException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_comment_operation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_comment_operation_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateCommentError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ProhibitedStateException" => crate::error::CreateCommentError {
            meta: generic,
            kind: crate::error::CreateCommentErrorKind::ProhibitedStateException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::prohibited_state_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_prohibited_state_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateCommentError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceUnavailableException" => {
            crate::error::CreateCommentError {
                meta: generic,
                kind: crate::error::CreateCommentErrorKind::ServiceUnavailableException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::service_unavailable_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_service_unavailable_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateCommentError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "UnauthorizedOperationException" => crate::error::CreateCommentError {
            meta: generic,
            kind: crate::error::CreateCommentErrorKind::UnauthorizedOperationException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::unauthorized_operation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_unauthorized_operation_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateCommentError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "UnauthorizedResourceAccessException" => crate::error::CreateCommentError {
            meta: generic,
            kind: crate::error::CreateCommentErrorKind::UnauthorizedResourceAccessException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::unauthorized_resource_access_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_unauthorized_resource_access_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateCommentError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::CreateCommentError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_comment_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateCommentOutput, crate::error::CreateCommentError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_comment_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_create_comment(response.body().as_ref(), output)
                .map_err(crate::error::CreateCommentError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_custom_metadata_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateCustomMetadataOutput,
    crate::error::CreateCustomMetadataError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateCustomMetadataError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateCustomMetadataError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "CustomMetadataLimitExceededException" => crate::error::CreateCustomMetadataError {
            meta: generic,
            kind: crate::error::CreateCustomMetadataErrorKind::CustomMetadataLimitExceededException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]let mut output = crate::error::custom_metadata_limit_exceeded_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_custom_metadata_limit_exceeded_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateCustomMetadataError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "EntityNotExistsException" => crate::error::CreateCustomMetadataError {
            meta: generic,
            kind: crate::error::CreateCustomMetadataErrorKind::EntityNotExistsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::entity_not_exists_exception::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_entity_not_exists_exceptionjson_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::CreateCustomMetadataError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "FailedDependencyException" => crate::error::CreateCustomMetadataError {
            meta: generic,
            kind: crate::error::CreateCustomMetadataErrorKind::FailedDependencyException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::failed_dependency_exception::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_failed_dependency_exceptionjson_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::CreateCustomMetadataError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ProhibitedStateException" => crate::error::CreateCustomMetadataError {
            meta: generic,
            kind: crate::error::CreateCustomMetadataErrorKind::ProhibitedStateException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::prohibited_state_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_prohibited_state_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateCustomMetadataError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceUnavailableException" => {
            crate::error::CreateCustomMetadataError {
                meta: generic,
                kind: crate::error::CreateCustomMetadataErrorKind::ServiceUnavailableException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::service_unavailable_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_service_unavailable_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateCustomMetadataError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "UnauthorizedOperationException" => crate::error::CreateCustomMetadataError {
            meta: generic,
            kind: crate::error::CreateCustomMetadataErrorKind::UnauthorizedOperationException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::unauthorized_operation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_unauthorized_operation_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateCustomMetadataError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "UnauthorizedResourceAccessException" => {
            crate::error::CreateCustomMetadataError {
                meta: generic,
                kind:
                    crate::error::CreateCustomMetadataErrorKind::UnauthorizedResourceAccessException(
                        {
                            #[allow(unused_mut)]
                            let mut tmp = {
                                #[allow(unused_mut)]let mut output = crate::error::unauthorized_resource_access_exception::Builder::default();
                                let _ = response;
                                output = crate::json_deser::deser_structure_unauthorized_resource_access_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateCustomMetadataError::unhandled)?;
                                output.build()
                            };
                            if (&tmp.message).is_none() {
                                tmp.message = _error_message;
                            }
                            tmp
                        },
                    ),
            }
        }
        _ => crate::error::CreateCustomMetadataError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_custom_metadata_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateCustomMetadataOutput,
    crate::error::CreateCustomMetadataError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_custom_metadata_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_folder_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateFolderOutput, crate::error::CreateFolderError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateFolderError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateFolderError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ConflictingOperationException" => {
            crate::error::CreateFolderError {
                meta: generic,
                kind: crate::error::CreateFolderErrorKind::ConflictingOperationException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::conflicting_operation_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_conflicting_operation_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateFolderError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "EntityAlreadyExistsException" => {
            crate::error::CreateFolderError {
                meta: generic,
                kind: crate::error::CreateFolderErrorKind::EntityAlreadyExistsException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::entity_already_exists_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_entity_already_exists_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateFolderError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "EntityNotExistsException" => crate::error::CreateFolderError {
            meta: generic,
            kind: crate::error::CreateFolderErrorKind::EntityNotExistsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::entity_not_exists_exception::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_entity_not_exists_exceptionjson_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::CreateFolderError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "FailedDependencyException" => crate::error::CreateFolderError {
            meta: generic,
            kind: crate::error::CreateFolderErrorKind::FailedDependencyException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::failed_dependency_exception::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_failed_dependency_exceptionjson_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::CreateFolderError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceededException" => crate::error::CreateFolderError {
            meta: generic,
            kind: crate::error::CreateFolderErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_limit_exceeded_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateFolderError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ProhibitedStateException" => crate::error::CreateFolderError {
            meta: generic,
            kind: crate::error::CreateFolderErrorKind::ProhibitedStateException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::prohibited_state_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_prohibited_state_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateFolderError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceUnavailableException" => {
            crate::error::CreateFolderError {
                meta: generic,
                kind: crate::error::CreateFolderErrorKind::ServiceUnavailableException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::service_unavailable_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_service_unavailable_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateFolderError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "UnauthorizedOperationException" => crate::error::CreateFolderError {
            meta: generic,
            kind: crate::error::CreateFolderErrorKind::UnauthorizedOperationException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::unauthorized_operation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_unauthorized_operation_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateFolderError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "UnauthorizedResourceAccessException" => crate::error::CreateFolderError {
            meta: generic,
            kind: crate::error::CreateFolderErrorKind::UnauthorizedResourceAccessException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::unauthorized_resource_access_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_unauthorized_resource_access_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateFolderError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::CreateFolderError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_folder_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateFolderOutput, crate::error::CreateFolderError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_folder_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_create_folder(response.body().as_ref(), output)
            .map_err(crate::error::CreateFolderError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_labels_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateLabelsOutput, crate::error::CreateLabelsError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateLabelsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateLabelsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "EntityNotExistsException" => crate::error::CreateLabelsError {
            meta: generic,
            kind: crate::error::CreateLabelsErrorKind::EntityNotExistsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::entity_not_exists_exception::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_entity_not_exists_exceptionjson_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::CreateLabelsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "FailedDependencyException" => crate::error::CreateLabelsError {
            meta: generic,
            kind: crate::error::CreateLabelsErrorKind::FailedDependencyException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::failed_dependency_exception::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_failed_dependency_exceptionjson_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::CreateLabelsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceUnavailableException" => {
            crate::error::CreateLabelsError {
                meta: generic,
                kind: crate::error::CreateLabelsErrorKind::ServiceUnavailableException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::service_unavailable_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_service_unavailable_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateLabelsError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "TooManyLabelsException" => crate::error::CreateLabelsError {
            meta: generic,
            kind: crate::error::CreateLabelsErrorKind::TooManyLabelsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_labels_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_too_many_labels_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateLabelsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "UnauthorizedOperationException" => crate::error::CreateLabelsError {
            meta: generic,
            kind: crate::error::CreateLabelsErrorKind::UnauthorizedOperationException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::unauthorized_operation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_unauthorized_operation_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateLabelsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "UnauthorizedResourceAccessException" => crate::error::CreateLabelsError {
            meta: generic,
            kind: crate::error::CreateLabelsErrorKind::UnauthorizedResourceAccessException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::unauthorized_resource_access_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_unauthorized_resource_access_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateLabelsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::CreateLabelsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_labels_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateLabelsOutput, crate::error::CreateLabelsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_labels_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_notification_subscription_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateNotificationSubscriptionOutput,
    crate::error::CreateNotificationSubscriptionError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateNotificationSubscriptionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateNotificationSubscriptionError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ServiceUnavailableException" => crate::error::CreateNotificationSubscriptionError { meta: generic, kind: crate::error::CreateNotificationSubscriptionErrorKind::ServiceUnavailableException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::service_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_service_unavailable_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateNotificationSubscriptionError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "TooManySubscriptionsException" => crate::error::CreateNotificationSubscriptionError { meta: generic, kind: crate::error::CreateNotificationSubscriptionErrorKind::TooManySubscriptionsException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::too_many_subscriptions_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_too_many_subscriptions_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateNotificationSubscriptionError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedResourceAccessException" => crate::error::CreateNotificationSubscriptionError { meta: generic, kind: crate::error::CreateNotificationSubscriptionErrorKind::UnauthorizedResourceAccessException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::unauthorized_resource_access_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_unauthorized_resource_access_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateNotificationSubscriptionError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::CreateNotificationSubscriptionError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_notification_subscription_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateNotificationSubscriptionOutput,
    crate::error::CreateNotificationSubscriptionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_notification_subscription_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_create_notification_subscription(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateNotificationSubscriptionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_user_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateUserOutput, crate::error::CreateUserError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateUserError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateUserError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "EntityAlreadyExistsException" => {
            crate::error::CreateUserError {
                meta: generic,
                kind: crate::error::CreateUserErrorKind::EntityAlreadyExistsException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::entity_already_exists_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_entity_already_exists_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateUserError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "FailedDependencyException" => crate::error::CreateUserError {
            meta: generic,
            kind: crate::error::CreateUserErrorKind::FailedDependencyException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::failed_dependency_exception::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_failed_dependency_exceptionjson_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::CreateUserError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceUnavailableException" => {
            crate::error::CreateUserError {
                meta: generic,
                kind: crate::error::CreateUserErrorKind::ServiceUnavailableException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::service_unavailable_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_service_unavailable_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateUserError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "UnauthorizedOperationException" => crate::error::CreateUserError {
            meta: generic,
            kind: crate::error::CreateUserErrorKind::UnauthorizedOperationException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::unauthorized_operation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_unauthorized_operation_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateUserError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "UnauthorizedResourceAccessException" => crate::error::CreateUserError {
            meta: generic,
            kind: crate::error::CreateUserErrorKind::UnauthorizedResourceAccessException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::unauthorized_resource_access_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_unauthorized_resource_access_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateUserError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::CreateUserError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_user_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateUserOutput, crate::error::CreateUserError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_user_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_create_user(response.body().as_ref(), output)
            .map_err(crate::error::CreateUserError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_deactivate_user_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeactivateUserOutput, crate::error::DeactivateUserError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DeactivateUserError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeactivateUserError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "EntityNotExistsException" => crate::error::DeactivateUserError {
            meta: generic,
            kind: crate::error::DeactivateUserErrorKind::EntityNotExistsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::entity_not_exists_exception::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_entity_not_exists_exceptionjson_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::DeactivateUserError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "FailedDependencyException" => crate::error::DeactivateUserError {
            meta: generic,
            kind: crate::error::DeactivateUserErrorKind::FailedDependencyException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::failed_dependency_exception::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_failed_dependency_exceptionjson_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::DeactivateUserError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceUnavailableException" => {
            crate::error::DeactivateUserError {
                meta: generic,
                kind: crate::error::DeactivateUserErrorKind::ServiceUnavailableException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::service_unavailable_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_service_unavailable_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeactivateUserError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "UnauthorizedOperationException" => crate::error::DeactivateUserError {
            meta: generic,
            kind: crate::error::DeactivateUserErrorKind::UnauthorizedOperationException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::unauthorized_operation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_unauthorized_operation_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeactivateUserError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "UnauthorizedResourceAccessException" => crate::error::DeactivateUserError {
            meta: generic,
            kind: crate::error::DeactivateUserErrorKind::UnauthorizedResourceAccessException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::unauthorized_resource_access_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_unauthorized_resource_access_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeactivateUserError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeactivateUserError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_deactivate_user_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeactivateUserOutput, crate::error::DeactivateUserError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::deactivate_user_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_comment_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteCommentOutput, crate::error::DeleteCommentError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteCommentError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteCommentError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DocumentLockedForCommentsException" => crate::error::DeleteCommentError {
            meta: generic,
            kind: crate::error::DeleteCommentErrorKind::DocumentLockedForCommentsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::document_locked_for_comments_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_document_locked_for_comments_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeleteCommentError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EntityNotExistsException" => crate::error::DeleteCommentError {
            meta: generic,
            kind: crate::error::DeleteCommentErrorKind::EntityNotExistsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::entity_not_exists_exception::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_entity_not_exists_exceptionjson_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::DeleteCommentError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "FailedDependencyException" => crate::error::DeleteCommentError {
            meta: generic,
            kind: crate::error::DeleteCommentErrorKind::FailedDependencyException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::failed_dependency_exception::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_failed_dependency_exceptionjson_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::DeleteCommentError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ProhibitedStateException" => crate::error::DeleteCommentError {
            meta: generic,
            kind: crate::error::DeleteCommentErrorKind::ProhibitedStateException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::prohibited_state_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_prohibited_state_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteCommentError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceUnavailableException" => {
            crate::error::DeleteCommentError {
                meta: generic,
                kind: crate::error::DeleteCommentErrorKind::ServiceUnavailableException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::service_unavailable_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_service_unavailable_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeleteCommentError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "UnauthorizedOperationException" => crate::error::DeleteCommentError {
            meta: generic,
            kind: crate::error::DeleteCommentErrorKind::UnauthorizedOperationException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::unauthorized_operation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_unauthorized_operation_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeleteCommentError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "UnauthorizedResourceAccessException" => crate::error::DeleteCommentError {
            meta: generic,
            kind: crate::error::DeleteCommentErrorKind::UnauthorizedResourceAccessException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::unauthorized_resource_access_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_unauthorized_resource_access_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeleteCommentError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeleteCommentError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_comment_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteCommentOutput, crate::error::DeleteCommentError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_comment_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_custom_metadata_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteCustomMetadataOutput,
    crate::error::DeleteCustomMetadataError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteCustomMetadataError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteCustomMetadataError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "EntityNotExistsException" => crate::error::DeleteCustomMetadataError {
            meta: generic,
            kind: crate::error::DeleteCustomMetadataErrorKind::EntityNotExistsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::entity_not_exists_exception::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_entity_not_exists_exceptionjson_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::DeleteCustomMetadataError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "FailedDependencyException" => crate::error::DeleteCustomMetadataError {
            meta: generic,
            kind: crate::error::DeleteCustomMetadataErrorKind::FailedDependencyException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::failed_dependency_exception::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_failed_dependency_exceptionjson_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::DeleteCustomMetadataError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ProhibitedStateException" => crate::error::DeleteCustomMetadataError {
            meta: generic,
            kind: crate::error::DeleteCustomMetadataErrorKind::ProhibitedStateException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::prohibited_state_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_prohibited_state_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteCustomMetadataError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceUnavailableException" => {
            crate::error::DeleteCustomMetadataError {
                meta: generic,
                kind: crate::error::DeleteCustomMetadataErrorKind::ServiceUnavailableException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::service_unavailable_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_service_unavailable_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeleteCustomMetadataError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "UnauthorizedOperationException" => crate::error::DeleteCustomMetadataError {
            meta: generic,
            kind: crate::error::DeleteCustomMetadataErrorKind::UnauthorizedOperationException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::unauthorized_operation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_unauthorized_operation_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeleteCustomMetadataError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "UnauthorizedResourceAccessException" => {
            crate::error::DeleteCustomMetadataError {
                meta: generic,
                kind:
                    crate::error::DeleteCustomMetadataErrorKind::UnauthorizedResourceAccessException(
                        {
                            #[allow(unused_mut)]
                            let mut tmp = {
                                #[allow(unused_mut)]let mut output = crate::error::unauthorized_resource_access_exception::Builder::default();
                                let _ = response;
                                output = crate::json_deser::deser_structure_unauthorized_resource_access_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeleteCustomMetadataError::unhandled)?;
                                output.build()
                            };
                            if (&tmp.message).is_none() {
                                tmp.message = _error_message;
                            }
                            tmp
                        },
                    ),
            }
        }
        _ => crate::error::DeleteCustomMetadataError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_custom_metadata_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteCustomMetadataOutput,
    crate::error::DeleteCustomMetadataError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_custom_metadata_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_document_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteDocumentOutput, crate::error::DeleteDocumentError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteDocumentError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteDocumentError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ConcurrentModificationException" => crate::error::DeleteDocumentError {
            meta: generic,
            kind: crate::error::DeleteDocumentErrorKind::ConcurrentModificationException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::concurrent_modification_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_concurrent_modification_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeleteDocumentError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ConflictingOperationException" => {
            crate::error::DeleteDocumentError {
                meta: generic,
                kind: crate::error::DeleteDocumentErrorKind::ConflictingOperationException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::conflicting_operation_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_conflicting_operation_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeleteDocumentError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "EntityNotExistsException" => crate::error::DeleteDocumentError {
            meta: generic,
            kind: crate::error::DeleteDocumentErrorKind::EntityNotExistsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::entity_not_exists_exception::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_entity_not_exists_exceptionjson_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::DeleteDocumentError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "FailedDependencyException" => crate::error::DeleteDocumentError {
            meta: generic,
            kind: crate::error::DeleteDocumentErrorKind::FailedDependencyException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::failed_dependency_exception::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_failed_dependency_exceptionjson_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::DeleteDocumentError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ProhibitedStateException" => crate::error::DeleteDocumentError {
            meta: generic,
            kind: crate::error::DeleteDocumentErrorKind::ProhibitedStateException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::prohibited_state_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_prohibited_state_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteDocumentError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceUnavailableException" => {
            crate::error::DeleteDocumentError {
                meta: generic,
                kind: crate::error::DeleteDocumentErrorKind::ServiceUnavailableException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::service_unavailable_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_service_unavailable_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeleteDocumentError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "UnauthorizedOperationException" => crate::error::DeleteDocumentError {
            meta: generic,
            kind: crate::error::DeleteDocumentErrorKind::UnauthorizedOperationException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::unauthorized_operation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_unauthorized_operation_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeleteDocumentError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "UnauthorizedResourceAccessException" => crate::error::DeleteDocumentError {
            meta: generic,
            kind: crate::error::DeleteDocumentErrorKind::UnauthorizedResourceAccessException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::unauthorized_resource_access_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_unauthorized_resource_access_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeleteDocumentError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeleteDocumentError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_document_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteDocumentOutput, crate::error::DeleteDocumentError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_document_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_folder_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteFolderOutput, crate::error::DeleteFolderError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteFolderError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteFolderError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ConcurrentModificationException" => crate::error::DeleteFolderError {
            meta: generic,
            kind: crate::error::DeleteFolderErrorKind::ConcurrentModificationException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::concurrent_modification_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_concurrent_modification_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeleteFolderError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ConflictingOperationException" => {
            crate::error::DeleteFolderError {
                meta: generic,
                kind: crate::error::DeleteFolderErrorKind::ConflictingOperationException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::conflicting_operation_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_conflicting_operation_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeleteFolderError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "EntityNotExistsException" => crate::error::DeleteFolderError {
            meta: generic,
            kind: crate::error::DeleteFolderErrorKind::EntityNotExistsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::entity_not_exists_exception::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_entity_not_exists_exceptionjson_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::DeleteFolderError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "FailedDependencyException" => crate::error::DeleteFolderError {
            meta: generic,
            kind: crate::error::DeleteFolderErrorKind::FailedDependencyException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::failed_dependency_exception::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_failed_dependency_exceptionjson_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::DeleteFolderError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ProhibitedStateException" => crate::error::DeleteFolderError {
            meta: generic,
            kind: crate::error::DeleteFolderErrorKind::ProhibitedStateException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::prohibited_state_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_prohibited_state_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteFolderError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceUnavailableException" => {
            crate::error::DeleteFolderError {
                meta: generic,
                kind: crate::error::DeleteFolderErrorKind::ServiceUnavailableException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::service_unavailable_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_service_unavailable_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeleteFolderError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "UnauthorizedOperationException" => crate::error::DeleteFolderError {
            meta: generic,
            kind: crate::error::DeleteFolderErrorKind::UnauthorizedOperationException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::unauthorized_operation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_unauthorized_operation_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeleteFolderError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "UnauthorizedResourceAccessException" => crate::error::DeleteFolderError {
            meta: generic,
            kind: crate::error::DeleteFolderErrorKind::UnauthorizedResourceAccessException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::unauthorized_resource_access_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_unauthorized_resource_access_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeleteFolderError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeleteFolderError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_folder_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteFolderOutput, crate::error::DeleteFolderError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_folder_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_folder_contents_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteFolderContentsOutput,
    crate::error::DeleteFolderContentsError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteFolderContentsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteFolderContentsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ConflictingOperationException" => {
            crate::error::DeleteFolderContentsError {
                meta: generic,
                kind: crate::error::DeleteFolderContentsErrorKind::ConflictingOperationException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::conflicting_operation_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_conflicting_operation_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeleteFolderContentsError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "EntityNotExistsException" => crate::error::DeleteFolderContentsError {
            meta: generic,
            kind: crate::error::DeleteFolderContentsErrorKind::EntityNotExistsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::entity_not_exists_exception::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_entity_not_exists_exceptionjson_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::DeleteFolderContentsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "FailedDependencyException" => crate::error::DeleteFolderContentsError {
            meta: generic,
            kind: crate::error::DeleteFolderContentsErrorKind::FailedDependencyException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::failed_dependency_exception::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_failed_dependency_exceptionjson_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::DeleteFolderContentsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ProhibitedStateException" => crate::error::DeleteFolderContentsError {
            meta: generic,
            kind: crate::error::DeleteFolderContentsErrorKind::ProhibitedStateException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::prohibited_state_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_prohibited_state_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteFolderContentsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceUnavailableException" => {
            crate::error::DeleteFolderContentsError {
                meta: generic,
                kind: crate::error::DeleteFolderContentsErrorKind::ServiceUnavailableException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::service_unavailable_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_service_unavailable_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeleteFolderContentsError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "UnauthorizedOperationException" => crate::error::DeleteFolderContentsError {
            meta: generic,
            kind: crate::error::DeleteFolderContentsErrorKind::UnauthorizedOperationException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::unauthorized_operation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_unauthorized_operation_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeleteFolderContentsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "UnauthorizedResourceAccessException" => {
            crate::error::DeleteFolderContentsError {
                meta: generic,
                kind:
                    crate::error::DeleteFolderContentsErrorKind::UnauthorizedResourceAccessException(
                        {
                            #[allow(unused_mut)]
                            let mut tmp = {
                                #[allow(unused_mut)]let mut output = crate::error::unauthorized_resource_access_exception::Builder::default();
                                let _ = response;
                                output = crate::json_deser::deser_structure_unauthorized_resource_access_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeleteFolderContentsError::unhandled)?;
                                output.build()
                            };
                            if (&tmp.message).is_none() {
                                tmp.message = _error_message;
                            }
                            tmp
                        },
                    ),
            }
        }
        _ => crate::error::DeleteFolderContentsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_folder_contents_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteFolderContentsOutput,
    crate::error::DeleteFolderContentsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_folder_contents_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_labels_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteLabelsOutput, crate::error::DeleteLabelsError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteLabelsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteLabelsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "EntityNotExistsException" => crate::error::DeleteLabelsError {
            meta: generic,
            kind: crate::error::DeleteLabelsErrorKind::EntityNotExistsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::entity_not_exists_exception::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_entity_not_exists_exceptionjson_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::DeleteLabelsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "FailedDependencyException" => crate::error::DeleteLabelsError {
            meta: generic,
            kind: crate::error::DeleteLabelsErrorKind::FailedDependencyException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::failed_dependency_exception::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_failed_dependency_exceptionjson_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::DeleteLabelsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceUnavailableException" => {
            crate::error::DeleteLabelsError {
                meta: generic,
                kind: crate::error::DeleteLabelsErrorKind::ServiceUnavailableException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::service_unavailable_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_service_unavailable_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeleteLabelsError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "UnauthorizedOperationException" => crate::error::DeleteLabelsError {
            meta: generic,
            kind: crate::error::DeleteLabelsErrorKind::UnauthorizedOperationException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::unauthorized_operation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_unauthorized_operation_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeleteLabelsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "UnauthorizedResourceAccessException" => crate::error::DeleteLabelsError {
            meta: generic,
            kind: crate::error::DeleteLabelsErrorKind::UnauthorizedResourceAccessException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::unauthorized_resource_access_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_unauthorized_resource_access_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeleteLabelsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeleteLabelsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_labels_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteLabelsOutput, crate::error::DeleteLabelsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_labels_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_notification_subscription_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteNotificationSubscriptionOutput,
    crate::error::DeleteNotificationSubscriptionError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteNotificationSubscriptionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteNotificationSubscriptionError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "EntityNotExistsException" => crate::error::DeleteNotificationSubscriptionError { meta: generic, kind: crate::error::DeleteNotificationSubscriptionErrorKind::EntityNotExistsException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::entity_not_exists_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_entity_not_exists_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeleteNotificationSubscriptionError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ProhibitedStateException" => crate::error::DeleteNotificationSubscriptionError { meta: generic, kind: crate::error::DeleteNotificationSubscriptionErrorKind::ProhibitedStateException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::prohibited_state_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_prohibited_state_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeleteNotificationSubscriptionError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ServiceUnavailableException" => crate::error::DeleteNotificationSubscriptionError { meta: generic, kind: crate::error::DeleteNotificationSubscriptionErrorKind::ServiceUnavailableException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::service_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_service_unavailable_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeleteNotificationSubscriptionError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedResourceAccessException" => crate::error::DeleteNotificationSubscriptionError { meta: generic, kind: crate::error::DeleteNotificationSubscriptionErrorKind::UnauthorizedResourceAccessException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::unauthorized_resource_access_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_unauthorized_resource_access_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeleteNotificationSubscriptionError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DeleteNotificationSubscriptionError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_notification_subscription_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteNotificationSubscriptionOutput,
    crate::error::DeleteNotificationSubscriptionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_notification_subscription_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_user_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteUserOutput, crate::error::DeleteUserError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteUserError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteUserError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "EntityNotExistsException" => crate::error::DeleteUserError {
            meta: generic,
            kind: crate::error::DeleteUserErrorKind::EntityNotExistsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::entity_not_exists_exception::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_entity_not_exists_exceptionjson_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::DeleteUserError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "FailedDependencyException" => crate::error::DeleteUserError {
            meta: generic,
            kind: crate::error::DeleteUserErrorKind::FailedDependencyException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::failed_dependency_exception::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_failed_dependency_exceptionjson_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::DeleteUserError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceUnavailableException" => {
            crate::error::DeleteUserError {
                meta: generic,
                kind: crate::error::DeleteUserErrorKind::ServiceUnavailableException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::service_unavailable_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_service_unavailable_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeleteUserError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "UnauthorizedOperationException" => crate::error::DeleteUserError {
            meta: generic,
            kind: crate::error::DeleteUserErrorKind::UnauthorizedOperationException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::unauthorized_operation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_unauthorized_operation_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeleteUserError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "UnauthorizedResourceAccessException" => crate::error::DeleteUserError {
            meta: generic,
            kind: crate::error::DeleteUserErrorKind::UnauthorizedResourceAccessException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::unauthorized_resource_access_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_unauthorized_resource_access_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeleteUserError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeleteUserError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_user_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteUserOutput, crate::error::DeleteUserError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_user_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_activities_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeActivitiesOutput,
    crate::error::DescribeActivitiesError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DescribeActivitiesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeActivitiesError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "FailedDependencyException" => crate::error::DescribeActivitiesError {
            meta: generic,
            kind: crate::error::DescribeActivitiesErrorKind::FailedDependencyException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::failed_dependency_exception::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_failed_dependency_exceptionjson_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::DescribeActivitiesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidArgumentException" => crate::error::DescribeActivitiesError {
            meta: generic,
            kind: crate::error::DescribeActivitiesErrorKind::InvalidArgumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_argument_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_argument_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DescribeActivitiesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceUnavailableException" => {
            crate::error::DescribeActivitiesError {
                meta: generic,
                kind: crate::error::DescribeActivitiesErrorKind::ServiceUnavailableException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::service_unavailable_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_service_unavailable_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DescribeActivitiesError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "UnauthorizedOperationException" => crate::error::DescribeActivitiesError {
            meta: generic,
            kind: crate::error::DescribeActivitiesErrorKind::UnauthorizedOperationException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::unauthorized_operation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_unauthorized_operation_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DescribeActivitiesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "UnauthorizedResourceAccessException" => crate::error::DescribeActivitiesError {
            meta: generic,
            kind: crate::error::DescribeActivitiesErrorKind::UnauthorizedResourceAccessException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::unauthorized_resource_access_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_unauthorized_resource_access_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DescribeActivitiesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DescribeActivitiesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_activities_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeActivitiesOutput,
    crate::error::DescribeActivitiesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_activities_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_describe_activities(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeActivitiesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_comments_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeCommentsOutput, crate::error::DescribeCommentsError>
{
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DescribeCommentsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeCommentsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "EntityNotExistsException" => crate::error::DescribeCommentsError {
            meta: generic,
            kind: crate::error::DescribeCommentsErrorKind::EntityNotExistsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::entity_not_exists_exception::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_entity_not_exists_exceptionjson_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::DescribeCommentsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "FailedDependencyException" => crate::error::DescribeCommentsError {
            meta: generic,
            kind: crate::error::DescribeCommentsErrorKind::FailedDependencyException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::failed_dependency_exception::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_failed_dependency_exceptionjson_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::DescribeCommentsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ProhibitedStateException" => crate::error::DescribeCommentsError {
            meta: generic,
            kind: crate::error::DescribeCommentsErrorKind::ProhibitedStateException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::prohibited_state_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_prohibited_state_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DescribeCommentsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceUnavailableException" => {
            crate::error::DescribeCommentsError {
                meta: generic,
                kind: crate::error::DescribeCommentsErrorKind::ServiceUnavailableException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::service_unavailable_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_service_unavailable_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DescribeCommentsError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "UnauthorizedOperationException" => crate::error::DescribeCommentsError {
            meta: generic,
            kind: crate::error::DescribeCommentsErrorKind::UnauthorizedOperationException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::unauthorized_operation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_unauthorized_operation_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DescribeCommentsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "UnauthorizedResourceAccessException" => crate::error::DescribeCommentsError {
            meta: generic,
            kind: crate::error::DescribeCommentsErrorKind::UnauthorizedResourceAccessException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::unauthorized_resource_access_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_unauthorized_resource_access_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DescribeCommentsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DescribeCommentsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_comments_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeCommentsOutput, crate::error::DescribeCommentsError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_comments_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_describe_comments(response.body().as_ref(), output)
                .map_err(crate::error::DescribeCommentsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_document_versions_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDocumentVersionsOutput,
    crate::error::DescribeDocumentVersionsError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DescribeDocumentVersionsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeDocumentVersionsError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "EntityNotExistsException" => crate::error::DescribeDocumentVersionsError {
            meta: generic,
            kind: crate::error::DescribeDocumentVersionsErrorKind::EntityNotExistsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::entity_not_exists_exception::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_entity_not_exists_exceptionjson_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::DescribeDocumentVersionsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "FailedDependencyException" => crate::error::DescribeDocumentVersionsError {
            meta: generic,
            kind: crate::error::DescribeDocumentVersionsErrorKind::FailedDependencyException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::failed_dependency_exception::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_failed_dependency_exceptionjson_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::DescribeDocumentVersionsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidArgumentException" => crate::error::DescribeDocumentVersionsError {
            meta: generic,
            kind: crate::error::DescribeDocumentVersionsErrorKind::InvalidArgumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_argument_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_argument_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DescribeDocumentVersionsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ProhibitedStateException" => crate::error::DescribeDocumentVersionsError {
            meta: generic,
            kind: crate::error::DescribeDocumentVersionsErrorKind::ProhibitedStateException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::prohibited_state_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_prohibited_state_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DescribeDocumentVersionsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceUnavailableException" => {
            crate::error::DescribeDocumentVersionsError {
                meta: generic,
                kind: crate::error::DescribeDocumentVersionsErrorKind::ServiceUnavailableException(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::service_unavailable_exception::Builder::default();
                            let _ = response;
                            output = crate::json_deser::deser_structure_service_unavailable_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DescribeDocumentVersionsError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
            }
        }
        "UnauthorizedOperationException" => crate::error::DescribeDocumentVersionsError {
            meta: generic,
            kind: crate::error::DescribeDocumentVersionsErrorKind::UnauthorizedOperationException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::unauthorized_operation_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_unauthorized_operation_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DescribeDocumentVersionsError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "UnauthorizedResourceAccessException" => crate::error::DescribeDocumentVersionsError {
            meta: generic,
            kind:
                crate::error::DescribeDocumentVersionsErrorKind::UnauthorizedResourceAccessException(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]let mut output = crate::error::unauthorized_resource_access_exception::Builder::default();
                            let _ = response;
                            output = crate::json_deser::deser_structure_unauthorized_resource_access_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DescribeDocumentVersionsError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        _ => crate::error::DescribeDocumentVersionsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_document_versions_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDocumentVersionsOutput,
    crate::error::DescribeDocumentVersionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_document_versions_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_describe_document_versions(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeDocumentVersionsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_folder_contents_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeFolderContentsOutput,
    crate::error::DescribeFolderContentsError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DescribeFolderContentsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeFolderContentsError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "EntityNotExistsException" => crate::error::DescribeFolderContentsError {
            meta: generic,
            kind: crate::error::DescribeFolderContentsErrorKind::EntityNotExistsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::entity_not_exists_exception::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_entity_not_exists_exceptionjson_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::DescribeFolderContentsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "FailedDependencyException" => crate::error::DescribeFolderContentsError {
            meta: generic,
            kind: crate::error::DescribeFolderContentsErrorKind::FailedDependencyException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::failed_dependency_exception::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_failed_dependency_exceptionjson_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::DescribeFolderContentsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidArgumentException" => crate::error::DescribeFolderContentsError {
            meta: generic,
            kind: crate::error::DescribeFolderContentsErrorKind::InvalidArgumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_argument_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_argument_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DescribeFolderContentsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ProhibitedStateException" => crate::error::DescribeFolderContentsError {
            meta: generic,
            kind: crate::error::DescribeFolderContentsErrorKind::ProhibitedStateException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::prohibited_state_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_prohibited_state_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DescribeFolderContentsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceUnavailableException" => {
            crate::error::DescribeFolderContentsError {
                meta: generic,
                kind: crate::error::DescribeFolderContentsErrorKind::ServiceUnavailableException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::service_unavailable_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_service_unavailable_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DescribeFolderContentsError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "UnauthorizedResourceAccessException" => crate::error::DescribeFolderContentsError {
            meta: generic,
            kind:
                crate::error::DescribeFolderContentsErrorKind::UnauthorizedResourceAccessException(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]let mut output = crate::error::unauthorized_resource_access_exception::Builder::default();
                            let _ = response;
                            output = crate::json_deser::deser_structure_unauthorized_resource_access_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DescribeFolderContentsError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        _ => crate::error::DescribeFolderContentsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_folder_contents_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeFolderContentsOutput,
    crate::error::DescribeFolderContentsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_folder_contents_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_describe_folder_contents(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeFolderContentsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_groups_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeGroupsOutput, crate::error::DescribeGroupsError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DescribeGroupsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeGroupsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "FailedDependencyException" => crate::error::DescribeGroupsError {
            meta: generic,
            kind: crate::error::DescribeGroupsErrorKind::FailedDependencyException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::failed_dependency_exception::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_failed_dependency_exceptionjson_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::DescribeGroupsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceUnavailableException" => {
            crate::error::DescribeGroupsError {
                meta: generic,
                kind: crate::error::DescribeGroupsErrorKind::ServiceUnavailableException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::service_unavailable_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_service_unavailable_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DescribeGroupsError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "UnauthorizedOperationException" => crate::error::DescribeGroupsError {
            meta: generic,
            kind: crate::error::DescribeGroupsErrorKind::UnauthorizedOperationException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::unauthorized_operation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_unauthorized_operation_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DescribeGroupsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "UnauthorizedResourceAccessException" => crate::error::DescribeGroupsError {
            meta: generic,
            kind: crate::error::DescribeGroupsErrorKind::UnauthorizedResourceAccessException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::unauthorized_resource_access_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_unauthorized_resource_access_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DescribeGroupsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DescribeGroupsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_groups_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeGroupsOutput, crate::error::DescribeGroupsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_groups_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_describe_groups(response.body().as_ref(), output)
                .map_err(crate::error::DescribeGroupsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_notification_subscriptions_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeNotificationSubscriptionsOutput,
    crate::error::DescribeNotificationSubscriptionsError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DescribeNotificationSubscriptionsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeNotificationSubscriptionsError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "EntityNotExistsException" => crate::error::DescribeNotificationSubscriptionsError { meta: generic, kind: crate::error::DescribeNotificationSubscriptionsErrorKind::EntityNotExistsException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::entity_not_exists_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_entity_not_exists_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DescribeNotificationSubscriptionsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ServiceUnavailableException" => crate::error::DescribeNotificationSubscriptionsError { meta: generic, kind: crate::error::DescribeNotificationSubscriptionsErrorKind::ServiceUnavailableException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::service_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_service_unavailable_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DescribeNotificationSubscriptionsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedResourceAccessException" => crate::error::DescribeNotificationSubscriptionsError { meta: generic, kind: crate::error::DescribeNotificationSubscriptionsErrorKind::UnauthorizedResourceAccessException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::unauthorized_resource_access_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_unauthorized_resource_access_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DescribeNotificationSubscriptionsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribeNotificationSubscriptionsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_notification_subscriptions_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeNotificationSubscriptionsOutput,
    crate::error::DescribeNotificationSubscriptionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_notification_subscriptions_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_describe_notification_subscriptions(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeNotificationSubscriptionsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_resource_permissions_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeResourcePermissionsOutput,
    crate::error::DescribeResourcePermissionsError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DescribeResourcePermissionsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeResourcePermissionsError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "FailedDependencyException" => crate::error::DescribeResourcePermissionsError { meta: generic, kind: crate::error::DescribeResourcePermissionsErrorKind::FailedDependencyException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::failed_dependency_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_failed_dependency_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DescribeResourcePermissionsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ServiceUnavailableException" => crate::error::DescribeResourcePermissionsError { meta: generic, kind: crate::error::DescribeResourcePermissionsErrorKind::ServiceUnavailableException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::service_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_service_unavailable_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DescribeResourcePermissionsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedOperationException" => crate::error::DescribeResourcePermissionsError { meta: generic, kind: crate::error::DescribeResourcePermissionsErrorKind::UnauthorizedOperationException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::unauthorized_operation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_unauthorized_operation_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DescribeResourcePermissionsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedResourceAccessException" => crate::error::DescribeResourcePermissionsError { meta: generic, kind: crate::error::DescribeResourcePermissionsErrorKind::UnauthorizedResourceAccessException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::unauthorized_resource_access_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_unauthorized_resource_access_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DescribeResourcePermissionsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribeResourcePermissionsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_resource_permissions_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeResourcePermissionsOutput,
    crate::error::DescribeResourcePermissionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_resource_permissions_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_describe_resource_permissions(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeResourcePermissionsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_root_folders_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeRootFoldersOutput,
    crate::error::DescribeRootFoldersError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DescribeRootFoldersError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeRootFoldersError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "FailedDependencyException" => crate::error::DescribeRootFoldersError {
            meta: generic,
            kind: crate::error::DescribeRootFoldersErrorKind::FailedDependencyException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::failed_dependency_exception::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_failed_dependency_exceptionjson_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::DescribeRootFoldersError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidArgumentException" => crate::error::DescribeRootFoldersError {
            meta: generic,
            kind: crate::error::DescribeRootFoldersErrorKind::InvalidArgumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_argument_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_argument_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DescribeRootFoldersError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceUnavailableException" => {
            crate::error::DescribeRootFoldersError {
                meta: generic,
                kind: crate::error::DescribeRootFoldersErrorKind::ServiceUnavailableException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::service_unavailable_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_service_unavailable_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DescribeRootFoldersError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "UnauthorizedOperationException" => crate::error::DescribeRootFoldersError {
            meta: generic,
            kind: crate::error::DescribeRootFoldersErrorKind::UnauthorizedOperationException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::unauthorized_operation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_unauthorized_operation_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DescribeRootFoldersError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "UnauthorizedResourceAccessException" => {
            crate::error::DescribeRootFoldersError {
                meta: generic,
                kind:
                    crate::error::DescribeRootFoldersErrorKind::UnauthorizedResourceAccessException(
                        {
                            #[allow(unused_mut)]
                            let mut tmp = {
                                #[allow(unused_mut)]let mut output = crate::error::unauthorized_resource_access_exception::Builder::default();
                                let _ = response;
                                output = crate::json_deser::deser_structure_unauthorized_resource_access_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DescribeRootFoldersError::unhandled)?;
                                output.build()
                            };
                            if (&tmp.message).is_none() {
                                tmp.message = _error_message;
                            }
                            tmp
                        },
                    ),
            }
        }
        _ => crate::error::DescribeRootFoldersError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_root_folders_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeRootFoldersOutput,
    crate::error::DescribeRootFoldersError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_root_folders_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_describe_root_folders(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeRootFoldersError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_users_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeUsersOutput, crate::error::DescribeUsersError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DescribeUsersError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeUsersError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "EntityNotExistsException" => crate::error::DescribeUsersError {
            meta: generic,
            kind: crate::error::DescribeUsersErrorKind::EntityNotExistsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::entity_not_exists_exception::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_entity_not_exists_exceptionjson_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::DescribeUsersError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "FailedDependencyException" => crate::error::DescribeUsersError {
            meta: generic,
            kind: crate::error::DescribeUsersErrorKind::FailedDependencyException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::failed_dependency_exception::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_failed_dependency_exceptionjson_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::DescribeUsersError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidArgumentException" => crate::error::DescribeUsersError {
            meta: generic,
            kind: crate::error::DescribeUsersErrorKind::InvalidArgumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_argument_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_argument_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DescribeUsersError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "RequestedEntityTooLargeException" => crate::error::DescribeUsersError {
            meta: generic,
            kind: crate::error::DescribeUsersErrorKind::RequestedEntityTooLargeException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::requested_entity_too_large_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_requested_entity_too_large_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DescribeUsersError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceUnavailableException" => {
            crate::error::DescribeUsersError {
                meta: generic,
                kind: crate::error::DescribeUsersErrorKind::ServiceUnavailableException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::service_unavailable_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_service_unavailable_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DescribeUsersError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "UnauthorizedOperationException" => crate::error::DescribeUsersError {
            meta: generic,
            kind: crate::error::DescribeUsersErrorKind::UnauthorizedOperationException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::unauthorized_operation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_unauthorized_operation_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DescribeUsersError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "UnauthorizedResourceAccessException" => crate::error::DescribeUsersError {
            meta: generic,
            kind: crate::error::DescribeUsersErrorKind::UnauthorizedResourceAccessException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::unauthorized_resource_access_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_unauthorized_resource_access_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DescribeUsersError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DescribeUsersError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_users_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeUsersOutput, crate::error::DescribeUsersError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_users_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_describe_users(response.body().as_ref(), output)
                .map_err(crate::error::DescribeUsersError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_current_user_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetCurrentUserOutput, crate::error::GetCurrentUserError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetCurrentUserError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetCurrentUserError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "EntityNotExistsException" => crate::error::GetCurrentUserError {
            meta: generic,
            kind: crate::error::GetCurrentUserErrorKind::EntityNotExistsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::entity_not_exists_exception::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_entity_not_exists_exceptionjson_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::GetCurrentUserError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "FailedDependencyException" => crate::error::GetCurrentUserError {
            meta: generic,
            kind: crate::error::GetCurrentUserErrorKind::FailedDependencyException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::failed_dependency_exception::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_failed_dependency_exceptionjson_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::GetCurrentUserError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceUnavailableException" => {
            crate::error::GetCurrentUserError {
                meta: generic,
                kind: crate::error::GetCurrentUserErrorKind::ServiceUnavailableException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::service_unavailable_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_service_unavailable_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetCurrentUserError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "UnauthorizedOperationException" => crate::error::GetCurrentUserError {
            meta: generic,
            kind: crate::error::GetCurrentUserErrorKind::UnauthorizedOperationException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::unauthorized_operation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_unauthorized_operation_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetCurrentUserError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "UnauthorizedResourceAccessException" => crate::error::GetCurrentUserError {
            meta: generic,
            kind: crate::error::GetCurrentUserErrorKind::UnauthorizedResourceAccessException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::unauthorized_resource_access_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_unauthorized_resource_access_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetCurrentUserError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetCurrentUserError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_current_user_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetCurrentUserOutput, crate::error::GetCurrentUserError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_current_user_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_get_current_user(response.body().as_ref(), output)
                .map_err(crate::error::GetCurrentUserError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_document_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetDocumentOutput, crate::error::GetDocumentError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetDocumentError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetDocumentError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "EntityNotExistsException" => crate::error::GetDocumentError {
            meta: generic,
            kind: crate::error::GetDocumentErrorKind::EntityNotExistsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::entity_not_exists_exception::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_entity_not_exists_exceptionjson_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::GetDocumentError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "FailedDependencyException" => crate::error::GetDocumentError {
            meta: generic,
            kind: crate::error::GetDocumentErrorKind::FailedDependencyException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::failed_dependency_exception::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_failed_dependency_exceptionjson_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::GetDocumentError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidArgumentException" => crate::error::GetDocumentError {
            meta: generic,
            kind: crate::error::GetDocumentErrorKind::InvalidArgumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_argument_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_argument_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetDocumentError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidPasswordException" => crate::error::GetDocumentError {
            meta: generic,
            kind: crate::error::GetDocumentErrorKind::InvalidPasswordException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_password_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_password_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetDocumentError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceUnavailableException" => {
            crate::error::GetDocumentError {
                meta: generic,
                kind: crate::error::GetDocumentErrorKind::ServiceUnavailableException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::service_unavailable_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_service_unavailable_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetDocumentError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "UnauthorizedOperationException" => crate::error::GetDocumentError {
            meta: generic,
            kind: crate::error::GetDocumentErrorKind::UnauthorizedOperationException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::unauthorized_operation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_unauthorized_operation_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetDocumentError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "UnauthorizedResourceAccessException" => crate::error::GetDocumentError {
            meta: generic,
            kind: crate::error::GetDocumentErrorKind::UnauthorizedResourceAccessException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::unauthorized_resource_access_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_unauthorized_resource_access_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetDocumentError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetDocumentError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_document_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetDocumentOutput, crate::error::GetDocumentError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_document_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_get_document(response.body().as_ref(), output)
            .map_err(crate::error::GetDocumentError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_document_path_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetDocumentPathOutput, crate::error::GetDocumentPathError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetDocumentPathError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetDocumentPathError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "EntityNotExistsException" => crate::error::GetDocumentPathError {
            meta: generic,
            kind: crate::error::GetDocumentPathErrorKind::EntityNotExistsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::entity_not_exists_exception::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_entity_not_exists_exceptionjson_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::GetDocumentPathError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "FailedDependencyException" => crate::error::GetDocumentPathError {
            meta: generic,
            kind: crate::error::GetDocumentPathErrorKind::FailedDependencyException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::failed_dependency_exception::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_failed_dependency_exceptionjson_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::GetDocumentPathError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceUnavailableException" => {
            crate::error::GetDocumentPathError {
                meta: generic,
                kind: crate::error::GetDocumentPathErrorKind::ServiceUnavailableException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::service_unavailable_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_service_unavailable_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetDocumentPathError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "UnauthorizedOperationException" => crate::error::GetDocumentPathError {
            meta: generic,
            kind: crate::error::GetDocumentPathErrorKind::UnauthorizedOperationException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::unauthorized_operation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_unauthorized_operation_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetDocumentPathError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "UnauthorizedResourceAccessException" => crate::error::GetDocumentPathError {
            meta: generic,
            kind: crate::error::GetDocumentPathErrorKind::UnauthorizedResourceAccessException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::unauthorized_resource_access_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_unauthorized_resource_access_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetDocumentPathError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetDocumentPathError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_document_path_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetDocumentPathOutput, crate::error::GetDocumentPathError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_document_path_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_get_document_path(response.body().as_ref(), output)
                .map_err(crate::error::GetDocumentPathError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_document_version_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetDocumentVersionOutput,
    crate::error::GetDocumentVersionError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetDocumentVersionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetDocumentVersionError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "EntityNotExistsException" => crate::error::GetDocumentVersionError {
            meta: generic,
            kind: crate::error::GetDocumentVersionErrorKind::EntityNotExistsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::entity_not_exists_exception::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_entity_not_exists_exceptionjson_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::GetDocumentVersionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "FailedDependencyException" => crate::error::GetDocumentVersionError {
            meta: generic,
            kind: crate::error::GetDocumentVersionErrorKind::FailedDependencyException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::failed_dependency_exception::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_failed_dependency_exceptionjson_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::GetDocumentVersionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidPasswordException" => crate::error::GetDocumentVersionError {
            meta: generic,
            kind: crate::error::GetDocumentVersionErrorKind::InvalidPasswordException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_password_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_password_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetDocumentVersionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ProhibitedStateException" => crate::error::GetDocumentVersionError {
            meta: generic,
            kind: crate::error::GetDocumentVersionErrorKind::ProhibitedStateException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::prohibited_state_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_prohibited_state_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetDocumentVersionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceUnavailableException" => {
            crate::error::GetDocumentVersionError {
                meta: generic,
                kind: crate::error::GetDocumentVersionErrorKind::ServiceUnavailableException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::service_unavailable_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_service_unavailable_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetDocumentVersionError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "UnauthorizedOperationException" => crate::error::GetDocumentVersionError {
            meta: generic,
            kind: crate::error::GetDocumentVersionErrorKind::UnauthorizedOperationException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::unauthorized_operation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_unauthorized_operation_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetDocumentVersionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "UnauthorizedResourceAccessException" => crate::error::GetDocumentVersionError {
            meta: generic,
            kind: crate::error::GetDocumentVersionErrorKind::UnauthorizedResourceAccessException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::unauthorized_resource_access_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_unauthorized_resource_access_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetDocumentVersionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetDocumentVersionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_document_version_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetDocumentVersionOutput,
    crate::error::GetDocumentVersionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_document_version_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_get_document_version(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetDocumentVersionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_folder_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetFolderOutput, crate::error::GetFolderError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetFolderError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetFolderError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "EntityNotExistsException" => crate::error::GetFolderError {
            meta: generic,
            kind: crate::error::GetFolderErrorKind::EntityNotExistsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::entity_not_exists_exception::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_entity_not_exists_exceptionjson_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::GetFolderError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "FailedDependencyException" => crate::error::GetFolderError {
            meta: generic,
            kind: crate::error::GetFolderErrorKind::FailedDependencyException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::failed_dependency_exception::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_failed_dependency_exceptionjson_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::GetFolderError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidArgumentException" => crate::error::GetFolderError {
            meta: generic,
            kind: crate::error::GetFolderErrorKind::InvalidArgumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_argument_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_argument_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetFolderError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ProhibitedStateException" => crate::error::GetFolderError {
            meta: generic,
            kind: crate::error::GetFolderErrorKind::ProhibitedStateException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::prohibited_state_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_prohibited_state_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetFolderError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceUnavailableException" => {
            crate::error::GetFolderError {
                meta: generic,
                kind: crate::error::GetFolderErrorKind::ServiceUnavailableException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::service_unavailable_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_service_unavailable_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetFolderError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "UnauthorizedOperationException" => crate::error::GetFolderError {
            meta: generic,
            kind: crate::error::GetFolderErrorKind::UnauthorizedOperationException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::unauthorized_operation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_unauthorized_operation_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetFolderError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "UnauthorizedResourceAccessException" => crate::error::GetFolderError {
            meta: generic,
            kind: crate::error::GetFolderErrorKind::UnauthorizedResourceAccessException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::unauthorized_resource_access_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_unauthorized_resource_access_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetFolderError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetFolderError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_folder_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetFolderOutput, crate::error::GetFolderError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_folder_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_get_folder(response.body().as_ref(), output)
            .map_err(crate::error::GetFolderError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_folder_path_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetFolderPathOutput, crate::error::GetFolderPathError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetFolderPathError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetFolderPathError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "EntityNotExistsException" => crate::error::GetFolderPathError {
            meta: generic,
            kind: crate::error::GetFolderPathErrorKind::EntityNotExistsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::entity_not_exists_exception::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_entity_not_exists_exceptionjson_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::GetFolderPathError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "FailedDependencyException" => crate::error::GetFolderPathError {
            meta: generic,
            kind: crate::error::GetFolderPathErrorKind::FailedDependencyException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::failed_dependency_exception::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_failed_dependency_exceptionjson_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::GetFolderPathError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceUnavailableException" => {
            crate::error::GetFolderPathError {
                meta: generic,
                kind: crate::error::GetFolderPathErrorKind::ServiceUnavailableException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::service_unavailable_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_service_unavailable_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetFolderPathError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "UnauthorizedOperationException" => crate::error::GetFolderPathError {
            meta: generic,
            kind: crate::error::GetFolderPathErrorKind::UnauthorizedOperationException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::unauthorized_operation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_unauthorized_operation_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetFolderPathError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "UnauthorizedResourceAccessException" => crate::error::GetFolderPathError {
            meta: generic,
            kind: crate::error::GetFolderPathErrorKind::UnauthorizedResourceAccessException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::unauthorized_resource_access_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_unauthorized_resource_access_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetFolderPathError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetFolderPathError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_folder_path_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetFolderPathOutput, crate::error::GetFolderPathError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_folder_path_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_get_folder_path(response.body().as_ref(), output)
                .map_err(crate::error::GetFolderPathError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_resources_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetResourcesOutput, crate::error::GetResourcesError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetResourcesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetResourcesError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "FailedDependencyException" => crate::error::GetResourcesError {
            meta: generic,
            kind: crate::error::GetResourcesErrorKind::FailedDependencyException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::failed_dependency_exception::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_failed_dependency_exceptionjson_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::GetResourcesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidArgumentException" => crate::error::GetResourcesError {
            meta: generic,
            kind: crate::error::GetResourcesErrorKind::InvalidArgumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_argument_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_argument_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetResourcesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceUnavailableException" => {
            crate::error::GetResourcesError {
                meta: generic,
                kind: crate::error::GetResourcesErrorKind::ServiceUnavailableException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::service_unavailable_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_service_unavailable_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetResourcesError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "UnauthorizedOperationException" => crate::error::GetResourcesError {
            meta: generic,
            kind: crate::error::GetResourcesErrorKind::UnauthorizedOperationException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::unauthorized_operation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_unauthorized_operation_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetResourcesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "UnauthorizedResourceAccessException" => crate::error::GetResourcesError {
            meta: generic,
            kind: crate::error::GetResourcesErrorKind::UnauthorizedResourceAccessException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::unauthorized_resource_access_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_unauthorized_resource_access_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetResourcesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetResourcesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_resources_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetResourcesOutput, crate::error::GetResourcesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_resources_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_get_resources(response.body().as_ref(), output)
            .map_err(crate::error::GetResourcesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_initiate_document_version_upload_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::InitiateDocumentVersionUploadOutput,
    crate::error::InitiateDocumentVersionUploadError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::InitiateDocumentVersionUploadError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::InitiateDocumentVersionUploadError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DraftUploadOutOfSyncException" => crate::error::InitiateDocumentVersionUploadError { meta: generic, kind: crate::error::InitiateDocumentVersionUploadErrorKind::DraftUploadOutOfSyncException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::draft_upload_out_of_sync_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_draft_upload_out_of_sync_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::InitiateDocumentVersionUploadError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EntityAlreadyExistsException" => crate::error::InitiateDocumentVersionUploadError { meta: generic, kind: crate::error::InitiateDocumentVersionUploadErrorKind::EntityAlreadyExistsException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::entity_already_exists_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_entity_already_exists_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::InitiateDocumentVersionUploadError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EntityNotExistsException" => crate::error::InitiateDocumentVersionUploadError { meta: generic, kind: crate::error::InitiateDocumentVersionUploadErrorKind::EntityNotExistsException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::entity_not_exists_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_entity_not_exists_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::InitiateDocumentVersionUploadError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "FailedDependencyException" => crate::error::InitiateDocumentVersionUploadError { meta: generic, kind: crate::error::InitiateDocumentVersionUploadErrorKind::FailedDependencyException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::failed_dependency_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_failed_dependency_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::InitiateDocumentVersionUploadError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ProhibitedStateException" => crate::error::InitiateDocumentVersionUploadError { meta: generic, kind: crate::error::InitiateDocumentVersionUploadErrorKind::ProhibitedStateException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::prohibited_state_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_prohibited_state_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::InitiateDocumentVersionUploadError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ResourceAlreadyCheckedOutException" => crate::error::InitiateDocumentVersionUploadError { meta: generic, kind: crate::error::InitiateDocumentVersionUploadErrorKind::ResourceAlreadyCheckedOutException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::resource_already_checked_out_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_resource_already_checked_out_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::InitiateDocumentVersionUploadError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ServiceUnavailableException" => crate::error::InitiateDocumentVersionUploadError { meta: generic, kind: crate::error::InitiateDocumentVersionUploadErrorKind::ServiceUnavailableException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::service_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_service_unavailable_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::InitiateDocumentVersionUploadError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "StorageLimitExceededException" => crate::error::InitiateDocumentVersionUploadError { meta: generic, kind: crate::error::InitiateDocumentVersionUploadErrorKind::StorageLimitExceededException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::storage_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_storage_limit_exceeded_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::InitiateDocumentVersionUploadError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "StorageLimitWillExceedException" => crate::error::InitiateDocumentVersionUploadError { meta: generic, kind: crate::error::InitiateDocumentVersionUploadErrorKind::StorageLimitWillExceedException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::storage_limit_will_exceed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_storage_limit_will_exceed_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::InitiateDocumentVersionUploadError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedOperationException" => crate::error::InitiateDocumentVersionUploadError { meta: generic, kind: crate::error::InitiateDocumentVersionUploadErrorKind::UnauthorizedOperationException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::unauthorized_operation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_unauthorized_operation_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::InitiateDocumentVersionUploadError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedResourceAccessException" => crate::error::InitiateDocumentVersionUploadError { meta: generic, kind: crate::error::InitiateDocumentVersionUploadErrorKind::UnauthorizedResourceAccessException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::unauthorized_resource_access_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_unauthorized_resource_access_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::InitiateDocumentVersionUploadError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::InitiateDocumentVersionUploadError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_initiate_document_version_upload_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::InitiateDocumentVersionUploadOutput,
    crate::error::InitiateDocumentVersionUploadError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::initiate_document_version_upload_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_initiate_document_version_upload(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::InitiateDocumentVersionUploadError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_remove_all_resource_permissions_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RemoveAllResourcePermissionsOutput,
    crate::error::RemoveAllResourcePermissionsError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::RemoveAllResourcePermissionsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::RemoveAllResourcePermissionsError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "FailedDependencyException" => crate::error::RemoveAllResourcePermissionsError { meta: generic, kind: crate::error::RemoveAllResourcePermissionsErrorKind::FailedDependencyException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::failed_dependency_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_failed_dependency_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::RemoveAllResourcePermissionsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ServiceUnavailableException" => crate::error::RemoveAllResourcePermissionsError { meta: generic, kind: crate::error::RemoveAllResourcePermissionsErrorKind::ServiceUnavailableException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::service_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_service_unavailable_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::RemoveAllResourcePermissionsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedOperationException" => crate::error::RemoveAllResourcePermissionsError { meta: generic, kind: crate::error::RemoveAllResourcePermissionsErrorKind::UnauthorizedOperationException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::unauthorized_operation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_unauthorized_operation_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::RemoveAllResourcePermissionsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedResourceAccessException" => crate::error::RemoveAllResourcePermissionsError { meta: generic, kind: crate::error::RemoveAllResourcePermissionsErrorKind::UnauthorizedResourceAccessException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::unauthorized_resource_access_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_unauthorized_resource_access_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::RemoveAllResourcePermissionsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::RemoveAllResourcePermissionsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_remove_all_resource_permissions_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RemoveAllResourcePermissionsOutput,
    crate::error::RemoveAllResourcePermissionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::remove_all_resource_permissions_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_remove_resource_permission_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RemoveResourcePermissionOutput,
    crate::error::RemoveResourcePermissionError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::RemoveResourcePermissionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::RemoveResourcePermissionError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "FailedDependencyException" => crate::error::RemoveResourcePermissionError {
            meta: generic,
            kind: crate::error::RemoveResourcePermissionErrorKind::FailedDependencyException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::failed_dependency_exception::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_failed_dependency_exceptionjson_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::RemoveResourcePermissionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceUnavailableException" => {
            crate::error::RemoveResourcePermissionError {
                meta: generic,
                kind: crate::error::RemoveResourcePermissionErrorKind::ServiceUnavailableException(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::service_unavailable_exception::Builder::default();
                            let _ = response;
                            output = crate::json_deser::deser_structure_service_unavailable_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::RemoveResourcePermissionError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
            }
        }
        "UnauthorizedOperationException" => crate::error::RemoveResourcePermissionError {
            meta: generic,
            kind: crate::error::RemoveResourcePermissionErrorKind::UnauthorizedOperationException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::unauthorized_operation_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_unauthorized_operation_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::RemoveResourcePermissionError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "UnauthorizedResourceAccessException" => crate::error::RemoveResourcePermissionError {
            meta: generic,
            kind:
                crate::error::RemoveResourcePermissionErrorKind::UnauthorizedResourceAccessException(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]let mut output = crate::error::unauthorized_resource_access_exception::Builder::default();
                            let _ = response;
                            output = crate::json_deser::deser_structure_unauthorized_resource_access_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::RemoveResourcePermissionError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        _ => crate::error::RemoveResourcePermissionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_remove_resource_permission_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RemoveResourcePermissionOutput,
    crate::error::RemoveResourcePermissionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::remove_resource_permission_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_document_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateDocumentOutput, crate::error::UpdateDocumentError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::UpdateDocumentError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateDocumentError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ConcurrentModificationException" => crate::error::UpdateDocumentError {
            meta: generic,
            kind: crate::error::UpdateDocumentErrorKind::ConcurrentModificationException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::concurrent_modification_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_concurrent_modification_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdateDocumentError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ConflictingOperationException" => {
            crate::error::UpdateDocumentError {
                meta: generic,
                kind: crate::error::UpdateDocumentErrorKind::ConflictingOperationException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::conflicting_operation_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_conflicting_operation_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdateDocumentError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "EntityAlreadyExistsException" => {
            crate::error::UpdateDocumentError {
                meta: generic,
                kind: crate::error::UpdateDocumentErrorKind::EntityAlreadyExistsException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::entity_already_exists_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_entity_already_exists_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdateDocumentError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "EntityNotExistsException" => crate::error::UpdateDocumentError {
            meta: generic,
            kind: crate::error::UpdateDocumentErrorKind::EntityNotExistsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::entity_not_exists_exception::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_entity_not_exists_exceptionjson_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::UpdateDocumentError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "FailedDependencyException" => crate::error::UpdateDocumentError {
            meta: generic,
            kind: crate::error::UpdateDocumentErrorKind::FailedDependencyException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::failed_dependency_exception::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_failed_dependency_exceptionjson_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::UpdateDocumentError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceededException" => crate::error::UpdateDocumentError {
            meta: generic,
            kind: crate::error::UpdateDocumentErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_limit_exceeded_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateDocumentError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ProhibitedStateException" => crate::error::UpdateDocumentError {
            meta: generic,
            kind: crate::error::UpdateDocumentErrorKind::ProhibitedStateException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::prohibited_state_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_prohibited_state_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateDocumentError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceUnavailableException" => {
            crate::error::UpdateDocumentError {
                meta: generic,
                kind: crate::error::UpdateDocumentErrorKind::ServiceUnavailableException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::service_unavailable_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_service_unavailable_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdateDocumentError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "UnauthorizedOperationException" => crate::error::UpdateDocumentError {
            meta: generic,
            kind: crate::error::UpdateDocumentErrorKind::UnauthorizedOperationException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::unauthorized_operation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_unauthorized_operation_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdateDocumentError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "UnauthorizedResourceAccessException" => crate::error::UpdateDocumentError {
            meta: generic,
            kind: crate::error::UpdateDocumentErrorKind::UnauthorizedResourceAccessException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::unauthorized_resource_access_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_unauthorized_resource_access_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdateDocumentError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::UpdateDocumentError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_document_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateDocumentOutput, crate::error::UpdateDocumentError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_document_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_document_version_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateDocumentVersionOutput,
    crate::error::UpdateDocumentVersionError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::UpdateDocumentVersionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateDocumentVersionError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ConcurrentModificationException" => crate::error::UpdateDocumentVersionError {
            meta: generic,
            kind: crate::error::UpdateDocumentVersionErrorKind::ConcurrentModificationException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::concurrent_modification_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_concurrent_modification_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdateDocumentVersionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EntityNotExistsException" => crate::error::UpdateDocumentVersionError {
            meta: generic,
            kind: crate::error::UpdateDocumentVersionErrorKind::EntityNotExistsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::entity_not_exists_exception::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_entity_not_exists_exceptionjson_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::UpdateDocumentVersionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "FailedDependencyException" => crate::error::UpdateDocumentVersionError {
            meta: generic,
            kind: crate::error::UpdateDocumentVersionErrorKind::FailedDependencyException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::failed_dependency_exception::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_failed_dependency_exceptionjson_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::UpdateDocumentVersionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidOperationException" => crate::error::UpdateDocumentVersionError {
            meta: generic,
            kind: crate::error::UpdateDocumentVersionErrorKind::InvalidOperationException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_operation_exception::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_invalid_operation_exceptionjson_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::UpdateDocumentVersionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ProhibitedStateException" => crate::error::UpdateDocumentVersionError {
            meta: generic,
            kind: crate::error::UpdateDocumentVersionErrorKind::ProhibitedStateException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::prohibited_state_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_prohibited_state_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateDocumentVersionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceUnavailableException" => {
            crate::error::UpdateDocumentVersionError {
                meta: generic,
                kind: crate::error::UpdateDocumentVersionErrorKind::ServiceUnavailableException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::service_unavailable_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_service_unavailable_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdateDocumentVersionError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "UnauthorizedOperationException" => crate::error::UpdateDocumentVersionError {
            meta: generic,
            kind: crate::error::UpdateDocumentVersionErrorKind::UnauthorizedOperationException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::unauthorized_operation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_unauthorized_operation_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdateDocumentVersionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "UnauthorizedResourceAccessException" => crate::error::UpdateDocumentVersionError {
            meta: generic,
            kind: crate::error::UpdateDocumentVersionErrorKind::UnauthorizedResourceAccessException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::unauthorized_resource_access_exception::Builder::default(
                            );
                        let _ = response;
                        output = crate::json_deser::deser_structure_unauthorized_resource_access_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdateDocumentVersionError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        _ => crate::error::UpdateDocumentVersionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_document_version_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateDocumentVersionOutput,
    crate::error::UpdateDocumentVersionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_document_version_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_folder_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateFolderOutput, crate::error::UpdateFolderError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::UpdateFolderError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateFolderError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ConcurrentModificationException" => crate::error::UpdateFolderError {
            meta: generic,
            kind: crate::error::UpdateFolderErrorKind::ConcurrentModificationException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::concurrent_modification_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_concurrent_modification_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdateFolderError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ConflictingOperationException" => {
            crate::error::UpdateFolderError {
                meta: generic,
                kind: crate::error::UpdateFolderErrorKind::ConflictingOperationException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::conflicting_operation_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_conflicting_operation_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdateFolderError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "EntityAlreadyExistsException" => {
            crate::error::UpdateFolderError {
                meta: generic,
                kind: crate::error::UpdateFolderErrorKind::EntityAlreadyExistsException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::entity_already_exists_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_entity_already_exists_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdateFolderError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "EntityNotExistsException" => crate::error::UpdateFolderError {
            meta: generic,
            kind: crate::error::UpdateFolderErrorKind::EntityNotExistsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::entity_not_exists_exception::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_entity_not_exists_exceptionjson_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::UpdateFolderError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "FailedDependencyException" => crate::error::UpdateFolderError {
            meta: generic,
            kind: crate::error::UpdateFolderErrorKind::FailedDependencyException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::failed_dependency_exception::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_failed_dependency_exceptionjson_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::UpdateFolderError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceededException" => crate::error::UpdateFolderError {
            meta: generic,
            kind: crate::error::UpdateFolderErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_limit_exceeded_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateFolderError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ProhibitedStateException" => crate::error::UpdateFolderError {
            meta: generic,
            kind: crate::error::UpdateFolderErrorKind::ProhibitedStateException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::prohibited_state_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_prohibited_state_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateFolderError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceUnavailableException" => {
            crate::error::UpdateFolderError {
                meta: generic,
                kind: crate::error::UpdateFolderErrorKind::ServiceUnavailableException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::service_unavailable_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_service_unavailable_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdateFolderError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "UnauthorizedOperationException" => crate::error::UpdateFolderError {
            meta: generic,
            kind: crate::error::UpdateFolderErrorKind::UnauthorizedOperationException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::unauthorized_operation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_unauthorized_operation_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdateFolderError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "UnauthorizedResourceAccessException" => crate::error::UpdateFolderError {
            meta: generic,
            kind: crate::error::UpdateFolderErrorKind::UnauthorizedResourceAccessException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::unauthorized_resource_access_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_unauthorized_resource_access_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdateFolderError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::UpdateFolderError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_folder_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateFolderOutput, crate::error::UpdateFolderError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_folder_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_user_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateUserOutput, crate::error::UpdateUserError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::UpdateUserError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateUserError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DeactivatingLastSystemUserException" => crate::error::UpdateUserError {
            meta: generic,
            kind: crate::error::UpdateUserErrorKind::DeactivatingLastSystemUserException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::deactivating_last_system_user_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_deactivating_last_system_user_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdateUserError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EntityNotExistsException" => crate::error::UpdateUserError {
            meta: generic,
            kind: crate::error::UpdateUserErrorKind::EntityNotExistsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::entity_not_exists_exception::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_entity_not_exists_exceptionjson_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::UpdateUserError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "FailedDependencyException" => crate::error::UpdateUserError {
            meta: generic,
            kind: crate::error::UpdateUserErrorKind::FailedDependencyException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::failed_dependency_exception::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_failed_dependency_exceptionjson_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::UpdateUserError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "IllegalUserStateException" => {
            crate::error::UpdateUserError {
                meta: generic,
                kind: crate::error::UpdateUserErrorKind::IllegalUserStateException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::illegal_user_state_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_illegal_user_state_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdateUserError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "InvalidArgumentException" => crate::error::UpdateUserError {
            meta: generic,
            kind: crate::error::UpdateUserErrorKind::InvalidArgumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_argument_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_argument_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateUserError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceUnavailableException" => {
            crate::error::UpdateUserError {
                meta: generic,
                kind: crate::error::UpdateUserErrorKind::ServiceUnavailableException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::service_unavailable_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_service_unavailable_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdateUserError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "UnauthorizedOperationException" => crate::error::UpdateUserError {
            meta: generic,
            kind: crate::error::UpdateUserErrorKind::UnauthorizedOperationException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::unauthorized_operation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_unauthorized_operation_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdateUserError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "UnauthorizedResourceAccessException" => crate::error::UpdateUserError {
            meta: generic,
            kind: crate::error::UpdateUserErrorKind::UnauthorizedResourceAccessException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::unauthorized_resource_access_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_unauthorized_resource_access_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdateUserError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::UpdateUserError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_user_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateUserOutput, crate::error::UpdateUserError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_user_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_update_user(response.body().as_ref(), output)
            .map_err(crate::error::UpdateUserError::unhandled)?;
        output.build()
    })
}
