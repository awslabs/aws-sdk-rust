// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct CreateEnvironmentInput {
    /// <note>
    /// <p>This parameter is not used in Amazon EVS currently. If you supply input for this parameter, it will have no effect.</p>
    /// </note>
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the environment creation request. If you do not specify a client token, a randomly generated token is used for the request to ensure idempotency.</p>
    pub client_token: ::std::option::Option<::std::string::String>,
    /// <p>The name to give to your environment. The name can contain only alphanumeric characters (case-sensitive), hyphens, and underscores. It must start with an alphanumeric character, and can't be longer than 100 characters. The name must be unique within the Amazon Web Services Region and Amazon Web Services account that you're creating the environment in.</p>
    pub environment_name: ::std::option::Option<::std::string::String>,
    /// <p>A unique ID for the customer-managed KMS key that is used to encrypt the VCF credential pairs for SDDC Manager, NSX Manager, and vCenter appliances. These credentials are stored in Amazon Web Services Secrets Manager.</p>
    pub kms_key_id: ::std::option::Option<::std::string::String>,
    /// <p>Metadata that assists with categorization and organization. Each tag consists of a key and an optional value. You define both. Tags don't propagate to any other cluster or Amazon Web Services resources.</p>
    pub tags: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>,
    /// <p>The security group that controls communication between the Amazon EVS control plane and VPC. The default security group is used if a custom security group isn't specified.</p>
    /// <p>The security group should allow access to the following.</p>
    /// <ul>
    /// <li>
    /// <p>TCP/UDP access to the DNS servers</p></li>
    /// <li>
    /// <p>HTTPS/SSH access to the host management VLAN subnet</p></li>
    /// <li>
    /// <p>HTTPS/SSH access to the Management VM VLAN subnet</p></li>
    /// </ul>
    /// <p>You should avoid modifying the security group rules after deployment, as this can break the persistent connection between the Amazon EVS control plane and VPC. This can cause future environment actions like adding or removing hosts to fail.</p>
    pub service_access_security_groups: ::std::option::Option<crate::types::ServiceAccessSecurityGroups>,
    /// <p>A unique ID for the VPC that the environment is deployed inside.</p>
    /// <p>Amazon EVS requires that all VPC subnets exist in a single Availability Zone in a Region where the service is available.</p>
    /// <p>The VPC that you specify must have a valid DHCP option set with domain name, at least two DNS servers, and an NTP server. These settings are used to configure your VCF appliances and hosts. The VPC cannot be used with any other deployed Amazon EVS environment. Amazon EVS does not provide multi-VPC support for environments at this time.</p>
    /// <p>Amazon EVS does not support the following Amazon Web Services networking options for NSX overlay connectivity: cross-Region VPC peering, Amazon S3 gateway endpoints, or Amazon Web Services Direct Connect virtual private gateway associations.</p><note>
    /// <p>Ensure that you specify a VPC that is adequately sized to accommodate the Amazon EVS subnets.</p>
    /// </note>
    pub vpc_id: ::std::option::Option<::std::string::String>,
    /// <p>The subnet that is used to establish connectivity between the Amazon EVS control plane and VPC. Amazon EVS uses this subnet to validate mandatory DNS records for your VCF appliances and hosts and create the environment.</p>
    pub service_access_subnet_id: ::std::option::Option<::std::string::String>,
    /// <p>The VCF version to use for the environment.</p>
    pub vcf_version: ::std::option::Option<crate::types::VcfVersion>,
    /// <p>Customer confirmation that the customer has purchased and will continue to maintain the required number of VCF software licenses to cover all physical processor cores in the Amazon EVS environment. Information about your VCF software in Amazon EVS will be shared with Broadcom to verify license compliance. Amazon EVS does not validate license keys. To validate license keys, visit the Broadcom support portal.</p>
    pub terms_accepted: ::std::option::Option<bool>,
    /// <p>The license information that Amazon EVS requires to create an environment. Amazon EVS requires two license keys: a VCF solution key and a vSAN license key. The VCF solution key must cover a minimum of 256 cores. The vSAN license key must provide at least 110 TiB of vSAN capacity.</p>
    /// <p>VCF licenses can be used for only one Amazon EVS environment. Amazon EVS does not support reuse of VCF licenses for multiple environments.</p>
    /// <p>VCF license information can be retrieved from the Broadcom portal.</p>
    pub license_info: ::std::option::Option<::std::vec::Vec<crate::types::LicenseInfo>>,
    /// <p>The initial VLAN subnets for the Amazon EVS environment.</p><note>
    /// <p>For each Amazon EVS VLAN subnet, you must specify a non-overlapping CIDR block. Amazon EVS VLAN subnets have a minimum CIDR block size of /28 and a maximum size of /24.</p>
    /// </note>
    pub initial_vlans: ::std::option::Option<crate::types::InitialVlans>,
    /// <p>The ESX hosts to add to the environment. Amazon EVS requires that you provide details for a minimum of 4 hosts during environment creation.</p>
    /// <p>For each host, you must provide the desired hostname, EC2 SSH keypair name, and EC2 instance type. Optionally, you can also provide a partition or cluster placement group to use, or use Amazon EC2 Dedicated Hosts.</p>
    pub hosts: ::std::option::Option<::std::vec::Vec<crate::types::HostInfoForCreate>>,
    /// <p>The connectivity configuration for the environment. Amazon EVS requires that you specify two route server peer IDs. During environment creation, the route server endpoints peer with the NSX edges over the NSX uplink subnet, providing BGP-based dynamic routing for overlay networks.</p>
    pub connectivity_info: ::std::option::Option<crate::types::ConnectivityInfo>,
    /// <p>The DNS hostnames for the virtual machines that host the VCF management appliances. Amazon EVS requires that you provide DNS hostnames for the following appliances: vCenter, NSX Manager, SDDC Manager, and Cloud Builder.</p>
    pub vcf_hostnames: ::std::option::Option<crate::types::VcfHostnames>,
    /// <p>The Broadcom Site ID that is allocated to you as part of your electronic software delivery. This ID allows customer access to the Broadcom portal, and is provided to you by Broadcom at the close of your software contract or contract renewal. Amazon EVS uses the Broadcom Site ID that you provide to meet Broadcom VCF license usage reporting requirements for Amazon EVS.</p>
    pub site_id: ::std::option::Option<::std::string::String>,
}
impl CreateEnvironmentInput {
    /// <note>
    /// <p>This parameter is not used in Amazon EVS currently. If you supply input for this parameter, it will have no effect.</p>
    /// </note>
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the environment creation request. If you do not specify a client token, a randomly generated token is used for the request to ensure idempotency.</p>
    pub fn client_token(&self) -> ::std::option::Option<&str> {
        self.client_token.as_deref()
    }
    /// <p>The name to give to your environment. The name can contain only alphanumeric characters (case-sensitive), hyphens, and underscores. It must start with an alphanumeric character, and can't be longer than 100 characters. The name must be unique within the Amazon Web Services Region and Amazon Web Services account that you're creating the environment in.</p>
    pub fn environment_name(&self) -> ::std::option::Option<&str> {
        self.environment_name.as_deref()
    }
    /// <p>A unique ID for the customer-managed KMS key that is used to encrypt the VCF credential pairs for SDDC Manager, NSX Manager, and vCenter appliances. These credentials are stored in Amazon Web Services Secrets Manager.</p>
    pub fn kms_key_id(&self) -> ::std::option::Option<&str> {
        self.kms_key_id.as_deref()
    }
    /// <p>Metadata that assists with categorization and organization. Each tag consists of a key and an optional value. You define both. Tags don't propagate to any other cluster or Amazon Web Services resources.</p>
    pub fn tags(&self) -> ::std::option::Option<&::std::collections::HashMap<::std::string::String, ::std::string::String>> {
        self.tags.as_ref()
    }
    /// <p>The security group that controls communication between the Amazon EVS control plane and VPC. The default security group is used if a custom security group isn't specified.</p>
    /// <p>The security group should allow access to the following.</p>
    /// <ul>
    /// <li>
    /// <p>TCP/UDP access to the DNS servers</p></li>
    /// <li>
    /// <p>HTTPS/SSH access to the host management VLAN subnet</p></li>
    /// <li>
    /// <p>HTTPS/SSH access to the Management VM VLAN subnet</p></li>
    /// </ul>
    /// <p>You should avoid modifying the security group rules after deployment, as this can break the persistent connection between the Amazon EVS control plane and VPC. This can cause future environment actions like adding or removing hosts to fail.</p>
    pub fn service_access_security_groups(&self) -> ::std::option::Option<&crate::types::ServiceAccessSecurityGroups> {
        self.service_access_security_groups.as_ref()
    }
    /// <p>A unique ID for the VPC that the environment is deployed inside.</p>
    /// <p>Amazon EVS requires that all VPC subnets exist in a single Availability Zone in a Region where the service is available.</p>
    /// <p>The VPC that you specify must have a valid DHCP option set with domain name, at least two DNS servers, and an NTP server. These settings are used to configure your VCF appliances and hosts. The VPC cannot be used with any other deployed Amazon EVS environment. Amazon EVS does not provide multi-VPC support for environments at this time.</p>
    /// <p>Amazon EVS does not support the following Amazon Web Services networking options for NSX overlay connectivity: cross-Region VPC peering, Amazon S3 gateway endpoints, or Amazon Web Services Direct Connect virtual private gateway associations.</p><note>
    /// <p>Ensure that you specify a VPC that is adequately sized to accommodate the Amazon EVS subnets.</p>
    /// </note>
    pub fn vpc_id(&self) -> ::std::option::Option<&str> {
        self.vpc_id.as_deref()
    }
    /// <p>The subnet that is used to establish connectivity between the Amazon EVS control plane and VPC. Amazon EVS uses this subnet to validate mandatory DNS records for your VCF appliances and hosts and create the environment.</p>
    pub fn service_access_subnet_id(&self) -> ::std::option::Option<&str> {
        self.service_access_subnet_id.as_deref()
    }
    /// <p>The VCF version to use for the environment.</p>
    pub fn vcf_version(&self) -> ::std::option::Option<&crate::types::VcfVersion> {
        self.vcf_version.as_ref()
    }
    /// <p>Customer confirmation that the customer has purchased and will continue to maintain the required number of VCF software licenses to cover all physical processor cores in the Amazon EVS environment. Information about your VCF software in Amazon EVS will be shared with Broadcom to verify license compliance. Amazon EVS does not validate license keys. To validate license keys, visit the Broadcom support portal.</p>
    pub fn terms_accepted(&self) -> ::std::option::Option<bool> {
        self.terms_accepted
    }
    /// <p>The license information that Amazon EVS requires to create an environment. Amazon EVS requires two license keys: a VCF solution key and a vSAN license key. The VCF solution key must cover a minimum of 256 cores. The vSAN license key must provide at least 110 TiB of vSAN capacity.</p>
    /// <p>VCF licenses can be used for only one Amazon EVS environment. Amazon EVS does not support reuse of VCF licenses for multiple environments.</p>
    /// <p>VCF license information can be retrieved from the Broadcom portal.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.license_info.is_none()`.
    pub fn license_info(&self) -> &[crate::types::LicenseInfo] {
        self.license_info.as_deref().unwrap_or_default()
    }
    /// <p>The initial VLAN subnets for the Amazon EVS environment.</p><note>
    /// <p>For each Amazon EVS VLAN subnet, you must specify a non-overlapping CIDR block. Amazon EVS VLAN subnets have a minimum CIDR block size of /28 and a maximum size of /24.</p>
    /// </note>
    pub fn initial_vlans(&self) -> ::std::option::Option<&crate::types::InitialVlans> {
        self.initial_vlans.as_ref()
    }
    /// <p>The ESX hosts to add to the environment. Amazon EVS requires that you provide details for a minimum of 4 hosts during environment creation.</p>
    /// <p>For each host, you must provide the desired hostname, EC2 SSH keypair name, and EC2 instance type. Optionally, you can also provide a partition or cluster placement group to use, or use Amazon EC2 Dedicated Hosts.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.hosts.is_none()`.
    pub fn hosts(&self) -> &[crate::types::HostInfoForCreate] {
        self.hosts.as_deref().unwrap_or_default()
    }
    /// <p>The connectivity configuration for the environment. Amazon EVS requires that you specify two route server peer IDs. During environment creation, the route server endpoints peer with the NSX edges over the NSX uplink subnet, providing BGP-based dynamic routing for overlay networks.</p>
    pub fn connectivity_info(&self) -> ::std::option::Option<&crate::types::ConnectivityInfo> {
        self.connectivity_info.as_ref()
    }
    /// <p>The DNS hostnames for the virtual machines that host the VCF management appliances. Amazon EVS requires that you provide DNS hostnames for the following appliances: vCenter, NSX Manager, SDDC Manager, and Cloud Builder.</p>
    pub fn vcf_hostnames(&self) -> ::std::option::Option<&crate::types::VcfHostnames> {
        self.vcf_hostnames.as_ref()
    }
    /// <p>The Broadcom Site ID that is allocated to you as part of your electronic software delivery. This ID allows customer access to the Broadcom portal, and is provided to you by Broadcom at the close of your software contract or contract renewal. Amazon EVS uses the Broadcom Site ID that you provide to meet Broadcom VCF license usage reporting requirements for Amazon EVS.</p>
    pub fn site_id(&self) -> ::std::option::Option<&str> {
        self.site_id.as_deref()
    }
}
impl CreateEnvironmentInput {
    /// Creates a new builder-style object to manufacture [`CreateEnvironmentInput`](crate::operation::create_environment::CreateEnvironmentInput).
    pub fn builder() -> crate::operation::create_environment::builders::CreateEnvironmentInputBuilder {
        crate::operation::create_environment::builders::CreateEnvironmentInputBuilder::default()
    }
}

/// A builder for [`CreateEnvironmentInput`](crate::operation::create_environment::CreateEnvironmentInput).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
#[non_exhaustive]
pub struct CreateEnvironmentInputBuilder {
    pub(crate) client_token: ::std::option::Option<::std::string::String>,
    pub(crate) environment_name: ::std::option::Option<::std::string::String>,
    pub(crate) kms_key_id: ::std::option::Option<::std::string::String>,
    pub(crate) tags: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>,
    pub(crate) service_access_security_groups: ::std::option::Option<crate::types::ServiceAccessSecurityGroups>,
    pub(crate) vpc_id: ::std::option::Option<::std::string::String>,
    pub(crate) service_access_subnet_id: ::std::option::Option<::std::string::String>,
    pub(crate) vcf_version: ::std::option::Option<crate::types::VcfVersion>,
    pub(crate) terms_accepted: ::std::option::Option<bool>,
    pub(crate) license_info: ::std::option::Option<::std::vec::Vec<crate::types::LicenseInfo>>,
    pub(crate) initial_vlans: ::std::option::Option<crate::types::InitialVlans>,
    pub(crate) hosts: ::std::option::Option<::std::vec::Vec<crate::types::HostInfoForCreate>>,
    pub(crate) connectivity_info: ::std::option::Option<crate::types::ConnectivityInfo>,
    pub(crate) vcf_hostnames: ::std::option::Option<crate::types::VcfHostnames>,
    pub(crate) site_id: ::std::option::Option<::std::string::String>,
}
impl CreateEnvironmentInputBuilder {
    /// <note>
    /// <p>This parameter is not used in Amazon EVS currently. If you supply input for this parameter, it will have no effect.</p>
    /// </note>
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the environment creation request. If you do not specify a client token, a randomly generated token is used for the request to ensure idempotency.</p>
    pub fn client_token(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.client_token = ::std::option::Option::Some(input.into());
        self
    }
    /// <note>
    /// <p>This parameter is not used in Amazon EVS currently. If you supply input for this parameter, it will have no effect.</p>
    /// </note>
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the environment creation request. If you do not specify a client token, a randomly generated token is used for the request to ensure idempotency.</p>
    pub fn set_client_token(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.client_token = input;
        self
    }
    /// <note>
    /// <p>This parameter is not used in Amazon EVS currently. If you supply input for this parameter, it will have no effect.</p>
    /// </note>
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the environment creation request. If you do not specify a client token, a randomly generated token is used for the request to ensure idempotency.</p>
    pub fn get_client_token(&self) -> &::std::option::Option<::std::string::String> {
        &self.client_token
    }
    /// <p>The name to give to your environment. The name can contain only alphanumeric characters (case-sensitive), hyphens, and underscores. It must start with an alphanumeric character, and can't be longer than 100 characters. The name must be unique within the Amazon Web Services Region and Amazon Web Services account that you're creating the environment in.</p>
    pub fn environment_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.environment_name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The name to give to your environment. The name can contain only alphanumeric characters (case-sensitive), hyphens, and underscores. It must start with an alphanumeric character, and can't be longer than 100 characters. The name must be unique within the Amazon Web Services Region and Amazon Web Services account that you're creating the environment in.</p>
    pub fn set_environment_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.environment_name = input;
        self
    }
    /// <p>The name to give to your environment. The name can contain only alphanumeric characters (case-sensitive), hyphens, and underscores. It must start with an alphanumeric character, and can't be longer than 100 characters. The name must be unique within the Amazon Web Services Region and Amazon Web Services account that you're creating the environment in.</p>
    pub fn get_environment_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.environment_name
    }
    /// <p>A unique ID for the customer-managed KMS key that is used to encrypt the VCF credential pairs for SDDC Manager, NSX Manager, and vCenter appliances. These credentials are stored in Amazon Web Services Secrets Manager.</p>
    pub fn kms_key_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.kms_key_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>A unique ID for the customer-managed KMS key that is used to encrypt the VCF credential pairs for SDDC Manager, NSX Manager, and vCenter appliances. These credentials are stored in Amazon Web Services Secrets Manager.</p>
    pub fn set_kms_key_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.kms_key_id = input;
        self
    }
    /// <p>A unique ID for the customer-managed KMS key that is used to encrypt the VCF credential pairs for SDDC Manager, NSX Manager, and vCenter appliances. These credentials are stored in Amazon Web Services Secrets Manager.</p>
    pub fn get_kms_key_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.kms_key_id
    }
    /// Adds a key-value pair to `tags`.
    ///
    /// To override the contents of this collection use [`set_tags`](Self::set_tags).
    ///
    /// <p>Metadata that assists with categorization and organization. Each tag consists of a key and an optional value. You define both. Tags don't propagate to any other cluster or Amazon Web Services resources.</p>
    pub fn tags(mut self, k: impl ::std::convert::Into<::std::string::String>, v: impl ::std::convert::Into<::std::string::String>) -> Self {
        let mut hash_map = self.tags.unwrap_or_default();
        hash_map.insert(k.into(), v.into());
        self.tags = ::std::option::Option::Some(hash_map);
        self
    }
    /// <p>Metadata that assists with categorization and organization. Each tag consists of a key and an optional value. You define both. Tags don't propagate to any other cluster or Amazon Web Services resources.</p>
    pub fn set_tags(mut self, input: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>) -> Self {
        self.tags = input;
        self
    }
    /// <p>Metadata that assists with categorization and organization. Each tag consists of a key and an optional value. You define both. Tags don't propagate to any other cluster or Amazon Web Services resources.</p>
    pub fn get_tags(&self) -> &::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>> {
        &self.tags
    }
    /// <p>The security group that controls communication between the Amazon EVS control plane and VPC. The default security group is used if a custom security group isn't specified.</p>
    /// <p>The security group should allow access to the following.</p>
    /// <ul>
    /// <li>
    /// <p>TCP/UDP access to the DNS servers</p></li>
    /// <li>
    /// <p>HTTPS/SSH access to the host management VLAN subnet</p></li>
    /// <li>
    /// <p>HTTPS/SSH access to the Management VM VLAN subnet</p></li>
    /// </ul>
    /// <p>You should avoid modifying the security group rules after deployment, as this can break the persistent connection between the Amazon EVS control plane and VPC. This can cause future environment actions like adding or removing hosts to fail.</p>
    pub fn service_access_security_groups(mut self, input: crate::types::ServiceAccessSecurityGroups) -> Self {
        self.service_access_security_groups = ::std::option::Option::Some(input);
        self
    }
    /// <p>The security group that controls communication between the Amazon EVS control plane and VPC. The default security group is used if a custom security group isn't specified.</p>
    /// <p>The security group should allow access to the following.</p>
    /// <ul>
    /// <li>
    /// <p>TCP/UDP access to the DNS servers</p></li>
    /// <li>
    /// <p>HTTPS/SSH access to the host management VLAN subnet</p></li>
    /// <li>
    /// <p>HTTPS/SSH access to the Management VM VLAN subnet</p></li>
    /// </ul>
    /// <p>You should avoid modifying the security group rules after deployment, as this can break the persistent connection between the Amazon EVS control plane and VPC. This can cause future environment actions like adding or removing hosts to fail.</p>
    pub fn set_service_access_security_groups(mut self, input: ::std::option::Option<crate::types::ServiceAccessSecurityGroups>) -> Self {
        self.service_access_security_groups = input;
        self
    }
    /// <p>The security group that controls communication between the Amazon EVS control plane and VPC. The default security group is used if a custom security group isn't specified.</p>
    /// <p>The security group should allow access to the following.</p>
    /// <ul>
    /// <li>
    /// <p>TCP/UDP access to the DNS servers</p></li>
    /// <li>
    /// <p>HTTPS/SSH access to the host management VLAN subnet</p></li>
    /// <li>
    /// <p>HTTPS/SSH access to the Management VM VLAN subnet</p></li>
    /// </ul>
    /// <p>You should avoid modifying the security group rules after deployment, as this can break the persistent connection between the Amazon EVS control plane and VPC. This can cause future environment actions like adding or removing hosts to fail.</p>
    pub fn get_service_access_security_groups(&self) -> &::std::option::Option<crate::types::ServiceAccessSecurityGroups> {
        &self.service_access_security_groups
    }
    /// <p>A unique ID for the VPC that the environment is deployed inside.</p>
    /// <p>Amazon EVS requires that all VPC subnets exist in a single Availability Zone in a Region where the service is available.</p>
    /// <p>The VPC that you specify must have a valid DHCP option set with domain name, at least two DNS servers, and an NTP server. These settings are used to configure your VCF appliances and hosts. The VPC cannot be used with any other deployed Amazon EVS environment. Amazon EVS does not provide multi-VPC support for environments at this time.</p>
    /// <p>Amazon EVS does not support the following Amazon Web Services networking options for NSX overlay connectivity: cross-Region VPC peering, Amazon S3 gateway endpoints, or Amazon Web Services Direct Connect virtual private gateway associations.</p><note>
    /// <p>Ensure that you specify a VPC that is adequately sized to accommodate the Amazon EVS subnets.</p>
    /// </note>
    /// This field is required.
    pub fn vpc_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.vpc_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>A unique ID for the VPC that the environment is deployed inside.</p>
    /// <p>Amazon EVS requires that all VPC subnets exist in a single Availability Zone in a Region where the service is available.</p>
    /// <p>The VPC that you specify must have a valid DHCP option set with domain name, at least two DNS servers, and an NTP server. These settings are used to configure your VCF appliances and hosts. The VPC cannot be used with any other deployed Amazon EVS environment. Amazon EVS does not provide multi-VPC support for environments at this time.</p>
    /// <p>Amazon EVS does not support the following Amazon Web Services networking options for NSX overlay connectivity: cross-Region VPC peering, Amazon S3 gateway endpoints, or Amazon Web Services Direct Connect virtual private gateway associations.</p><note>
    /// <p>Ensure that you specify a VPC that is adequately sized to accommodate the Amazon EVS subnets.</p>
    /// </note>
    pub fn set_vpc_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.vpc_id = input;
        self
    }
    /// <p>A unique ID for the VPC that the environment is deployed inside.</p>
    /// <p>Amazon EVS requires that all VPC subnets exist in a single Availability Zone in a Region where the service is available.</p>
    /// <p>The VPC that you specify must have a valid DHCP option set with domain name, at least two DNS servers, and an NTP server. These settings are used to configure your VCF appliances and hosts. The VPC cannot be used with any other deployed Amazon EVS environment. Amazon EVS does not provide multi-VPC support for environments at this time.</p>
    /// <p>Amazon EVS does not support the following Amazon Web Services networking options for NSX overlay connectivity: cross-Region VPC peering, Amazon S3 gateway endpoints, or Amazon Web Services Direct Connect virtual private gateway associations.</p><note>
    /// <p>Ensure that you specify a VPC that is adequately sized to accommodate the Amazon EVS subnets.</p>
    /// </note>
    pub fn get_vpc_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.vpc_id
    }
    /// <p>The subnet that is used to establish connectivity between the Amazon EVS control plane and VPC. Amazon EVS uses this subnet to validate mandatory DNS records for your VCF appliances and hosts and create the environment.</p>
    /// This field is required.
    pub fn service_access_subnet_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.service_access_subnet_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The subnet that is used to establish connectivity between the Amazon EVS control plane and VPC. Amazon EVS uses this subnet to validate mandatory DNS records for your VCF appliances and hosts and create the environment.</p>
    pub fn set_service_access_subnet_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.service_access_subnet_id = input;
        self
    }
    /// <p>The subnet that is used to establish connectivity between the Amazon EVS control plane and VPC. Amazon EVS uses this subnet to validate mandatory DNS records for your VCF appliances and hosts and create the environment.</p>
    pub fn get_service_access_subnet_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.service_access_subnet_id
    }
    /// <p>The VCF version to use for the environment.</p>
    /// This field is required.
    pub fn vcf_version(mut self, input: crate::types::VcfVersion) -> Self {
        self.vcf_version = ::std::option::Option::Some(input);
        self
    }
    /// <p>The VCF version to use for the environment.</p>
    pub fn set_vcf_version(mut self, input: ::std::option::Option<crate::types::VcfVersion>) -> Self {
        self.vcf_version = input;
        self
    }
    /// <p>The VCF version to use for the environment.</p>
    pub fn get_vcf_version(&self) -> &::std::option::Option<crate::types::VcfVersion> {
        &self.vcf_version
    }
    /// <p>Customer confirmation that the customer has purchased and will continue to maintain the required number of VCF software licenses to cover all physical processor cores in the Amazon EVS environment. Information about your VCF software in Amazon EVS will be shared with Broadcom to verify license compliance. Amazon EVS does not validate license keys. To validate license keys, visit the Broadcom support portal.</p>
    /// This field is required.
    pub fn terms_accepted(mut self, input: bool) -> Self {
        self.terms_accepted = ::std::option::Option::Some(input);
        self
    }
    /// <p>Customer confirmation that the customer has purchased and will continue to maintain the required number of VCF software licenses to cover all physical processor cores in the Amazon EVS environment. Information about your VCF software in Amazon EVS will be shared with Broadcom to verify license compliance. Amazon EVS does not validate license keys. To validate license keys, visit the Broadcom support portal.</p>
    pub fn set_terms_accepted(mut self, input: ::std::option::Option<bool>) -> Self {
        self.terms_accepted = input;
        self
    }
    /// <p>Customer confirmation that the customer has purchased and will continue to maintain the required number of VCF software licenses to cover all physical processor cores in the Amazon EVS environment. Information about your VCF software in Amazon EVS will be shared with Broadcom to verify license compliance. Amazon EVS does not validate license keys. To validate license keys, visit the Broadcom support portal.</p>
    pub fn get_terms_accepted(&self) -> &::std::option::Option<bool> {
        &self.terms_accepted
    }
    /// Appends an item to `license_info`.
    ///
    /// To override the contents of this collection use [`set_license_info`](Self::set_license_info).
    ///
    /// <p>The license information that Amazon EVS requires to create an environment. Amazon EVS requires two license keys: a VCF solution key and a vSAN license key. The VCF solution key must cover a minimum of 256 cores. The vSAN license key must provide at least 110 TiB of vSAN capacity.</p>
    /// <p>VCF licenses can be used for only one Amazon EVS environment. Amazon EVS does not support reuse of VCF licenses for multiple environments.</p>
    /// <p>VCF license information can be retrieved from the Broadcom portal.</p>
    pub fn license_info(mut self, input: crate::types::LicenseInfo) -> Self {
        let mut v = self.license_info.unwrap_or_default();
        v.push(input);
        self.license_info = ::std::option::Option::Some(v);
        self
    }
    /// <p>The license information that Amazon EVS requires to create an environment. Amazon EVS requires two license keys: a VCF solution key and a vSAN license key. The VCF solution key must cover a minimum of 256 cores. The vSAN license key must provide at least 110 TiB of vSAN capacity.</p>
    /// <p>VCF licenses can be used for only one Amazon EVS environment. Amazon EVS does not support reuse of VCF licenses for multiple environments.</p>
    /// <p>VCF license information can be retrieved from the Broadcom portal.</p>
    pub fn set_license_info(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::LicenseInfo>>) -> Self {
        self.license_info = input;
        self
    }
    /// <p>The license information that Amazon EVS requires to create an environment. Amazon EVS requires two license keys: a VCF solution key and a vSAN license key. The VCF solution key must cover a minimum of 256 cores. The vSAN license key must provide at least 110 TiB of vSAN capacity.</p>
    /// <p>VCF licenses can be used for only one Amazon EVS environment. Amazon EVS does not support reuse of VCF licenses for multiple environments.</p>
    /// <p>VCF license information can be retrieved from the Broadcom portal.</p>
    pub fn get_license_info(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::LicenseInfo>> {
        &self.license_info
    }
    /// <p>The initial VLAN subnets for the Amazon EVS environment.</p><note>
    /// <p>For each Amazon EVS VLAN subnet, you must specify a non-overlapping CIDR block. Amazon EVS VLAN subnets have a minimum CIDR block size of /28 and a maximum size of /24.</p>
    /// </note>
    /// This field is required.
    pub fn initial_vlans(mut self, input: crate::types::InitialVlans) -> Self {
        self.initial_vlans = ::std::option::Option::Some(input);
        self
    }
    /// <p>The initial VLAN subnets for the Amazon EVS environment.</p><note>
    /// <p>For each Amazon EVS VLAN subnet, you must specify a non-overlapping CIDR block. Amazon EVS VLAN subnets have a minimum CIDR block size of /28 and a maximum size of /24.</p>
    /// </note>
    pub fn set_initial_vlans(mut self, input: ::std::option::Option<crate::types::InitialVlans>) -> Self {
        self.initial_vlans = input;
        self
    }
    /// <p>The initial VLAN subnets for the Amazon EVS environment.</p><note>
    /// <p>For each Amazon EVS VLAN subnet, you must specify a non-overlapping CIDR block. Amazon EVS VLAN subnets have a minimum CIDR block size of /28 and a maximum size of /24.</p>
    /// </note>
    pub fn get_initial_vlans(&self) -> &::std::option::Option<crate::types::InitialVlans> {
        &self.initial_vlans
    }
    /// Appends an item to `hosts`.
    ///
    /// To override the contents of this collection use [`set_hosts`](Self::set_hosts).
    ///
    /// <p>The ESX hosts to add to the environment. Amazon EVS requires that you provide details for a minimum of 4 hosts during environment creation.</p>
    /// <p>For each host, you must provide the desired hostname, EC2 SSH keypair name, and EC2 instance type. Optionally, you can also provide a partition or cluster placement group to use, or use Amazon EC2 Dedicated Hosts.</p>
    pub fn hosts(mut self, input: crate::types::HostInfoForCreate) -> Self {
        let mut v = self.hosts.unwrap_or_default();
        v.push(input);
        self.hosts = ::std::option::Option::Some(v);
        self
    }
    /// <p>The ESX hosts to add to the environment. Amazon EVS requires that you provide details for a minimum of 4 hosts during environment creation.</p>
    /// <p>For each host, you must provide the desired hostname, EC2 SSH keypair name, and EC2 instance type. Optionally, you can also provide a partition or cluster placement group to use, or use Amazon EC2 Dedicated Hosts.</p>
    pub fn set_hosts(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::HostInfoForCreate>>) -> Self {
        self.hosts = input;
        self
    }
    /// <p>The ESX hosts to add to the environment. Amazon EVS requires that you provide details for a minimum of 4 hosts during environment creation.</p>
    /// <p>For each host, you must provide the desired hostname, EC2 SSH keypair name, and EC2 instance type. Optionally, you can also provide a partition or cluster placement group to use, or use Amazon EC2 Dedicated Hosts.</p>
    pub fn get_hosts(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::HostInfoForCreate>> {
        &self.hosts
    }
    /// <p>The connectivity configuration for the environment. Amazon EVS requires that you specify two route server peer IDs. During environment creation, the route server endpoints peer with the NSX edges over the NSX uplink subnet, providing BGP-based dynamic routing for overlay networks.</p>
    /// This field is required.
    pub fn connectivity_info(mut self, input: crate::types::ConnectivityInfo) -> Self {
        self.connectivity_info = ::std::option::Option::Some(input);
        self
    }
    /// <p>The connectivity configuration for the environment. Amazon EVS requires that you specify two route server peer IDs. During environment creation, the route server endpoints peer with the NSX edges over the NSX uplink subnet, providing BGP-based dynamic routing for overlay networks.</p>
    pub fn set_connectivity_info(mut self, input: ::std::option::Option<crate::types::ConnectivityInfo>) -> Self {
        self.connectivity_info = input;
        self
    }
    /// <p>The connectivity configuration for the environment. Amazon EVS requires that you specify two route server peer IDs. During environment creation, the route server endpoints peer with the NSX edges over the NSX uplink subnet, providing BGP-based dynamic routing for overlay networks.</p>
    pub fn get_connectivity_info(&self) -> &::std::option::Option<crate::types::ConnectivityInfo> {
        &self.connectivity_info
    }
    /// <p>The DNS hostnames for the virtual machines that host the VCF management appliances. Amazon EVS requires that you provide DNS hostnames for the following appliances: vCenter, NSX Manager, SDDC Manager, and Cloud Builder.</p>
    /// This field is required.
    pub fn vcf_hostnames(mut self, input: crate::types::VcfHostnames) -> Self {
        self.vcf_hostnames = ::std::option::Option::Some(input);
        self
    }
    /// <p>The DNS hostnames for the virtual machines that host the VCF management appliances. Amazon EVS requires that you provide DNS hostnames for the following appliances: vCenter, NSX Manager, SDDC Manager, and Cloud Builder.</p>
    pub fn set_vcf_hostnames(mut self, input: ::std::option::Option<crate::types::VcfHostnames>) -> Self {
        self.vcf_hostnames = input;
        self
    }
    /// <p>The DNS hostnames for the virtual machines that host the VCF management appliances. Amazon EVS requires that you provide DNS hostnames for the following appliances: vCenter, NSX Manager, SDDC Manager, and Cloud Builder.</p>
    pub fn get_vcf_hostnames(&self) -> &::std::option::Option<crate::types::VcfHostnames> {
        &self.vcf_hostnames
    }
    /// <p>The Broadcom Site ID that is allocated to you as part of your electronic software delivery. This ID allows customer access to the Broadcom portal, and is provided to you by Broadcom at the close of your software contract or contract renewal. Amazon EVS uses the Broadcom Site ID that you provide to meet Broadcom VCF license usage reporting requirements for Amazon EVS.</p>
    /// This field is required.
    pub fn site_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.site_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The Broadcom Site ID that is allocated to you as part of your electronic software delivery. This ID allows customer access to the Broadcom portal, and is provided to you by Broadcom at the close of your software contract or contract renewal. Amazon EVS uses the Broadcom Site ID that you provide to meet Broadcom VCF license usage reporting requirements for Amazon EVS.</p>
    pub fn set_site_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.site_id = input;
        self
    }
    /// <p>The Broadcom Site ID that is allocated to you as part of your electronic software delivery. This ID allows customer access to the Broadcom portal, and is provided to you by Broadcom at the close of your software contract or contract renewal. Amazon EVS uses the Broadcom Site ID that you provide to meet Broadcom VCF license usage reporting requirements for Amazon EVS.</p>
    pub fn get_site_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.site_id
    }
    /// Consumes the builder and constructs a [`CreateEnvironmentInput`](crate::operation::create_environment::CreateEnvironmentInput).
    pub fn build(
        self,
    ) -> ::std::result::Result<crate::operation::create_environment::CreateEnvironmentInput, ::aws_smithy_types::error::operation::BuildError> {
        ::std::result::Result::Ok(crate::operation::create_environment::CreateEnvironmentInput {
            client_token: self.client_token,
            environment_name: self.environment_name,
            kms_key_id: self.kms_key_id,
            tags: self.tags,
            service_access_security_groups: self.service_access_security_groups,
            vpc_id: self.vpc_id,
            service_access_subnet_id: self.service_access_subnet_id,
            vcf_version: self.vcf_version,
            terms_accepted: self.terms_accepted,
            license_info: self.license_info,
            initial_vlans: self.initial_vlans,
            hosts: self.hosts,
            connectivity_info: self.connectivity_info,
            vcf_hostnames: self.vcf_hostnames,
            site_id: self.site_id,
        })
    }
}
