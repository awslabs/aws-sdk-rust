// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>The initial VLAN subnets for the environment. Amazon EVS VLAN subnets have a minimum CIDR block size of /28 and a maximum size of /24. Amazon EVS VLAN subnet CIDR blocks must not overlap with other subnets in the VPC.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct InitialVlans {
    /// <p>The host VMkernel management VLAN subnet. This VLAN subnet carries traffic for managing ESX hosts and communicating with VMware vCenter Server.</p>
    pub vmk_management: ::std::option::Option<crate::types::InitialVlanInfo>,
    /// <p>The VM management VLAN subnet. This VLAN subnet carries traffic for vSphere virtual machines.</p>
    pub vm_management: ::std::option::Option<crate::types::InitialVlanInfo>,
    /// <p>The vMotion VLAN subnet. This VLAN subnet carries traffic for vSphere vMotion.</p>
    pub v_motion: ::std::option::Option<crate::types::InitialVlanInfo>,
    /// <p>The vSAN VLAN subnet. This VLAN subnet carries the communication between ESX hosts to implement a vSAN shared storage pool.</p>
    pub v_san: ::std::option::Option<crate::types::InitialVlanInfo>,
    /// <p>The VTEP VLAN subnet. This VLAN subnet handles internal network traffic between virtual machines within a VCF instance.</p>
    pub v_tep: ::std::option::Option<crate::types::InitialVlanInfo>,
    /// <p>The edge VTEP VLAN subnet. This VLAN subnet manages traffic flowing between the internal network and external networks, including internet access and other site connections.</p>
    pub edge_v_tep: ::std::option::Option<crate::types::InitialVlanInfo>,
    /// <p>The NSX uplink VLAN subnet. This VLAN subnet allows connectivity to the NSX overlay network.</p>
    pub nsx_uplink: ::std::option::Option<crate::types::InitialVlanInfo>,
    /// <p>The HCX VLAN subnet. This VLAN subnet allows the HCX Interconnnect (IX) and HCX Network Extension (NE) to reach their peers and enable HCX Service Mesh creation.</p>
    /// <p>If you plan to use a public HCX VLAN subnet, the following requirements must be met:</p>
    /// <ul>
    /// <li>
    /// <p>Must have a /28 netmask and be allocated from the IPAM public pool. Required for HCX internet access configuration.</p></li>
    /// <li>
    /// <p>The HCX public VLAN CIDR block must be added to the VPC as a secondary CIDR block.</p></li>
    /// <li>
    /// <p>Must have at least two Elastic IP addresses to be allocated from the public IPAM pool for HCX components.</p></li>
    /// </ul>
    pub hcx: ::std::option::Option<crate::types::InitialVlanInfo>,
    /// <p>An additional VLAN subnet that can be used to extend VCF capabilities once configured. For example, you can configure an expansion VLAN subnet to use NSX Federation for centralized management and synchronization of multiple NSX deployments across different locations.</p>
    pub expansion_vlan1: ::std::option::Option<crate::types::InitialVlanInfo>,
    /// <p>An additional VLAN subnet that can be used to extend VCF capabilities once configured. For example, you can configure an expansion VLAN subnet to use NSX Federation for centralized management and synchronization of multiple NSX deployments across different locations.</p>
    pub expansion_vlan2: ::std::option::Option<crate::types::InitialVlanInfo>,
    /// <p>Determines if the HCX VLAN that Amazon EVS provisions is public or private.</p>
    pub is_hcx_public: bool,
    /// <p>A unique ID for a network access control list that the HCX VLAN uses. Required when <code>isHcxPublic</code> is set to <code>true</code>.</p>
    pub hcx_network_acl_id: ::std::option::Option<::std::string::String>,
}
impl InitialVlans {
    /// <p>The host VMkernel management VLAN subnet. This VLAN subnet carries traffic for managing ESX hosts and communicating with VMware vCenter Server.</p>
    pub fn vmk_management(&self) -> ::std::option::Option<&crate::types::InitialVlanInfo> {
        self.vmk_management.as_ref()
    }
    /// <p>The VM management VLAN subnet. This VLAN subnet carries traffic for vSphere virtual machines.</p>
    pub fn vm_management(&self) -> ::std::option::Option<&crate::types::InitialVlanInfo> {
        self.vm_management.as_ref()
    }
    /// <p>The vMotion VLAN subnet. This VLAN subnet carries traffic for vSphere vMotion.</p>
    pub fn v_motion(&self) -> ::std::option::Option<&crate::types::InitialVlanInfo> {
        self.v_motion.as_ref()
    }
    /// <p>The vSAN VLAN subnet. This VLAN subnet carries the communication between ESX hosts to implement a vSAN shared storage pool.</p>
    pub fn v_san(&self) -> ::std::option::Option<&crate::types::InitialVlanInfo> {
        self.v_san.as_ref()
    }
    /// <p>The VTEP VLAN subnet. This VLAN subnet handles internal network traffic between virtual machines within a VCF instance.</p>
    pub fn v_tep(&self) -> ::std::option::Option<&crate::types::InitialVlanInfo> {
        self.v_tep.as_ref()
    }
    /// <p>The edge VTEP VLAN subnet. This VLAN subnet manages traffic flowing between the internal network and external networks, including internet access and other site connections.</p>
    pub fn edge_v_tep(&self) -> ::std::option::Option<&crate::types::InitialVlanInfo> {
        self.edge_v_tep.as_ref()
    }
    /// <p>The NSX uplink VLAN subnet. This VLAN subnet allows connectivity to the NSX overlay network.</p>
    pub fn nsx_uplink(&self) -> ::std::option::Option<&crate::types::InitialVlanInfo> {
        self.nsx_uplink.as_ref()
    }
    /// <p>The HCX VLAN subnet. This VLAN subnet allows the HCX Interconnnect (IX) and HCX Network Extension (NE) to reach their peers and enable HCX Service Mesh creation.</p>
    /// <p>If you plan to use a public HCX VLAN subnet, the following requirements must be met:</p>
    /// <ul>
    /// <li>
    /// <p>Must have a /28 netmask and be allocated from the IPAM public pool. Required for HCX internet access configuration.</p></li>
    /// <li>
    /// <p>The HCX public VLAN CIDR block must be added to the VPC as a secondary CIDR block.</p></li>
    /// <li>
    /// <p>Must have at least two Elastic IP addresses to be allocated from the public IPAM pool for HCX components.</p></li>
    /// </ul>
    pub fn hcx(&self) -> ::std::option::Option<&crate::types::InitialVlanInfo> {
        self.hcx.as_ref()
    }
    /// <p>An additional VLAN subnet that can be used to extend VCF capabilities once configured. For example, you can configure an expansion VLAN subnet to use NSX Federation for centralized management and synchronization of multiple NSX deployments across different locations.</p>
    pub fn expansion_vlan1(&self) -> ::std::option::Option<&crate::types::InitialVlanInfo> {
        self.expansion_vlan1.as_ref()
    }
    /// <p>An additional VLAN subnet that can be used to extend VCF capabilities once configured. For example, you can configure an expansion VLAN subnet to use NSX Federation for centralized management and synchronization of multiple NSX deployments across different locations.</p>
    pub fn expansion_vlan2(&self) -> ::std::option::Option<&crate::types::InitialVlanInfo> {
        self.expansion_vlan2.as_ref()
    }
    /// <p>Determines if the HCX VLAN that Amazon EVS provisions is public or private.</p>
    pub fn is_hcx_public(&self) -> bool {
        self.is_hcx_public
    }
    /// <p>A unique ID for a network access control list that the HCX VLAN uses. Required when <code>isHcxPublic</code> is set to <code>true</code>.</p>
    pub fn hcx_network_acl_id(&self) -> ::std::option::Option<&str> {
        self.hcx_network_acl_id.as_deref()
    }
}
impl InitialVlans {
    /// Creates a new builder-style object to manufacture [`InitialVlans`](crate::types::InitialVlans).
    pub fn builder() -> crate::types::builders::InitialVlansBuilder {
        crate::types::builders::InitialVlansBuilder::default()
    }
}

/// A builder for [`InitialVlans`](crate::types::InitialVlans).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
#[non_exhaustive]
pub struct InitialVlansBuilder {
    pub(crate) vmk_management: ::std::option::Option<crate::types::InitialVlanInfo>,
    pub(crate) vm_management: ::std::option::Option<crate::types::InitialVlanInfo>,
    pub(crate) v_motion: ::std::option::Option<crate::types::InitialVlanInfo>,
    pub(crate) v_san: ::std::option::Option<crate::types::InitialVlanInfo>,
    pub(crate) v_tep: ::std::option::Option<crate::types::InitialVlanInfo>,
    pub(crate) edge_v_tep: ::std::option::Option<crate::types::InitialVlanInfo>,
    pub(crate) nsx_uplink: ::std::option::Option<crate::types::InitialVlanInfo>,
    pub(crate) hcx: ::std::option::Option<crate::types::InitialVlanInfo>,
    pub(crate) expansion_vlan1: ::std::option::Option<crate::types::InitialVlanInfo>,
    pub(crate) expansion_vlan2: ::std::option::Option<crate::types::InitialVlanInfo>,
    pub(crate) is_hcx_public: ::std::option::Option<bool>,
    pub(crate) hcx_network_acl_id: ::std::option::Option<::std::string::String>,
}
impl InitialVlansBuilder {
    /// <p>The host VMkernel management VLAN subnet. This VLAN subnet carries traffic for managing ESX hosts and communicating with VMware vCenter Server.</p>
    /// This field is required.
    pub fn vmk_management(mut self, input: crate::types::InitialVlanInfo) -> Self {
        self.vmk_management = ::std::option::Option::Some(input);
        self
    }
    /// <p>The host VMkernel management VLAN subnet. This VLAN subnet carries traffic for managing ESX hosts and communicating with VMware vCenter Server.</p>
    pub fn set_vmk_management(mut self, input: ::std::option::Option<crate::types::InitialVlanInfo>) -> Self {
        self.vmk_management = input;
        self
    }
    /// <p>The host VMkernel management VLAN subnet. This VLAN subnet carries traffic for managing ESX hosts and communicating with VMware vCenter Server.</p>
    pub fn get_vmk_management(&self) -> &::std::option::Option<crate::types::InitialVlanInfo> {
        &self.vmk_management
    }
    /// <p>The VM management VLAN subnet. This VLAN subnet carries traffic for vSphere virtual machines.</p>
    /// This field is required.
    pub fn vm_management(mut self, input: crate::types::InitialVlanInfo) -> Self {
        self.vm_management = ::std::option::Option::Some(input);
        self
    }
    /// <p>The VM management VLAN subnet. This VLAN subnet carries traffic for vSphere virtual machines.</p>
    pub fn set_vm_management(mut self, input: ::std::option::Option<crate::types::InitialVlanInfo>) -> Self {
        self.vm_management = input;
        self
    }
    /// <p>The VM management VLAN subnet. This VLAN subnet carries traffic for vSphere virtual machines.</p>
    pub fn get_vm_management(&self) -> &::std::option::Option<crate::types::InitialVlanInfo> {
        &self.vm_management
    }
    /// <p>The vMotion VLAN subnet. This VLAN subnet carries traffic for vSphere vMotion.</p>
    /// This field is required.
    pub fn v_motion(mut self, input: crate::types::InitialVlanInfo) -> Self {
        self.v_motion = ::std::option::Option::Some(input);
        self
    }
    /// <p>The vMotion VLAN subnet. This VLAN subnet carries traffic for vSphere vMotion.</p>
    pub fn set_v_motion(mut self, input: ::std::option::Option<crate::types::InitialVlanInfo>) -> Self {
        self.v_motion = input;
        self
    }
    /// <p>The vMotion VLAN subnet. This VLAN subnet carries traffic for vSphere vMotion.</p>
    pub fn get_v_motion(&self) -> &::std::option::Option<crate::types::InitialVlanInfo> {
        &self.v_motion
    }
    /// <p>The vSAN VLAN subnet. This VLAN subnet carries the communication between ESX hosts to implement a vSAN shared storage pool.</p>
    /// This field is required.
    pub fn v_san(mut self, input: crate::types::InitialVlanInfo) -> Self {
        self.v_san = ::std::option::Option::Some(input);
        self
    }
    /// <p>The vSAN VLAN subnet. This VLAN subnet carries the communication between ESX hosts to implement a vSAN shared storage pool.</p>
    pub fn set_v_san(mut self, input: ::std::option::Option<crate::types::InitialVlanInfo>) -> Self {
        self.v_san = input;
        self
    }
    /// <p>The vSAN VLAN subnet. This VLAN subnet carries the communication between ESX hosts to implement a vSAN shared storage pool.</p>
    pub fn get_v_san(&self) -> &::std::option::Option<crate::types::InitialVlanInfo> {
        &self.v_san
    }
    /// <p>The VTEP VLAN subnet. This VLAN subnet handles internal network traffic between virtual machines within a VCF instance.</p>
    /// This field is required.
    pub fn v_tep(mut self, input: crate::types::InitialVlanInfo) -> Self {
        self.v_tep = ::std::option::Option::Some(input);
        self
    }
    /// <p>The VTEP VLAN subnet. This VLAN subnet handles internal network traffic between virtual machines within a VCF instance.</p>
    pub fn set_v_tep(mut self, input: ::std::option::Option<crate::types::InitialVlanInfo>) -> Self {
        self.v_tep = input;
        self
    }
    /// <p>The VTEP VLAN subnet. This VLAN subnet handles internal network traffic between virtual machines within a VCF instance.</p>
    pub fn get_v_tep(&self) -> &::std::option::Option<crate::types::InitialVlanInfo> {
        &self.v_tep
    }
    /// <p>The edge VTEP VLAN subnet. This VLAN subnet manages traffic flowing between the internal network and external networks, including internet access and other site connections.</p>
    /// This field is required.
    pub fn edge_v_tep(mut self, input: crate::types::InitialVlanInfo) -> Self {
        self.edge_v_tep = ::std::option::Option::Some(input);
        self
    }
    /// <p>The edge VTEP VLAN subnet. This VLAN subnet manages traffic flowing between the internal network and external networks, including internet access and other site connections.</p>
    pub fn set_edge_v_tep(mut self, input: ::std::option::Option<crate::types::InitialVlanInfo>) -> Self {
        self.edge_v_tep = input;
        self
    }
    /// <p>The edge VTEP VLAN subnet. This VLAN subnet manages traffic flowing between the internal network and external networks, including internet access and other site connections.</p>
    pub fn get_edge_v_tep(&self) -> &::std::option::Option<crate::types::InitialVlanInfo> {
        &self.edge_v_tep
    }
    /// <p>The NSX uplink VLAN subnet. This VLAN subnet allows connectivity to the NSX overlay network.</p>
    /// This field is required.
    pub fn nsx_uplink(mut self, input: crate::types::InitialVlanInfo) -> Self {
        self.nsx_uplink = ::std::option::Option::Some(input);
        self
    }
    /// <p>The NSX uplink VLAN subnet. This VLAN subnet allows connectivity to the NSX overlay network.</p>
    pub fn set_nsx_uplink(mut self, input: ::std::option::Option<crate::types::InitialVlanInfo>) -> Self {
        self.nsx_uplink = input;
        self
    }
    /// <p>The NSX uplink VLAN subnet. This VLAN subnet allows connectivity to the NSX overlay network.</p>
    pub fn get_nsx_uplink(&self) -> &::std::option::Option<crate::types::InitialVlanInfo> {
        &self.nsx_uplink
    }
    /// <p>The HCX VLAN subnet. This VLAN subnet allows the HCX Interconnnect (IX) and HCX Network Extension (NE) to reach their peers and enable HCX Service Mesh creation.</p>
    /// <p>If you plan to use a public HCX VLAN subnet, the following requirements must be met:</p>
    /// <ul>
    /// <li>
    /// <p>Must have a /28 netmask and be allocated from the IPAM public pool. Required for HCX internet access configuration.</p></li>
    /// <li>
    /// <p>The HCX public VLAN CIDR block must be added to the VPC as a secondary CIDR block.</p></li>
    /// <li>
    /// <p>Must have at least two Elastic IP addresses to be allocated from the public IPAM pool for HCX components.</p></li>
    /// </ul>
    /// This field is required.
    pub fn hcx(mut self, input: crate::types::InitialVlanInfo) -> Self {
        self.hcx = ::std::option::Option::Some(input);
        self
    }
    /// <p>The HCX VLAN subnet. This VLAN subnet allows the HCX Interconnnect (IX) and HCX Network Extension (NE) to reach their peers and enable HCX Service Mesh creation.</p>
    /// <p>If you plan to use a public HCX VLAN subnet, the following requirements must be met:</p>
    /// <ul>
    /// <li>
    /// <p>Must have a /28 netmask and be allocated from the IPAM public pool. Required for HCX internet access configuration.</p></li>
    /// <li>
    /// <p>The HCX public VLAN CIDR block must be added to the VPC as a secondary CIDR block.</p></li>
    /// <li>
    /// <p>Must have at least two Elastic IP addresses to be allocated from the public IPAM pool for HCX components.</p></li>
    /// </ul>
    pub fn set_hcx(mut self, input: ::std::option::Option<crate::types::InitialVlanInfo>) -> Self {
        self.hcx = input;
        self
    }
    /// <p>The HCX VLAN subnet. This VLAN subnet allows the HCX Interconnnect (IX) and HCX Network Extension (NE) to reach their peers and enable HCX Service Mesh creation.</p>
    /// <p>If you plan to use a public HCX VLAN subnet, the following requirements must be met:</p>
    /// <ul>
    /// <li>
    /// <p>Must have a /28 netmask and be allocated from the IPAM public pool. Required for HCX internet access configuration.</p></li>
    /// <li>
    /// <p>The HCX public VLAN CIDR block must be added to the VPC as a secondary CIDR block.</p></li>
    /// <li>
    /// <p>Must have at least two Elastic IP addresses to be allocated from the public IPAM pool for HCX components.</p></li>
    /// </ul>
    pub fn get_hcx(&self) -> &::std::option::Option<crate::types::InitialVlanInfo> {
        &self.hcx
    }
    /// <p>An additional VLAN subnet that can be used to extend VCF capabilities once configured. For example, you can configure an expansion VLAN subnet to use NSX Federation for centralized management and synchronization of multiple NSX deployments across different locations.</p>
    /// This field is required.
    pub fn expansion_vlan1(mut self, input: crate::types::InitialVlanInfo) -> Self {
        self.expansion_vlan1 = ::std::option::Option::Some(input);
        self
    }
    /// <p>An additional VLAN subnet that can be used to extend VCF capabilities once configured. For example, you can configure an expansion VLAN subnet to use NSX Federation for centralized management and synchronization of multiple NSX deployments across different locations.</p>
    pub fn set_expansion_vlan1(mut self, input: ::std::option::Option<crate::types::InitialVlanInfo>) -> Self {
        self.expansion_vlan1 = input;
        self
    }
    /// <p>An additional VLAN subnet that can be used to extend VCF capabilities once configured. For example, you can configure an expansion VLAN subnet to use NSX Federation for centralized management and synchronization of multiple NSX deployments across different locations.</p>
    pub fn get_expansion_vlan1(&self) -> &::std::option::Option<crate::types::InitialVlanInfo> {
        &self.expansion_vlan1
    }
    /// <p>An additional VLAN subnet that can be used to extend VCF capabilities once configured. For example, you can configure an expansion VLAN subnet to use NSX Federation for centralized management and synchronization of multiple NSX deployments across different locations.</p>
    /// This field is required.
    pub fn expansion_vlan2(mut self, input: crate::types::InitialVlanInfo) -> Self {
        self.expansion_vlan2 = ::std::option::Option::Some(input);
        self
    }
    /// <p>An additional VLAN subnet that can be used to extend VCF capabilities once configured. For example, you can configure an expansion VLAN subnet to use NSX Federation for centralized management and synchronization of multiple NSX deployments across different locations.</p>
    pub fn set_expansion_vlan2(mut self, input: ::std::option::Option<crate::types::InitialVlanInfo>) -> Self {
        self.expansion_vlan2 = input;
        self
    }
    /// <p>An additional VLAN subnet that can be used to extend VCF capabilities once configured. For example, you can configure an expansion VLAN subnet to use NSX Federation for centralized management and synchronization of multiple NSX deployments across different locations.</p>
    pub fn get_expansion_vlan2(&self) -> &::std::option::Option<crate::types::InitialVlanInfo> {
        &self.expansion_vlan2
    }
    /// <p>Determines if the HCX VLAN that Amazon EVS provisions is public or private.</p>
    pub fn is_hcx_public(mut self, input: bool) -> Self {
        self.is_hcx_public = ::std::option::Option::Some(input);
        self
    }
    /// <p>Determines if the HCX VLAN that Amazon EVS provisions is public or private.</p>
    pub fn set_is_hcx_public(mut self, input: ::std::option::Option<bool>) -> Self {
        self.is_hcx_public = input;
        self
    }
    /// <p>Determines if the HCX VLAN that Amazon EVS provisions is public or private.</p>
    pub fn get_is_hcx_public(&self) -> &::std::option::Option<bool> {
        &self.is_hcx_public
    }
    /// <p>A unique ID for a network access control list that the HCX VLAN uses. Required when <code>isHcxPublic</code> is set to <code>true</code>.</p>
    pub fn hcx_network_acl_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.hcx_network_acl_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>A unique ID for a network access control list that the HCX VLAN uses. Required when <code>isHcxPublic</code> is set to <code>true</code>.</p>
    pub fn set_hcx_network_acl_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.hcx_network_acl_id = input;
        self
    }
    /// <p>A unique ID for a network access control list that the HCX VLAN uses. Required when <code>isHcxPublic</code> is set to <code>true</code>.</p>
    pub fn get_hcx_network_acl_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.hcx_network_acl_id
    }
    /// Consumes the builder and constructs a [`InitialVlans`](crate::types::InitialVlans).
    pub fn build(self) -> crate::types::InitialVlans {
        crate::types::InitialVlans {
            vmk_management: self.vmk_management,
            vm_management: self.vm_management,
            v_motion: self.v_motion,
            v_san: self.v_san,
            v_tep: self.v_tep,
            edge_v_tep: self.edge_v_tep,
            nsx_uplink: self.nsx_uplink,
            hcx: self.hcx,
            expansion_vlan1: self.expansion_vlan1,
            expansion_vlan2: self.expansion_vlan2,
            is_hcx_public: self.is_hcx_public.unwrap_or_default(),
            hcx_network_acl_id: self.hcx_network_acl_id,
        }
    }
}
