// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// <p>Creates an Amazon Connect Wisdom assistant.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateAssistant {
    _private: (),
}
impl CreateAssistant {
    /// Creates a new builder-style object to manufacture [`CreateAssistantInput`](crate::input::CreateAssistantInput)
    pub fn builder() -> crate::input::create_assistant_input::Builder {
        crate::input::create_assistant_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateAssistant {
    type Output = std::result::Result<
        crate::output::CreateAssistantOutput,
        crate::error::CreateAssistantError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_assistant_error(response)
        } else {
            crate::operation_deser::parse_create_assistant_response(response)
        }
    }
}

/// <p>Creates an association between an Amazon Connect Wisdom assistant and another resource. Currently, the
/// only supported association is with a knowledge base. An assistant can have only a single
/// association.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateAssistantAssociation {
    _private: (),
}
impl CreateAssistantAssociation {
    /// Creates a new builder-style object to manufacture [`CreateAssistantAssociationInput`](crate::input::CreateAssistantAssociationInput)
    pub fn builder() -> crate::input::create_assistant_association_input::Builder {
        crate::input::create_assistant_association_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateAssistantAssociation {
    type Output = std::result::Result<
        crate::output::CreateAssistantAssociationOutput,
        crate::error::CreateAssistantAssociationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_assistant_association_error(response)
        } else {
            crate::operation_deser::parse_create_assistant_association_response(response)
        }
    }
}

/// <p>Creates Wisdom content. Before to calling this API, use <a href="https://docs.aws.amazon.com/wisdom/latest/APIReference/API_StartContentUpload.html">StartContentUpload</a> to
/// upload an asset.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateContent {
    _private: (),
}
impl CreateContent {
    /// Creates a new builder-style object to manufacture [`CreateContentInput`](crate::input::CreateContentInput)
    pub fn builder() -> crate::input::create_content_input::Builder {
        crate::input::create_content_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateContent {
    type Output =
        std::result::Result<crate::output::CreateContentOutput, crate::error::CreateContentError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_content_error(response)
        } else {
            crate::operation_deser::parse_create_content_response(response)
        }
    }
}

/// <p>Creates a knowledge base.</p>
/// <note>
/// <p>When using this API, you cannot reuse <a href="https://docs.aws.amazon.com/appintegrations/latest/APIReference/Welcome.html">Amazon AppIntegrations</a>
/// DataIntegrations with external knowledge bases such as Salesforce and ServiceNow. If you do,
/// you'll get an <code>InvalidRequestException</code> error. </p>
/// <p>For example, you're programmatically managing your external knowledge base, and you want
/// to add or remove one of the fields that is being ingested from Salesforce. Do the
/// following:</p>
/// <ol>
/// <li>
/// <p>Call <a href="https://docs.aws.amazon.com/wisdom/latest/APIReference/API_DeleteKnowledgeBase.html">DeleteKnowledgeBase</a>.</p>
/// </li>
/// <li>
/// <p>Call <a href="https://docs.aws.amazon.com/appintegrations/latest/APIReference/API_DeleteDataIntegration.html">DeleteDataIntegration</a>.</p>
/// </li>
/// <li>
/// <p>Call <a href="https://docs.aws.amazon.com/appintegrations/latest/APIReference/API_CreateDataIntegration.html">CreateDataIntegration</a> to recreate the DataIntegration or a create different
/// one.</p>
/// </li>
/// <li>
/// <p>Call CreateKnowledgeBase.</p>
/// </li>
/// </ol>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateKnowledgeBase {
    _private: (),
}
impl CreateKnowledgeBase {
    /// Creates a new builder-style object to manufacture [`CreateKnowledgeBaseInput`](crate::input::CreateKnowledgeBaseInput)
    pub fn builder() -> crate::input::create_knowledge_base_input::Builder {
        crate::input::create_knowledge_base_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateKnowledgeBase {
    type Output = std::result::Result<
        crate::output::CreateKnowledgeBaseOutput,
        crate::error::CreateKnowledgeBaseError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_knowledge_base_error(response)
        } else {
            crate::operation_deser::parse_create_knowledge_base_response(response)
        }
    }
}

/// <p>Creates a session. A session is a contextual container used for generating
/// recommendations. Amazon Connect creates a new Wisdom session for each contact on which Wisdom is
/// enabled.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateSession {
    _private: (),
}
impl CreateSession {
    /// Creates a new builder-style object to manufacture [`CreateSessionInput`](crate::input::CreateSessionInput)
    pub fn builder() -> crate::input::create_session_input::Builder {
        crate::input::create_session_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateSession {
    type Output =
        std::result::Result<crate::output::CreateSessionOutput, crate::error::CreateSessionError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_session_error(response)
        } else {
            crate::operation_deser::parse_create_session_response(response)
        }
    }
}

/// <p>Deletes an assistant.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteAssistant {
    _private: (),
}
impl DeleteAssistant {
    /// Creates a new builder-style object to manufacture [`DeleteAssistantInput`](crate::input::DeleteAssistantInput)
    pub fn builder() -> crate::input::delete_assistant_input::Builder {
        crate::input::delete_assistant_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteAssistant {
    type Output = std::result::Result<
        crate::output::DeleteAssistantOutput,
        crate::error::DeleteAssistantError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 204 {
            crate::operation_deser::parse_delete_assistant_error(response)
        } else {
            crate::operation_deser::parse_delete_assistant_response(response)
        }
    }
}

/// <p>Deletes an assistant association.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteAssistantAssociation {
    _private: (),
}
impl DeleteAssistantAssociation {
    /// Creates a new builder-style object to manufacture [`DeleteAssistantAssociationInput`](crate::input::DeleteAssistantAssociationInput)
    pub fn builder() -> crate::input::delete_assistant_association_input::Builder {
        crate::input::delete_assistant_association_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteAssistantAssociation {
    type Output = std::result::Result<
        crate::output::DeleteAssistantAssociationOutput,
        crate::error::DeleteAssistantAssociationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 204 {
            crate::operation_deser::parse_delete_assistant_association_error(response)
        } else {
            crate::operation_deser::parse_delete_assistant_association_response(response)
        }
    }
}

/// <p>Deletes the content.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteContent {
    _private: (),
}
impl DeleteContent {
    /// Creates a new builder-style object to manufacture [`DeleteContentInput`](crate::input::DeleteContentInput)
    pub fn builder() -> crate::input::delete_content_input::Builder {
        crate::input::delete_content_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteContent {
    type Output =
        std::result::Result<crate::output::DeleteContentOutput, crate::error::DeleteContentError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 204 {
            crate::operation_deser::parse_delete_content_error(response)
        } else {
            crate::operation_deser::parse_delete_content_response(response)
        }
    }
}

/// <p>Deletes the knowledge base.</p>
/// <note>
/// <p>When you use this API to delete an external knowledge base such as Salesforce or
/// ServiceNow, you must also delete the <a href="https://docs.aws.amazon.com/appintegrations/latest/APIReference/Welcome.html">Amazon AppIntegrations</a> DataIntegration.
/// This is because you can't reuse the DataIntegration after it's been associated with an
/// external knowledge base. However, you can delete and recreate it. See <a href="https://docs.aws.amazon.com/appintegrations/latest/APIReference/API_DeleteDataIntegration.html">DeleteDataIntegration</a> and <a href="https://docs.aws.amazon.com/appintegrations/latest/APIReference/API_CreateDataIntegration.html">CreateDataIntegration</a> in the <i>Amazon AppIntegrations API
/// Reference</i>.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteKnowledgeBase {
    _private: (),
}
impl DeleteKnowledgeBase {
    /// Creates a new builder-style object to manufacture [`DeleteKnowledgeBaseInput`](crate::input::DeleteKnowledgeBaseInput)
    pub fn builder() -> crate::input::delete_knowledge_base_input::Builder {
        crate::input::delete_knowledge_base_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteKnowledgeBase {
    type Output = std::result::Result<
        crate::output::DeleteKnowledgeBaseOutput,
        crate::error::DeleteKnowledgeBaseError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 204 {
            crate::operation_deser::parse_delete_knowledge_base_error(response)
        } else {
            crate::operation_deser::parse_delete_knowledge_base_response(response)
        }
    }
}

/// <p>Retrieves information about an assistant.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetAssistant {
    _private: (),
}
impl GetAssistant {
    /// Creates a new builder-style object to manufacture [`GetAssistantInput`](crate::input::GetAssistantInput)
    pub fn builder() -> crate::input::get_assistant_input::Builder {
        crate::input::get_assistant_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetAssistant {
    type Output =
        std::result::Result<crate::output::GetAssistantOutput, crate::error::GetAssistantError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_assistant_error(response)
        } else {
            crate::operation_deser::parse_get_assistant_response(response)
        }
    }
}

/// <p>Retrieves information about an assistant association.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetAssistantAssociation {
    _private: (),
}
impl GetAssistantAssociation {
    /// Creates a new builder-style object to manufacture [`GetAssistantAssociationInput`](crate::input::GetAssistantAssociationInput)
    pub fn builder() -> crate::input::get_assistant_association_input::Builder {
        crate::input::get_assistant_association_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetAssistantAssociation {
    type Output = std::result::Result<
        crate::output::GetAssistantAssociationOutput,
        crate::error::GetAssistantAssociationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_assistant_association_error(response)
        } else {
            crate::operation_deser::parse_get_assistant_association_response(response)
        }
    }
}

/// <p>Retrieves content, including a pre-signed URL to download the content.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetContent {
    _private: (),
}
impl GetContent {
    /// Creates a new builder-style object to manufacture [`GetContentInput`](crate::input::GetContentInput)
    pub fn builder() -> crate::input::get_content_input::Builder {
        crate::input::get_content_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetContent {
    type Output =
        std::result::Result<crate::output::GetContentOutput, crate::error::GetContentError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_content_error(response)
        } else {
            crate::operation_deser::parse_get_content_response(response)
        }
    }
}

/// <p>Retrieves summary information about the content.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetContentSummary {
    _private: (),
}
impl GetContentSummary {
    /// Creates a new builder-style object to manufacture [`GetContentSummaryInput`](crate::input::GetContentSummaryInput)
    pub fn builder() -> crate::input::get_content_summary_input::Builder {
        crate::input::get_content_summary_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetContentSummary {
    type Output = std::result::Result<
        crate::output::GetContentSummaryOutput,
        crate::error::GetContentSummaryError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_content_summary_error(response)
        } else {
            crate::operation_deser::parse_get_content_summary_response(response)
        }
    }
}

/// <p>Retrieves information about the knowledge base.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetKnowledgeBase {
    _private: (),
}
impl GetKnowledgeBase {
    /// Creates a new builder-style object to manufacture [`GetKnowledgeBaseInput`](crate::input::GetKnowledgeBaseInput)
    pub fn builder() -> crate::input::get_knowledge_base_input::Builder {
        crate::input::get_knowledge_base_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetKnowledgeBase {
    type Output = std::result::Result<
        crate::output::GetKnowledgeBaseOutput,
        crate::error::GetKnowledgeBaseError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_knowledge_base_error(response)
        } else {
            crate::operation_deser::parse_get_knowledge_base_response(response)
        }
    }
}

/// <p>Retrieves recommendations for the specified session. To avoid retrieving the same
/// recommendations in subsequent calls, use <a href="https://docs.aws.amazon.com/wisdom/latest/APIReference/API_NotifyRecommendationsReceived.html">NotifyRecommendationsReceived</a>. This API supports long-polling behavior with the
/// <code>waitTimeSeconds</code> parameter. Short poll is the default behavior and only returns
/// recommendations already available. To perform a manual query against an assistant, use <a href="https://docs.aws.amazon.com/wisdom/latest/APIReference/API_QueryAssistant.html">QueryAssistant</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetRecommendations {
    _private: (),
}
impl GetRecommendations {
    /// Creates a new builder-style object to manufacture [`GetRecommendationsInput`](crate::input::GetRecommendationsInput)
    pub fn builder() -> crate::input::get_recommendations_input::Builder {
        crate::input::get_recommendations_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetRecommendations {
    type Output = std::result::Result<
        crate::output::GetRecommendationsOutput,
        crate::error::GetRecommendationsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_recommendations_error(response)
        } else {
            crate::operation_deser::parse_get_recommendations_response(response)
        }
    }
}

/// <p>Retrieves information for a specified session.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetSession {
    _private: (),
}
impl GetSession {
    /// Creates a new builder-style object to manufacture [`GetSessionInput`](crate::input::GetSessionInput)
    pub fn builder() -> crate::input::get_session_input::Builder {
        crate::input::get_session_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetSession {
    type Output =
        std::result::Result<crate::output::GetSessionOutput, crate::error::GetSessionError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_session_error(response)
        } else {
            crate::operation_deser::parse_get_session_response(response)
        }
    }
}

/// <p>Lists information about assistant associations.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListAssistantAssociations {
    _private: (),
}
impl ListAssistantAssociations {
    /// Creates a new builder-style object to manufacture [`ListAssistantAssociationsInput`](crate::input::ListAssistantAssociationsInput)
    pub fn builder() -> crate::input::list_assistant_associations_input::Builder {
        crate::input::list_assistant_associations_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListAssistantAssociations {
    type Output = std::result::Result<
        crate::output::ListAssistantAssociationsOutput,
        crate::error::ListAssistantAssociationsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_assistant_associations_error(response)
        } else {
            crate::operation_deser::parse_list_assistant_associations_response(response)
        }
    }
}

/// <p>Lists information about assistants.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListAssistants {
    _private: (),
}
impl ListAssistants {
    /// Creates a new builder-style object to manufacture [`ListAssistantsInput`](crate::input::ListAssistantsInput)
    pub fn builder() -> crate::input::list_assistants_input::Builder {
        crate::input::list_assistants_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListAssistants {
    type Output =
        std::result::Result<crate::output::ListAssistantsOutput, crate::error::ListAssistantsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_assistants_error(response)
        } else {
            crate::operation_deser::parse_list_assistants_response(response)
        }
    }
}

/// <p>Lists the content.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListContents {
    _private: (),
}
impl ListContents {
    /// Creates a new builder-style object to manufacture [`ListContentsInput`](crate::input::ListContentsInput)
    pub fn builder() -> crate::input::list_contents_input::Builder {
        crate::input::list_contents_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListContents {
    type Output =
        std::result::Result<crate::output::ListContentsOutput, crate::error::ListContentsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_contents_error(response)
        } else {
            crate::operation_deser::parse_list_contents_response(response)
        }
    }
}

/// <p>Lists the knowledge bases.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListKnowledgeBases {
    _private: (),
}
impl ListKnowledgeBases {
    /// Creates a new builder-style object to manufacture [`ListKnowledgeBasesInput`](crate::input::ListKnowledgeBasesInput)
    pub fn builder() -> crate::input::list_knowledge_bases_input::Builder {
        crate::input::list_knowledge_bases_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListKnowledgeBases {
    type Output = std::result::Result<
        crate::output::ListKnowledgeBasesOutput,
        crate::error::ListKnowledgeBasesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_knowledge_bases_error(response)
        } else {
            crate::operation_deser::parse_list_knowledge_bases_response(response)
        }
    }
}

/// <p>Lists the tags for the specified resource.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListTagsForResource {
    _private: (),
}
impl ListTagsForResource {
    /// Creates a new builder-style object to manufacture [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput)
    pub fn builder() -> crate::input::list_tags_for_resource_input::Builder {
        crate::input::list_tags_for_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListTagsForResource {
    type Output = std::result::Result<
        crate::output::ListTagsForResourceOutput,
        crate::error::ListTagsForResourceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_tags_for_resource_error(response)
        } else {
            crate::operation_deser::parse_list_tags_for_resource_response(response)
        }
    }
}

/// <p>Removes the specified recommendations from the specified assistant's queue of newly
/// available recommendations. You can use this API in conjunction with <a href="https://docs.aws.amazon.com/wisdom/latest/APIReference/API_GetRecommendations.html">GetRecommendations</a> and a <code>waitTimeSeconds</code> input for long-polling
/// behavior and avoiding duplicate recommendations.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct NotifyRecommendationsReceived {
    _private: (),
}
impl NotifyRecommendationsReceived {
    /// Creates a new builder-style object to manufacture [`NotifyRecommendationsReceivedInput`](crate::input::NotifyRecommendationsReceivedInput)
    pub fn builder() -> crate::input::notify_recommendations_received_input::Builder {
        crate::input::notify_recommendations_received_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for NotifyRecommendationsReceived {
    type Output = std::result::Result<
        crate::output::NotifyRecommendationsReceivedOutput,
        crate::error::NotifyRecommendationsReceivedError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_notify_recommendations_received_error(response)
        } else {
            crate::operation_deser::parse_notify_recommendations_received_response(response)
        }
    }
}

/// <p>Performs a manual search against the specified assistant. To retrieve recommendations for
/// an assistant, use <a href="https://docs.aws.amazon.com/wisdom/latest/APIReference/API_GetRecommendations.html">GetRecommendations</a>.
/// </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct QueryAssistant {
    _private: (),
}
impl QueryAssistant {
    /// Creates a new builder-style object to manufacture [`QueryAssistantInput`](crate::input::QueryAssistantInput)
    pub fn builder() -> crate::input::query_assistant_input::Builder {
        crate::input::query_assistant_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for QueryAssistant {
    type Output =
        std::result::Result<crate::output::QueryAssistantOutput, crate::error::QueryAssistantError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_query_assistant_error(response)
        } else {
            crate::operation_deser::parse_query_assistant_response(response)
        }
    }
}

/// <p>Removes a URI template from a knowledge base.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct RemoveKnowledgeBaseTemplateUri {
    _private: (),
}
impl RemoveKnowledgeBaseTemplateUri {
    /// Creates a new builder-style object to manufacture [`RemoveKnowledgeBaseTemplateUriInput`](crate::input::RemoveKnowledgeBaseTemplateUriInput)
    pub fn builder() -> crate::input::remove_knowledge_base_template_uri_input::Builder {
        crate::input::remove_knowledge_base_template_uri_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for RemoveKnowledgeBaseTemplateUri {
    type Output = std::result::Result<
        crate::output::RemoveKnowledgeBaseTemplateUriOutput,
        crate::error::RemoveKnowledgeBaseTemplateUriError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 204 {
            crate::operation_deser::parse_remove_knowledge_base_template_uri_error(response)
        } else {
            crate::operation_deser::parse_remove_knowledge_base_template_uri_response(response)
        }
    }
}

/// <p>Searches for content in a specified knowledge base. Can be used to get a specific content
/// resource by its name.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct SearchContent {
    _private: (),
}
impl SearchContent {
    /// Creates a new builder-style object to manufacture [`SearchContentInput`](crate::input::SearchContentInput)
    pub fn builder() -> crate::input::search_content_input::Builder {
        crate::input::search_content_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for SearchContent {
    type Output =
        std::result::Result<crate::output::SearchContentOutput, crate::error::SearchContentError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_search_content_error(response)
        } else {
            crate::operation_deser::parse_search_content_response(response)
        }
    }
}

/// <p>Searches for sessions.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct SearchSessions {
    _private: (),
}
impl SearchSessions {
    /// Creates a new builder-style object to manufacture [`SearchSessionsInput`](crate::input::SearchSessionsInput)
    pub fn builder() -> crate::input::search_sessions_input::Builder {
        crate::input::search_sessions_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for SearchSessions {
    type Output =
        std::result::Result<crate::output::SearchSessionsOutput, crate::error::SearchSessionsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_search_sessions_error(response)
        } else {
            crate::operation_deser::parse_search_sessions_response(response)
        }
    }
}

/// <p>Get a URL to upload content to a knowledge base. To upload content, first make a PUT
/// request to the returned URL with your file, making sure to include the required headers. Then
/// use <a href="https://docs.aws.amazon.com/wisdom/latest/APIReference/API_CreateContent.html">CreateContent</a> to finalize the content creation process or <a href="https://docs.aws.amazon.com/wisdom/latest/APIReference/API_UpdateContent.html">UpdateContent</a> to modify an existing resource. You can only upload content to a
/// knowledge base of type CUSTOM.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct StartContentUpload {
    _private: (),
}
impl StartContentUpload {
    /// Creates a new builder-style object to manufacture [`StartContentUploadInput`](crate::input::StartContentUploadInput)
    pub fn builder() -> crate::input::start_content_upload_input::Builder {
        crate::input::start_content_upload_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for StartContentUpload {
    type Output = std::result::Result<
        crate::output::StartContentUploadOutput,
        crate::error::StartContentUploadError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_start_content_upload_error(response)
        } else {
            crate::operation_deser::parse_start_content_upload_response(response)
        }
    }
}

/// <p>Adds the specified tags to the specified resource.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct TagResource {
    _private: (),
}
impl TagResource {
    /// Creates a new builder-style object to manufacture [`TagResourceInput`](crate::input::TagResourceInput)
    pub fn builder() -> crate::input::tag_resource_input::Builder {
        crate::input::tag_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for TagResource {
    type Output =
        std::result::Result<crate::output::TagResourceOutput, crate::error::TagResourceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_tag_resource_error(response)
        } else {
            crate::operation_deser::parse_tag_resource_response(response)
        }
    }
}

/// <p>Removes the specified tags from the specified resource.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UntagResource {
    _private: (),
}
impl UntagResource {
    /// Creates a new builder-style object to manufacture [`UntagResourceInput`](crate::input::UntagResourceInput)
    pub fn builder() -> crate::input::untag_resource_input::Builder {
        crate::input::untag_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UntagResource {
    type Output =
        std::result::Result<crate::output::UntagResourceOutput, crate::error::UntagResourceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_untag_resource_error(response)
        } else {
            crate::operation_deser::parse_untag_resource_response(response)
        }
    }
}

/// <p>Updates information about the content.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateContent {
    _private: (),
}
impl UpdateContent {
    /// Creates a new builder-style object to manufacture [`UpdateContentInput`](crate::input::UpdateContentInput)
    pub fn builder() -> crate::input::update_content_input::Builder {
        crate::input::update_content_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateContent {
    type Output =
        std::result::Result<crate::output::UpdateContentOutput, crate::error::UpdateContentError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_content_error(response)
        } else {
            crate::operation_deser::parse_update_content_response(response)
        }
    }
}

/// <p>Updates the template URI of a knowledge base. This is only supported for knowledge bases
/// of type EXTERNAL. Include a single variable in <code>${variable}</code> format; this
/// interpolated by Wisdom using ingested content. For example, if you ingest a Salesforce
/// article, it has an <code>Id</code> value, and you can set the template URI to
/// <code>https://myInstanceName.lightning.force.com/lightning/r/Knowledge__kav/*${Id}*/view</code>.
/// </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateKnowledgeBaseTemplateUri {
    _private: (),
}
impl UpdateKnowledgeBaseTemplateUri {
    /// Creates a new builder-style object to manufacture [`UpdateKnowledgeBaseTemplateUriInput`](crate::input::UpdateKnowledgeBaseTemplateUriInput)
    pub fn builder() -> crate::input::update_knowledge_base_template_uri_input::Builder {
        crate::input::update_knowledge_base_template_uri_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateKnowledgeBaseTemplateUri {
    type Output = std::result::Result<
        crate::output::UpdateKnowledgeBaseTemplateUriOutput,
        crate::error::UpdateKnowledgeBaseTemplateUriError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_knowledge_base_template_uri_error(response)
        } else {
            crate::operation_deser::parse_update_knowledge_base_template_uri_response(response)
        }
    }
}
