// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Summary information about the content.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct ContentSummary {
    /// <p>The Amazon Resource Name (ARN) of the content.</p>
    pub content_arn: ::std::string::String,
    /// <p>The identifier of the content.</p>
    pub content_id: ::std::string::String,
    /// <p>The Amazon Resource Name (ARN) of the knowledge base.</p>
    pub knowledge_base_arn: ::std::string::String,
    /// <p>The identifier of the knowledge base.</p>
    pub knowledge_base_id: ::std::string::String,
    /// <p>The name of the content.</p>
    pub name: ::std::string::String,
    /// <p>The identifier of the revision of the content.</p>
    pub revision_id: ::std::string::String,
    /// <p>The title of the content.</p>
    pub title: ::std::string::String,
    /// <p>The media type of the content.</p>
    pub content_type: ::std::string::String,
    /// <p>The status of the content.</p>
    pub status: crate::types::ContentStatus,
    /// <p>A key/value map to store attributes without affecting tagging or recommendations. For example, when synchronizing data between an external system and Wisdom, you can store an external version identifier as metadata to utilize for determining drift.</p>
    pub metadata: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    /// <p>The tags used to organize, track, or control access for this resource.</p>
    pub tags: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>,
}
impl ContentSummary {
    /// <p>The Amazon Resource Name (ARN) of the content.</p>
    pub fn content_arn(&self) -> &str {
        use std::ops::Deref;
        self.content_arn.deref()
    }
    /// <p>The identifier of the content.</p>
    pub fn content_id(&self) -> &str {
        use std::ops::Deref;
        self.content_id.deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the knowledge base.</p>
    pub fn knowledge_base_arn(&self) -> &str {
        use std::ops::Deref;
        self.knowledge_base_arn.deref()
    }
    /// <p>The identifier of the knowledge base.</p>
    pub fn knowledge_base_id(&self) -> &str {
        use std::ops::Deref;
        self.knowledge_base_id.deref()
    }
    /// <p>The name of the content.</p>
    pub fn name(&self) -> &str {
        use std::ops::Deref;
        self.name.deref()
    }
    /// <p>The identifier of the revision of the content.</p>
    pub fn revision_id(&self) -> &str {
        use std::ops::Deref;
        self.revision_id.deref()
    }
    /// <p>The title of the content.</p>
    pub fn title(&self) -> &str {
        use std::ops::Deref;
        self.title.deref()
    }
    /// <p>The media type of the content.</p>
    pub fn content_type(&self) -> &str {
        use std::ops::Deref;
        self.content_type.deref()
    }
    /// <p>The status of the content.</p>
    pub fn status(&self) -> &crate::types::ContentStatus {
        &self.status
    }
    /// <p>A key/value map to store attributes without affecting tagging or recommendations. For example, when synchronizing data between an external system and Wisdom, you can store an external version identifier as metadata to utilize for determining drift.</p>
    pub fn metadata(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.metadata
    }
    /// <p>The tags used to organize, track, or control access for this resource.</p>
    pub fn tags(&self) -> ::std::option::Option<&::std::collections::HashMap<::std::string::String, ::std::string::String>> {
        self.tags.as_ref()
    }
}
impl ContentSummary {
    /// Creates a new builder-style object to manufacture [`ContentSummary`](crate::types::ContentSummary).
    pub fn builder() -> crate::types::builders::ContentSummaryBuilder {
        crate::types::builders::ContentSummaryBuilder::default()
    }
}

/// A builder for [`ContentSummary`](crate::types::ContentSummary).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
pub struct ContentSummaryBuilder {
    pub(crate) content_arn: ::std::option::Option<::std::string::String>,
    pub(crate) content_id: ::std::option::Option<::std::string::String>,
    pub(crate) knowledge_base_arn: ::std::option::Option<::std::string::String>,
    pub(crate) knowledge_base_id: ::std::option::Option<::std::string::String>,
    pub(crate) name: ::std::option::Option<::std::string::String>,
    pub(crate) revision_id: ::std::option::Option<::std::string::String>,
    pub(crate) title: ::std::option::Option<::std::string::String>,
    pub(crate) content_type: ::std::option::Option<::std::string::String>,
    pub(crate) status: ::std::option::Option<crate::types::ContentStatus>,
    pub(crate) metadata: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>,
    pub(crate) tags: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>,
}
impl ContentSummaryBuilder {
    /// <p>The Amazon Resource Name (ARN) of the content.</p>
    /// This field is required.
    pub fn content_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.content_arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the content.</p>
    pub fn set_content_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.content_arn = input;
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the content.</p>
    pub fn get_content_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.content_arn
    }
    /// <p>The identifier of the content.</p>
    /// This field is required.
    pub fn content_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.content_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The identifier of the content.</p>
    pub fn set_content_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.content_id = input;
        self
    }
    /// <p>The identifier of the content.</p>
    pub fn get_content_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.content_id
    }
    /// <p>The Amazon Resource Name (ARN) of the knowledge base.</p>
    /// This field is required.
    pub fn knowledge_base_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.knowledge_base_arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the knowledge base.</p>
    pub fn set_knowledge_base_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.knowledge_base_arn = input;
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the knowledge base.</p>
    pub fn get_knowledge_base_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.knowledge_base_arn
    }
    /// <p>The identifier of the knowledge base.</p>
    /// This field is required.
    pub fn knowledge_base_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.knowledge_base_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The identifier of the knowledge base.</p>
    pub fn set_knowledge_base_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.knowledge_base_id = input;
        self
    }
    /// <p>The identifier of the knowledge base.</p>
    pub fn get_knowledge_base_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.knowledge_base_id
    }
    /// <p>The name of the content.</p>
    /// This field is required.
    pub fn name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The name of the content.</p>
    pub fn set_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.name = input;
        self
    }
    /// <p>The name of the content.</p>
    pub fn get_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.name
    }
    /// <p>The identifier of the revision of the content.</p>
    /// This field is required.
    pub fn revision_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.revision_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The identifier of the revision of the content.</p>
    pub fn set_revision_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.revision_id = input;
        self
    }
    /// <p>The identifier of the revision of the content.</p>
    pub fn get_revision_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.revision_id
    }
    /// <p>The title of the content.</p>
    /// This field is required.
    pub fn title(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.title = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The title of the content.</p>
    pub fn set_title(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.title = input;
        self
    }
    /// <p>The title of the content.</p>
    pub fn get_title(&self) -> &::std::option::Option<::std::string::String> {
        &self.title
    }
    /// <p>The media type of the content.</p>
    /// This field is required.
    pub fn content_type(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.content_type = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The media type of the content.</p>
    pub fn set_content_type(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.content_type = input;
        self
    }
    /// <p>The media type of the content.</p>
    pub fn get_content_type(&self) -> &::std::option::Option<::std::string::String> {
        &self.content_type
    }
    /// <p>The status of the content.</p>
    /// This field is required.
    pub fn status(mut self, input: crate::types::ContentStatus) -> Self {
        self.status = ::std::option::Option::Some(input);
        self
    }
    /// <p>The status of the content.</p>
    pub fn set_status(mut self, input: ::std::option::Option<crate::types::ContentStatus>) -> Self {
        self.status = input;
        self
    }
    /// <p>The status of the content.</p>
    pub fn get_status(&self) -> &::std::option::Option<crate::types::ContentStatus> {
        &self.status
    }
    /// Adds a key-value pair to `metadata`.
    ///
    /// To override the contents of this collection use [`set_metadata`](Self::set_metadata).
    ///
    /// <p>A key/value map to store attributes without affecting tagging or recommendations. For example, when synchronizing data between an external system and Wisdom, you can store an external version identifier as metadata to utilize for determining drift.</p>
    pub fn metadata(mut self, k: impl ::std::convert::Into<::std::string::String>, v: impl ::std::convert::Into<::std::string::String>) -> Self {
        let mut hash_map = self.metadata.unwrap_or_default();
        hash_map.insert(k.into(), v.into());
        self.metadata = ::std::option::Option::Some(hash_map);
        self
    }
    /// <p>A key/value map to store attributes without affecting tagging or recommendations. For example, when synchronizing data between an external system and Wisdom, you can store an external version identifier as metadata to utilize for determining drift.</p>
    pub fn set_metadata(mut self, input: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>) -> Self {
        self.metadata = input;
        self
    }
    /// <p>A key/value map to store attributes without affecting tagging or recommendations. For example, when synchronizing data between an external system and Wisdom, you can store an external version identifier as metadata to utilize for determining drift.</p>
    pub fn get_metadata(&self) -> &::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>> {
        &self.metadata
    }
    /// Adds a key-value pair to `tags`.
    ///
    /// To override the contents of this collection use [`set_tags`](Self::set_tags).
    ///
    /// <p>The tags used to organize, track, or control access for this resource.</p>
    pub fn tags(mut self, k: impl ::std::convert::Into<::std::string::String>, v: impl ::std::convert::Into<::std::string::String>) -> Self {
        let mut hash_map = self.tags.unwrap_or_default();
        hash_map.insert(k.into(), v.into());
        self.tags = ::std::option::Option::Some(hash_map);
        self
    }
    /// <p>The tags used to organize, track, or control access for this resource.</p>
    pub fn set_tags(mut self, input: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>) -> Self {
        self.tags = input;
        self
    }
    /// <p>The tags used to organize, track, or control access for this resource.</p>
    pub fn get_tags(&self) -> &::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>> {
        &self.tags
    }
    /// Consumes the builder and constructs a [`ContentSummary`](crate::types::ContentSummary).
    /// This method will fail if any of the following fields are not set:
    /// - [`content_arn`](crate::types::builders::ContentSummaryBuilder::content_arn)
    /// - [`content_id`](crate::types::builders::ContentSummaryBuilder::content_id)
    /// - [`knowledge_base_arn`](crate::types::builders::ContentSummaryBuilder::knowledge_base_arn)
    /// - [`knowledge_base_id`](crate::types::builders::ContentSummaryBuilder::knowledge_base_id)
    /// - [`name`](crate::types::builders::ContentSummaryBuilder::name)
    /// - [`revision_id`](crate::types::builders::ContentSummaryBuilder::revision_id)
    /// - [`title`](crate::types::builders::ContentSummaryBuilder::title)
    /// - [`content_type`](crate::types::builders::ContentSummaryBuilder::content_type)
    /// - [`status`](crate::types::builders::ContentSummaryBuilder::status)
    /// - [`metadata`](crate::types::builders::ContentSummaryBuilder::metadata)
    pub fn build(self) -> ::std::result::Result<crate::types::ContentSummary, ::aws_smithy_types::error::operation::BuildError> {
        ::std::result::Result::Ok(crate::types::ContentSummary {
            content_arn: self.content_arn.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "content_arn",
                    "content_arn was not specified but it is required when building ContentSummary",
                )
            })?,
            content_id: self.content_id.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "content_id",
                    "content_id was not specified but it is required when building ContentSummary",
                )
            })?,
            knowledge_base_arn: self.knowledge_base_arn.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "knowledge_base_arn",
                    "knowledge_base_arn was not specified but it is required when building ContentSummary",
                )
            })?,
            knowledge_base_id: self.knowledge_base_id.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "knowledge_base_id",
                    "knowledge_base_id was not specified but it is required when building ContentSummary",
                )
            })?,
            name: self.name.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "name",
                    "name was not specified but it is required when building ContentSummary",
                )
            })?,
            revision_id: self.revision_id.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "revision_id",
                    "revision_id was not specified but it is required when building ContentSummary",
                )
            })?,
            title: self.title.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "title",
                    "title was not specified but it is required when building ContentSummary",
                )
            })?,
            content_type: self.content_type.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "content_type",
                    "content_type was not specified but it is required when building ContentSummary",
                )
            })?,
            status: self.status.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "status",
                    "status was not specified but it is required when building ContentSummary",
                )
            })?,
            metadata: self.metadata.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "metadata",
                    "metadata was not specified but it is required when building ContentSummary",
                )
            })?,
            tags: self.tags,
        })
    }
}
