// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Information about the content.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ContentData {
    /// <p>The Amazon Resource Name (ARN) of the content.</p>
    #[doc(hidden)]
    pub content_arn: std::option::Option<std::string::String>,
    /// <p>The identifier of the content.</p>
    #[doc(hidden)]
    pub content_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the knowledge base.</p>
    #[doc(hidden)]
    pub knowledge_base_arn: std::option::Option<std::string::String>,
    /// <p>The identifier of the knowledge base.</p>
    #[doc(hidden)]
    pub knowledge_base_id: std::option::Option<std::string::String>,
    /// <p>The name of the content.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The identifier of the content revision.</p>
    #[doc(hidden)]
    pub revision_id: std::option::Option<std::string::String>,
    /// <p>The title of the content.</p>
    #[doc(hidden)]
    pub title: std::option::Option<std::string::String>,
    /// <p>The media type of the content.</p>
    #[doc(hidden)]
    pub content_type: std::option::Option<std::string::String>,
    /// <p>The status of the content.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::types::ContentStatus>,
    /// <p>A key/value map to store attributes without affecting tagging or recommendations. For example, when synchronizing data between an external system and Wisdom, you can store an external version identifier as metadata to utilize for determining drift.</p>
    #[doc(hidden)]
    pub metadata:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The tags used to organize, track, or control access for this resource.</p>
    #[doc(hidden)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The URI of the content.</p>
    #[doc(hidden)]
    pub link_out_uri: std::option::Option<std::string::String>,
    /// <p>The URL of the content.</p>
    #[doc(hidden)]
    pub url: std::option::Option<std::string::String>,
    /// <p>The expiration time of the URL as an epoch timestamp.</p>
    #[doc(hidden)]
    pub url_expiry: std::option::Option<aws_smithy_types::DateTime>,
}
impl ContentData {
    /// <p>The Amazon Resource Name (ARN) of the content.</p>
    pub fn content_arn(&self) -> std::option::Option<&str> {
        self.content_arn.as_deref()
    }
    /// <p>The identifier of the content.</p>
    pub fn content_id(&self) -> std::option::Option<&str> {
        self.content_id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the knowledge base.</p>
    pub fn knowledge_base_arn(&self) -> std::option::Option<&str> {
        self.knowledge_base_arn.as_deref()
    }
    /// <p>The identifier of the knowledge base.</p>
    pub fn knowledge_base_id(&self) -> std::option::Option<&str> {
        self.knowledge_base_id.as_deref()
    }
    /// <p>The name of the content.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The identifier of the content revision.</p>
    pub fn revision_id(&self) -> std::option::Option<&str> {
        self.revision_id.as_deref()
    }
    /// <p>The title of the content.</p>
    pub fn title(&self) -> std::option::Option<&str> {
        self.title.as_deref()
    }
    /// <p>The media type of the content.</p>
    pub fn content_type(&self) -> std::option::Option<&str> {
        self.content_type.as_deref()
    }
    /// <p>The status of the content.</p>
    pub fn status(&self) -> std::option::Option<&crate::types::ContentStatus> {
        self.status.as_ref()
    }
    /// <p>A key/value map to store attributes without affecting tagging or recommendations. For example, when synchronizing data between an external system and Wisdom, you can store an external version identifier as metadata to utilize for determining drift.</p>
    pub fn metadata(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.metadata.as_ref()
    }
    /// <p>The tags used to organize, track, or control access for this resource.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
    /// <p>The URI of the content.</p>
    pub fn link_out_uri(&self) -> std::option::Option<&str> {
        self.link_out_uri.as_deref()
    }
    /// <p>The URL of the content.</p>
    pub fn url(&self) -> std::option::Option<&str> {
        self.url.as_deref()
    }
    /// <p>The expiration time of the URL as an epoch timestamp.</p>
    pub fn url_expiry(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.url_expiry.as_ref()
    }
}
impl std::fmt::Debug for ContentData {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ContentData");
        formatter.field("content_arn", &self.content_arn);
        formatter.field("content_id", &self.content_id);
        formatter.field("knowledge_base_arn", &self.knowledge_base_arn);
        formatter.field("knowledge_base_id", &self.knowledge_base_id);
        formatter.field("name", &self.name);
        formatter.field("revision_id", &self.revision_id);
        formatter.field("title", &self.title);
        formatter.field("content_type", &self.content_type);
        formatter.field("status", &self.status);
        formatter.field("metadata", &self.metadata);
        formatter.field("tags", &self.tags);
        formatter.field("link_out_uri", &self.link_out_uri);
        formatter.field("url", &"*** Sensitive Data Redacted ***");
        formatter.field("url_expiry", &self.url_expiry);
        formatter.finish()
    }
}
impl ContentData {
    /// Creates a new builder-style object to manufacture [`ContentData`](crate::types::ContentData).
    pub fn builder() -> crate::types::builders::ContentDataBuilder {
        crate::types::builders::ContentDataBuilder::default()
    }
}

/// A builder for [`ContentData`](crate::types::ContentData).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
pub struct ContentDataBuilder {
    pub(crate) content_arn: std::option::Option<std::string::String>,
    pub(crate) content_id: std::option::Option<std::string::String>,
    pub(crate) knowledge_base_arn: std::option::Option<std::string::String>,
    pub(crate) knowledge_base_id: std::option::Option<std::string::String>,
    pub(crate) name: std::option::Option<std::string::String>,
    pub(crate) revision_id: std::option::Option<std::string::String>,
    pub(crate) title: std::option::Option<std::string::String>,
    pub(crate) content_type: std::option::Option<std::string::String>,
    pub(crate) status: std::option::Option<crate::types::ContentStatus>,
    pub(crate) metadata:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    pub(crate) tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    pub(crate) link_out_uri: std::option::Option<std::string::String>,
    pub(crate) url: std::option::Option<std::string::String>,
    pub(crate) url_expiry: std::option::Option<aws_smithy_types::DateTime>,
}
impl ContentDataBuilder {
    /// <p>The Amazon Resource Name (ARN) of the content.</p>
    pub fn content_arn(mut self, input: impl Into<std::string::String>) -> Self {
        self.content_arn = Some(input.into());
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the content.</p>
    pub fn set_content_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.content_arn = input;
        self
    }
    /// <p>The identifier of the content.</p>
    pub fn content_id(mut self, input: impl Into<std::string::String>) -> Self {
        self.content_id = Some(input.into());
        self
    }
    /// <p>The identifier of the content.</p>
    pub fn set_content_id(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.content_id = input;
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the knowledge base.</p>
    pub fn knowledge_base_arn(mut self, input: impl Into<std::string::String>) -> Self {
        self.knowledge_base_arn = Some(input.into());
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the knowledge base.</p>
    pub fn set_knowledge_base_arn(
        mut self,
        input: std::option::Option<std::string::String>,
    ) -> Self {
        self.knowledge_base_arn = input;
        self
    }
    /// <p>The identifier of the knowledge base.</p>
    pub fn knowledge_base_id(mut self, input: impl Into<std::string::String>) -> Self {
        self.knowledge_base_id = Some(input.into());
        self
    }
    /// <p>The identifier of the knowledge base.</p>
    pub fn set_knowledge_base_id(
        mut self,
        input: std::option::Option<std::string::String>,
    ) -> Self {
        self.knowledge_base_id = input;
        self
    }
    /// <p>The name of the content.</p>
    pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
        self.name = Some(input.into());
        self
    }
    /// <p>The name of the content.</p>
    pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.name = input;
        self
    }
    /// <p>The identifier of the content revision.</p>
    pub fn revision_id(mut self, input: impl Into<std::string::String>) -> Self {
        self.revision_id = Some(input.into());
        self
    }
    /// <p>The identifier of the content revision.</p>
    pub fn set_revision_id(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.revision_id = input;
        self
    }
    /// <p>The title of the content.</p>
    pub fn title(mut self, input: impl Into<std::string::String>) -> Self {
        self.title = Some(input.into());
        self
    }
    /// <p>The title of the content.</p>
    pub fn set_title(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.title = input;
        self
    }
    /// <p>The media type of the content.</p>
    pub fn content_type(mut self, input: impl Into<std::string::String>) -> Self {
        self.content_type = Some(input.into());
        self
    }
    /// <p>The media type of the content.</p>
    pub fn set_content_type(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.content_type = input;
        self
    }
    /// <p>The status of the content.</p>
    pub fn status(mut self, input: crate::types::ContentStatus) -> Self {
        self.status = Some(input);
        self
    }
    /// <p>The status of the content.</p>
    pub fn set_status(mut self, input: std::option::Option<crate::types::ContentStatus>) -> Self {
        self.status = input;
        self
    }
    /// Adds a key-value pair to `metadata`.
    ///
    /// To override the contents of this collection use [`set_metadata`](Self::set_metadata).
    ///
    /// <p>A key/value map to store attributes without affecting tagging or recommendations. For example, when synchronizing data between an external system and Wisdom, you can store an external version identifier as metadata to utilize for determining drift.</p>
    pub fn metadata(
        mut self,
        k: impl Into<std::string::String>,
        v: impl Into<std::string::String>,
    ) -> Self {
        let mut hash_map = self.metadata.unwrap_or_default();
        hash_map.insert(k.into(), v.into());
        self.metadata = Some(hash_map);
        self
    }
    /// <p>A key/value map to store attributes without affecting tagging or recommendations. For example, when synchronizing data between an external system and Wisdom, you can store an external version identifier as metadata to utilize for determining drift.</p>
    pub fn set_metadata(
        mut self,
        input: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    ) -> Self {
        self.metadata = input;
        self
    }
    /// Adds a key-value pair to `tags`.
    ///
    /// To override the contents of this collection use [`set_tags`](Self::set_tags).
    ///
    /// <p>The tags used to organize, track, or control access for this resource.</p>
    pub fn tags(
        mut self,
        k: impl Into<std::string::String>,
        v: impl Into<std::string::String>,
    ) -> Self {
        let mut hash_map = self.tags.unwrap_or_default();
        hash_map.insert(k.into(), v.into());
        self.tags = Some(hash_map);
        self
    }
    /// <p>The tags used to organize, track, or control access for this resource.</p>
    pub fn set_tags(
        mut self,
        input: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    ) -> Self {
        self.tags = input;
        self
    }
    /// <p>The URI of the content.</p>
    pub fn link_out_uri(mut self, input: impl Into<std::string::String>) -> Self {
        self.link_out_uri = Some(input.into());
        self
    }
    /// <p>The URI of the content.</p>
    pub fn set_link_out_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.link_out_uri = input;
        self
    }
    /// <p>The URL of the content.</p>
    pub fn url(mut self, input: impl Into<std::string::String>) -> Self {
        self.url = Some(input.into());
        self
    }
    /// <p>The URL of the content.</p>
    pub fn set_url(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.url = input;
        self
    }
    /// <p>The expiration time of the URL as an epoch timestamp.</p>
    pub fn url_expiry(mut self, input: aws_smithy_types::DateTime) -> Self {
        self.url_expiry = Some(input);
        self
    }
    /// <p>The expiration time of the URL as an epoch timestamp.</p>
    pub fn set_url_expiry(
        mut self,
        input: std::option::Option<aws_smithy_types::DateTime>,
    ) -> Self {
        self.url_expiry = input;
        self
    }
    /// Consumes the builder and constructs a [`ContentData`](crate::types::ContentData).
    pub fn build(self) -> crate::types::ContentData {
        crate::types::ContentData {
            content_arn: self.content_arn,
            content_id: self.content_id,
            knowledge_base_arn: self.knowledge_base_arn,
            knowledge_base_id: self.knowledge_base_id,
            name: self.name,
            revision_id: self.revision_id,
            title: self.title,
            content_type: self.content_type,
            status: self.status,
            metadata: self.metadata,
            tags: self.tags,
            link_out_uri: self.link_out_uri,
            url: self.url,
            url_expiry: self.url_expiry,
        }
    }
}
impl std::fmt::Debug for ContentDataBuilder {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ContentDataBuilder");
        formatter.field("content_arn", &self.content_arn);
        formatter.field("content_id", &self.content_id);
        formatter.field("knowledge_base_arn", &self.knowledge_base_arn);
        formatter.field("knowledge_base_id", &self.knowledge_base_id);
        formatter.field("name", &self.name);
        formatter.field("revision_id", &self.revision_id);
        formatter.field("title", &self.title);
        formatter.field("content_type", &self.content_type);
        formatter.field("status", &self.status);
        formatter.field("metadata", &self.metadata);
        formatter.field("tags", &self.tags);
        formatter.field("link_out_uri", &self.link_out_uri);
        formatter.field("url", &"*** Sensitive Data Redacted ***");
        formatter.field("url_expiry", &self.url_expiry);
        formatter.finish()
    }
}
