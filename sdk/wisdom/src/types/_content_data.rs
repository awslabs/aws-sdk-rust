// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Information about the content.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq)]
pub struct ContentData {
    /// <p>The Amazon Resource Name (ARN) of the content.</p>
    pub content_arn: ::std::string::String,
    /// <p>The identifier of the content.</p>
    pub content_id: ::std::string::String,
    /// <p>The Amazon Resource Name (ARN) of the knowledge base.</p>
    pub knowledge_base_arn: ::std::string::String,
    /// <p>The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge base if you're storing Wisdom Content resource to it.</p>
    pub knowledge_base_id: ::std::string::String,
    /// <p>The name of the content.</p>
    pub name: ::std::string::String,
    /// <p>The identifier of the content revision.</p>
    pub revision_id: ::std::string::String,
    /// <p>The title of the content.</p>
    pub title: ::std::string::String,
    /// <p>The media type of the content.</p>
    pub content_type: ::std::string::String,
    /// <p>The status of the content.</p>
    pub status: crate::types::ContentStatus,
    /// <p>A key/value map to store attributes without affecting tagging or recommendations. For example, when synchronizing data between an external system and Wisdom, you can store an external version identifier as metadata to utilize for determining drift.</p>
    pub metadata: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    /// <p>The tags used to organize, track, or control access for this resource.</p>
    pub tags: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>,
    /// <p>The URI of the content.</p>
    pub link_out_uri: ::std::option::Option<::std::string::String>,
    /// <p>The URL of the content.</p>
    pub url: ::std::string::String,
    /// <p>The expiration time of the URL as an epoch timestamp.</p>
    pub url_expiry: ::aws_smithy_types::DateTime,
}
impl ContentData {
    /// <p>The Amazon Resource Name (ARN) of the content.</p>
    pub fn content_arn(&self) -> &str {
        use std::ops::Deref;
        self.content_arn.deref()
    }
    /// <p>The identifier of the content.</p>
    pub fn content_id(&self) -> &str {
        use std::ops::Deref;
        self.content_id.deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the knowledge base.</p>
    pub fn knowledge_base_arn(&self) -> &str {
        use std::ops::Deref;
        self.knowledge_base_arn.deref()
    }
    /// <p>The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge base if you're storing Wisdom Content resource to it.</p>
    pub fn knowledge_base_id(&self) -> &str {
        use std::ops::Deref;
        self.knowledge_base_id.deref()
    }
    /// <p>The name of the content.</p>
    pub fn name(&self) -> &str {
        use std::ops::Deref;
        self.name.deref()
    }
    /// <p>The identifier of the content revision.</p>
    pub fn revision_id(&self) -> &str {
        use std::ops::Deref;
        self.revision_id.deref()
    }
    /// <p>The title of the content.</p>
    pub fn title(&self) -> &str {
        use std::ops::Deref;
        self.title.deref()
    }
    /// <p>The media type of the content.</p>
    pub fn content_type(&self) -> &str {
        use std::ops::Deref;
        self.content_type.deref()
    }
    /// <p>The status of the content.</p>
    pub fn status(&self) -> &crate::types::ContentStatus {
        &self.status
    }
    /// <p>A key/value map to store attributes without affecting tagging or recommendations. For example, when synchronizing data between an external system and Wisdom, you can store an external version identifier as metadata to utilize for determining drift.</p>
    pub fn metadata(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.metadata
    }
    /// <p>The tags used to organize, track, or control access for this resource.</p>
    pub fn tags(&self) -> ::std::option::Option<&::std::collections::HashMap<::std::string::String, ::std::string::String>> {
        self.tags.as_ref()
    }
    /// <p>The URI of the content.</p>
    pub fn link_out_uri(&self) -> ::std::option::Option<&str> {
        self.link_out_uri.as_deref()
    }
    /// <p>The URL of the content.</p>
    pub fn url(&self) -> &str {
        use std::ops::Deref;
        self.url.deref()
    }
    /// <p>The expiration time of the URL as an epoch timestamp.</p>
    pub fn url_expiry(&self) -> &::aws_smithy_types::DateTime {
        &self.url_expiry
    }
}
impl ::std::fmt::Debug for ContentData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("ContentData");
        formatter.field("content_arn", &self.content_arn);
        formatter.field("content_id", &self.content_id);
        formatter.field("knowledge_base_arn", &self.knowledge_base_arn);
        formatter.field("knowledge_base_id", &self.knowledge_base_id);
        formatter.field("name", &self.name);
        formatter.field("revision_id", &self.revision_id);
        formatter.field("title", &self.title);
        formatter.field("content_type", &self.content_type);
        formatter.field("status", &self.status);
        formatter.field("metadata", &self.metadata);
        formatter.field("tags", &self.tags);
        formatter.field("link_out_uri", &self.link_out_uri);
        formatter.field("url", &"*** Sensitive Data Redacted ***");
        formatter.field("url_expiry", &self.url_expiry);
        formatter.finish()
    }
}
impl ContentData {
    /// Creates a new builder-style object to manufacture [`ContentData`](crate::types::ContentData).
    pub fn builder() -> crate::types::builders::ContentDataBuilder {
        crate::types::builders::ContentDataBuilder::default()
    }
}

/// A builder for [`ContentData`](crate::types::ContentData).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default)]
pub struct ContentDataBuilder {
    pub(crate) content_arn: ::std::option::Option<::std::string::String>,
    pub(crate) content_id: ::std::option::Option<::std::string::String>,
    pub(crate) knowledge_base_arn: ::std::option::Option<::std::string::String>,
    pub(crate) knowledge_base_id: ::std::option::Option<::std::string::String>,
    pub(crate) name: ::std::option::Option<::std::string::String>,
    pub(crate) revision_id: ::std::option::Option<::std::string::String>,
    pub(crate) title: ::std::option::Option<::std::string::String>,
    pub(crate) content_type: ::std::option::Option<::std::string::String>,
    pub(crate) status: ::std::option::Option<crate::types::ContentStatus>,
    pub(crate) metadata: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>,
    pub(crate) tags: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>,
    pub(crate) link_out_uri: ::std::option::Option<::std::string::String>,
    pub(crate) url: ::std::option::Option<::std::string::String>,
    pub(crate) url_expiry: ::std::option::Option<::aws_smithy_types::DateTime>,
}
impl ContentDataBuilder {
    /// <p>The Amazon Resource Name (ARN) of the content.</p>
    /// This field is required.
    pub fn content_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.content_arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the content.</p>
    pub fn set_content_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.content_arn = input;
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the content.</p>
    pub fn get_content_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.content_arn
    }
    /// <p>The identifier of the content.</p>
    /// This field is required.
    pub fn content_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.content_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The identifier of the content.</p>
    pub fn set_content_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.content_id = input;
        self
    }
    /// <p>The identifier of the content.</p>
    pub fn get_content_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.content_id
    }
    /// <p>The Amazon Resource Name (ARN) of the knowledge base.</p>
    /// This field is required.
    pub fn knowledge_base_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.knowledge_base_arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the knowledge base.</p>
    pub fn set_knowledge_base_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.knowledge_base_arn = input;
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the knowledge base.</p>
    pub fn get_knowledge_base_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.knowledge_base_arn
    }
    /// <p>The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge base if you're storing Wisdom Content resource to it.</p>
    /// This field is required.
    pub fn knowledge_base_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.knowledge_base_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge base if you're storing Wisdom Content resource to it.</p>
    pub fn set_knowledge_base_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.knowledge_base_id = input;
        self
    }
    /// <p>The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge base if you're storing Wisdom Content resource to it.</p>
    pub fn get_knowledge_base_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.knowledge_base_id
    }
    /// <p>The name of the content.</p>
    /// This field is required.
    pub fn name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The name of the content.</p>
    pub fn set_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.name = input;
        self
    }
    /// <p>The name of the content.</p>
    pub fn get_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.name
    }
    /// <p>The identifier of the content revision.</p>
    /// This field is required.
    pub fn revision_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.revision_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The identifier of the content revision.</p>
    pub fn set_revision_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.revision_id = input;
        self
    }
    /// <p>The identifier of the content revision.</p>
    pub fn get_revision_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.revision_id
    }
    /// <p>The title of the content.</p>
    /// This field is required.
    pub fn title(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.title = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The title of the content.</p>
    pub fn set_title(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.title = input;
        self
    }
    /// <p>The title of the content.</p>
    pub fn get_title(&self) -> &::std::option::Option<::std::string::String> {
        &self.title
    }
    /// <p>The media type of the content.</p>
    /// This field is required.
    pub fn content_type(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.content_type = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The media type of the content.</p>
    pub fn set_content_type(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.content_type = input;
        self
    }
    /// <p>The media type of the content.</p>
    pub fn get_content_type(&self) -> &::std::option::Option<::std::string::String> {
        &self.content_type
    }
    /// <p>The status of the content.</p>
    /// This field is required.
    pub fn status(mut self, input: crate::types::ContentStatus) -> Self {
        self.status = ::std::option::Option::Some(input);
        self
    }
    /// <p>The status of the content.</p>
    pub fn set_status(mut self, input: ::std::option::Option<crate::types::ContentStatus>) -> Self {
        self.status = input;
        self
    }
    /// <p>The status of the content.</p>
    pub fn get_status(&self) -> &::std::option::Option<crate::types::ContentStatus> {
        &self.status
    }
    /// Adds a key-value pair to `metadata`.
    ///
    /// To override the contents of this collection use [`set_metadata`](Self::set_metadata).
    ///
    /// <p>A key/value map to store attributes without affecting tagging or recommendations. For example, when synchronizing data between an external system and Wisdom, you can store an external version identifier as metadata to utilize for determining drift.</p>
    pub fn metadata(mut self, k: impl ::std::convert::Into<::std::string::String>, v: impl ::std::convert::Into<::std::string::String>) -> Self {
        let mut hash_map = self.metadata.unwrap_or_default();
        hash_map.insert(k.into(), v.into());
        self.metadata = ::std::option::Option::Some(hash_map);
        self
    }
    /// <p>A key/value map to store attributes without affecting tagging or recommendations. For example, when synchronizing data between an external system and Wisdom, you can store an external version identifier as metadata to utilize for determining drift.</p>
    pub fn set_metadata(mut self, input: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>) -> Self {
        self.metadata = input;
        self
    }
    /// <p>A key/value map to store attributes without affecting tagging or recommendations. For example, when synchronizing data between an external system and Wisdom, you can store an external version identifier as metadata to utilize for determining drift.</p>
    pub fn get_metadata(&self) -> &::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>> {
        &self.metadata
    }
    /// Adds a key-value pair to `tags`.
    ///
    /// To override the contents of this collection use [`set_tags`](Self::set_tags).
    ///
    /// <p>The tags used to organize, track, or control access for this resource.</p>
    pub fn tags(mut self, k: impl ::std::convert::Into<::std::string::String>, v: impl ::std::convert::Into<::std::string::String>) -> Self {
        let mut hash_map = self.tags.unwrap_or_default();
        hash_map.insert(k.into(), v.into());
        self.tags = ::std::option::Option::Some(hash_map);
        self
    }
    /// <p>The tags used to organize, track, or control access for this resource.</p>
    pub fn set_tags(mut self, input: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>) -> Self {
        self.tags = input;
        self
    }
    /// <p>The tags used to organize, track, or control access for this resource.</p>
    pub fn get_tags(&self) -> &::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>> {
        &self.tags
    }
    /// <p>The URI of the content.</p>
    pub fn link_out_uri(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.link_out_uri = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The URI of the content.</p>
    pub fn set_link_out_uri(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.link_out_uri = input;
        self
    }
    /// <p>The URI of the content.</p>
    pub fn get_link_out_uri(&self) -> &::std::option::Option<::std::string::String> {
        &self.link_out_uri
    }
    /// <p>The URL of the content.</p>
    /// This field is required.
    pub fn url(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.url = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The URL of the content.</p>
    pub fn set_url(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.url = input;
        self
    }
    /// <p>The URL of the content.</p>
    pub fn get_url(&self) -> &::std::option::Option<::std::string::String> {
        &self.url
    }
    /// <p>The expiration time of the URL as an epoch timestamp.</p>
    /// This field is required.
    pub fn url_expiry(mut self, input: ::aws_smithy_types::DateTime) -> Self {
        self.url_expiry = ::std::option::Option::Some(input);
        self
    }
    /// <p>The expiration time of the URL as an epoch timestamp.</p>
    pub fn set_url_expiry(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
        self.url_expiry = input;
        self
    }
    /// <p>The expiration time of the URL as an epoch timestamp.</p>
    pub fn get_url_expiry(&self) -> &::std::option::Option<::aws_smithy_types::DateTime> {
        &self.url_expiry
    }
    /// Consumes the builder and constructs a [`ContentData`](crate::types::ContentData).
    /// This method will fail if any of the following fields are not set:
    /// - [`content_arn`](crate::types::builders::ContentDataBuilder::content_arn)
    /// - [`content_id`](crate::types::builders::ContentDataBuilder::content_id)
    /// - [`knowledge_base_arn`](crate::types::builders::ContentDataBuilder::knowledge_base_arn)
    /// - [`knowledge_base_id`](crate::types::builders::ContentDataBuilder::knowledge_base_id)
    /// - [`name`](crate::types::builders::ContentDataBuilder::name)
    /// - [`revision_id`](crate::types::builders::ContentDataBuilder::revision_id)
    /// - [`title`](crate::types::builders::ContentDataBuilder::title)
    /// - [`content_type`](crate::types::builders::ContentDataBuilder::content_type)
    /// - [`status`](crate::types::builders::ContentDataBuilder::status)
    /// - [`metadata`](crate::types::builders::ContentDataBuilder::metadata)
    /// - [`url`](crate::types::builders::ContentDataBuilder::url)
    /// - [`url_expiry`](crate::types::builders::ContentDataBuilder::url_expiry)
    pub fn build(self) -> ::std::result::Result<crate::types::ContentData, ::aws_smithy_types::error::operation::BuildError> {
        ::std::result::Result::Ok(crate::types::ContentData {
            content_arn: self.content_arn.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "content_arn",
                    "content_arn was not specified but it is required when building ContentData",
                )
            })?,
            content_id: self.content_id.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "content_id",
                    "content_id was not specified but it is required when building ContentData",
                )
            })?,
            knowledge_base_arn: self.knowledge_base_arn.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "knowledge_base_arn",
                    "knowledge_base_arn was not specified but it is required when building ContentData",
                )
            })?,
            knowledge_base_id: self.knowledge_base_id.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "knowledge_base_id",
                    "knowledge_base_id was not specified but it is required when building ContentData",
                )
            })?,
            name: self.name.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "name",
                    "name was not specified but it is required when building ContentData",
                )
            })?,
            revision_id: self.revision_id.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "revision_id",
                    "revision_id was not specified but it is required when building ContentData",
                )
            })?,
            title: self.title.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "title",
                    "title was not specified but it is required when building ContentData",
                )
            })?,
            content_type: self.content_type.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "content_type",
                    "content_type was not specified but it is required when building ContentData",
                )
            })?,
            status: self.status.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "status",
                    "status was not specified but it is required when building ContentData",
                )
            })?,
            metadata: self.metadata.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "metadata",
                    "metadata was not specified but it is required when building ContentData",
                )
            })?,
            tags: self.tags,
            link_out_uri: self.link_out_uri,
            url: self.url.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "url",
                    "url was not specified but it is required when building ContentData",
                )
            })?,
            url_expiry: self.url_expiry.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "url_expiry",
                    "url_expiry was not specified but it is required when building ContentData",
                )
            })?,
        })
    }
}
impl ::std::fmt::Debug for ContentDataBuilder {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("ContentDataBuilder");
        formatter.field("content_arn", &self.content_arn);
        formatter.field("content_id", &self.content_id);
        formatter.field("knowledge_base_arn", &self.knowledge_base_arn);
        formatter.field("knowledge_base_id", &self.knowledge_base_id);
        formatter.field("name", &self.name);
        formatter.field("revision_id", &self.revision_id);
        formatter.field("title", &self.title);
        formatter.field("content_type", &self.content_type);
        formatter.field("status", &self.status);
        formatter.field("metadata", &self.metadata);
        formatter.field("tags", &self.tags);
        formatter.field("link_out_uri", &self.link_out_uri);
        formatter.field("url", &"*** Sensitive Data Redacted ***");
        formatter.field("url_expiry", &self.url_expiry);
        formatter.finish()
    }
}
