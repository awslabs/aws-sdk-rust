// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Contains information about a validation exception field.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ValidationExceptionField {
    /// <p>The name of the exception field.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The message of the exception field.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl ValidationExceptionField {
    /// <p>The name of the exception field.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The message of the exception field.</p>
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
/// See [`ValidationExceptionField`](crate::model::ValidationExceptionField).
pub mod validation_exception_field {

    /// A builder for [`ValidationExceptionField`](crate::model::ValidationExceptionField).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the exception field.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the exception field.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The message of the exception field.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message of the exception field.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ValidationExceptionField`](crate::model::ValidationExceptionField).
        pub fn build(self) -> crate::model::ValidationExceptionField {
            crate::model::ValidationExceptionField {
                name: self.name,
                message: self.message,
            }
        }
    }
}
impl ValidationExceptionField {
    /// Creates a new builder-style object to manufacture [`ValidationExceptionField`](crate::model::ValidationExceptionField).
    pub fn builder() -> crate::model::validation_exception_field::Builder {
        crate::model::validation_exception_field::Builder::default()
    }
}

/// When writing a match expression against `ValidationExceptionReason`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let validationexceptionreason = unimplemented!();
/// match validationexceptionreason {
///     ValidationExceptionReason::CannotParse => { /* ... */ },
///     ValidationExceptionReason::FieldValidationFailed => { /* ... */ },
///     ValidationExceptionReason::Other => { /* ... */ },
///     ValidationExceptionReason::UnknownOperation => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `validationexceptionreason` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ValidationExceptionReason::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ValidationExceptionReason::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ValidationExceptionReason::NewFeature` is defined.
/// Specifically, when `validationexceptionreason` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ValidationExceptionReason::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ValidationExceptionReason {
    #[allow(missing_docs)] // documentation missing in model
    CannotParse,
    #[allow(missing_docs)] // documentation missing in model
    FieldValidationFailed,
    #[allow(missing_docs)] // documentation missing in model
    Other,
    #[allow(missing_docs)] // documentation missing in model
    UnknownOperation,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ValidationExceptionReason {
    fn from(s: &str) -> Self {
        match s {
            "cannotParse" => ValidationExceptionReason::CannotParse,
            "fieldValidationFailed" => ValidationExceptionReason::FieldValidationFailed,
            "other" => ValidationExceptionReason::Other,
            "unknownOperation" => ValidationExceptionReason::UnknownOperation,
            other => ValidationExceptionReason::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for ValidationExceptionReason {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ValidationExceptionReason::from(s))
    }
}
impl ValidationExceptionReason {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ValidationExceptionReason::CannotParse => "cannotParse",
            ValidationExceptionReason::FieldValidationFailed => "fieldValidationFailed",
            ValidationExceptionReason::Other => "other",
            ValidationExceptionReason::UnknownOperation => "unknownOperation",
            ValidationExceptionReason::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "cannotParse",
            "fieldValidationFailed",
            "other",
            "unknownOperation",
        ]
    }
}
impl AsRef<str> for ValidationExceptionReason {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Contains a subset of the possible runtime environment attributes. Used in the environment list.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EnvironmentSummary {
    /// <p>The name of the runtime environment.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of a particular runtime environment.</p>
    #[doc(hidden)]
    pub environment_arn: std::option::Option<std::string::String>,
    /// <p>The unique identifier of a particular runtime environment.</p>
    #[doc(hidden)]
    pub environment_id: std::option::Option<std::string::String>,
    /// <p>The instance type of the runtime environment.</p>
    #[doc(hidden)]
    pub instance_type: std::option::Option<std::string::String>,
    /// <p>The status of the runtime environment</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::EnvironmentLifecycle>,
    /// <p>The target platform for the runtime environment.</p>
    #[doc(hidden)]
    pub engine_type: std::option::Option<crate::model::EngineType>,
    /// <p>The version of the runtime engine.</p>
    #[doc(hidden)]
    pub engine_version: std::option::Option<std::string::String>,
    /// <p>The timestamp when the runtime environment was created.</p>
    #[doc(hidden)]
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl EnvironmentSummary {
    /// <p>The name of the runtime environment.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of a particular runtime environment.</p>
    pub fn environment_arn(&self) -> std::option::Option<&str> {
        self.environment_arn.as_deref()
    }
    /// <p>The unique identifier of a particular runtime environment.</p>
    pub fn environment_id(&self) -> std::option::Option<&str> {
        self.environment_id.as_deref()
    }
    /// <p>The instance type of the runtime environment.</p>
    pub fn instance_type(&self) -> std::option::Option<&str> {
        self.instance_type.as_deref()
    }
    /// <p>The status of the runtime environment</p>
    pub fn status(&self) -> std::option::Option<&crate::model::EnvironmentLifecycle> {
        self.status.as_ref()
    }
    /// <p>The target platform for the runtime environment.</p>
    pub fn engine_type(&self) -> std::option::Option<&crate::model::EngineType> {
        self.engine_type.as_ref()
    }
    /// <p>The version of the runtime engine.</p>
    pub fn engine_version(&self) -> std::option::Option<&str> {
        self.engine_version.as_deref()
    }
    /// <p>The timestamp when the runtime environment was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
}
/// See [`EnvironmentSummary`](crate::model::EnvironmentSummary).
pub mod environment_summary {

    /// A builder for [`EnvironmentSummary`](crate::model::EnvironmentSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) environment_arn: std::option::Option<std::string::String>,
        pub(crate) environment_id: std::option::Option<std::string::String>,
        pub(crate) instance_type: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::EnvironmentLifecycle>,
        pub(crate) engine_type: std::option::Option<crate::model::EngineType>,
        pub(crate) engine_version: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The name of the runtime environment.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the runtime environment.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of a particular runtime environment.</p>
        pub fn environment_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.environment_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of a particular runtime environment.</p>
        pub fn set_environment_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.environment_arn = input;
            self
        }
        /// <p>The unique identifier of a particular runtime environment.</p>
        pub fn environment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.environment_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of a particular runtime environment.</p>
        pub fn set_environment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.environment_id = input;
            self
        }
        /// <p>The instance type of the runtime environment.</p>
        pub fn instance_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_type = Some(input.into());
            self
        }
        /// <p>The instance type of the runtime environment.</p>
        pub fn set_instance_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.instance_type = input;
            self
        }
        /// <p>The status of the runtime environment</p>
        pub fn status(mut self, input: crate::model::EnvironmentLifecycle) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the runtime environment</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::EnvironmentLifecycle>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The target platform for the runtime environment.</p>
        pub fn engine_type(mut self, input: crate::model::EngineType) -> Self {
            self.engine_type = Some(input);
            self
        }
        /// <p>The target platform for the runtime environment.</p>
        pub fn set_engine_type(
            mut self,
            input: std::option::Option<crate::model::EngineType>,
        ) -> Self {
            self.engine_type = input;
            self
        }
        /// <p>The version of the runtime engine.</p>
        pub fn engine_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.engine_version = Some(input.into());
            self
        }
        /// <p>The version of the runtime engine.</p>
        pub fn set_engine_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.engine_version = input;
            self
        }
        /// <p>The timestamp when the runtime environment was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The timestamp when the runtime environment was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// Consumes the builder and constructs a [`EnvironmentSummary`](crate::model::EnvironmentSummary).
        pub fn build(self) -> crate::model::EnvironmentSummary {
            crate::model::EnvironmentSummary {
                name: self.name,
                environment_arn: self.environment_arn,
                environment_id: self.environment_id,
                instance_type: self.instance_type,
                status: self.status,
                engine_type: self.engine_type,
                engine_version: self.engine_version,
                creation_time: self.creation_time,
            }
        }
    }
}
impl EnvironmentSummary {
    /// Creates a new builder-style object to manufacture [`EnvironmentSummary`](crate::model::EnvironmentSummary).
    pub fn builder() -> crate::model::environment_summary::Builder {
        crate::model::environment_summary::Builder::default()
    }
}

/// When writing a match expression against `EngineType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let enginetype = unimplemented!();
/// match enginetype {
///     EngineType::Bluage => { /* ... */ },
///     EngineType::Microfocus => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `enginetype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `EngineType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `EngineType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `EngineType::NewFeature` is defined.
/// Specifically, when `enginetype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `EngineType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum EngineType {
    #[allow(missing_docs)] // documentation missing in model
    Bluage,
    #[allow(missing_docs)] // documentation missing in model
    Microfocus,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for EngineType {
    fn from(s: &str) -> Self {
        match s {
            "bluage" => EngineType::Bluage,
            "microfocus" => EngineType::Microfocus,
            other => EngineType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for EngineType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(EngineType::from(s))
    }
}
impl EngineType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            EngineType::Bluage => "bluage",
            EngineType::Microfocus => "microfocus",
            EngineType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["bluage", "microfocus"]
    }
}
impl AsRef<str> for EngineType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `EnvironmentLifecycle`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let environmentlifecycle = unimplemented!();
/// match environmentlifecycle {
///     EnvironmentLifecycle::Available => { /* ... */ },
///     EnvironmentLifecycle::Creating => { /* ... */ },
///     EnvironmentLifecycle::Deleting => { /* ... */ },
///     EnvironmentLifecycle::Failed => { /* ... */ },
///     EnvironmentLifecycle::Updating => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `environmentlifecycle` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `EnvironmentLifecycle::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `EnvironmentLifecycle::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `EnvironmentLifecycle::NewFeature` is defined.
/// Specifically, when `environmentlifecycle` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `EnvironmentLifecycle::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum EnvironmentLifecycle {
    #[allow(missing_docs)] // documentation missing in model
    Available,
    #[allow(missing_docs)] // documentation missing in model
    Creating,
    #[allow(missing_docs)] // documentation missing in model
    Deleting,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    Updating,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for EnvironmentLifecycle {
    fn from(s: &str) -> Self {
        match s {
            "Available" => EnvironmentLifecycle::Available,
            "Creating" => EnvironmentLifecycle::Creating,
            "Deleting" => EnvironmentLifecycle::Deleting,
            "Failed" => EnvironmentLifecycle::Failed,
            "Updating" => EnvironmentLifecycle::Updating,
            other => {
                EnvironmentLifecycle::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for EnvironmentLifecycle {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(EnvironmentLifecycle::from(s))
    }
}
impl EnvironmentLifecycle {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            EnvironmentLifecycle::Available => "Available",
            EnvironmentLifecycle::Creating => "Creating",
            EnvironmentLifecycle::Deleting => "Deleting",
            EnvironmentLifecycle::Failed => "Failed",
            EnvironmentLifecycle::Updating => "Updating",
            EnvironmentLifecycle::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["Available", "Creating", "Deleting", "Failed", "Updating"]
    }
}
impl AsRef<str> for EnvironmentLifecycle {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Defines the details of a high availability configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct HighAvailabilityConfig {
    /// <p>The number of instances in a high availability configuration.</p>
    #[doc(hidden)]
    pub desired_capacity: std::option::Option<i32>,
}
impl HighAvailabilityConfig {
    /// <p>The number of instances in a high availability configuration.</p>
    pub fn desired_capacity(&self) -> std::option::Option<i32> {
        self.desired_capacity
    }
}
/// See [`HighAvailabilityConfig`](crate::model::HighAvailabilityConfig).
pub mod high_availability_config {

    /// A builder for [`HighAvailabilityConfig`](crate::model::HighAvailabilityConfig).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) desired_capacity: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The number of instances in a high availability configuration.</p>
        pub fn desired_capacity(mut self, input: i32) -> Self {
            self.desired_capacity = Some(input);
            self
        }
        /// <p>The number of instances in a high availability configuration.</p>
        pub fn set_desired_capacity(mut self, input: std::option::Option<i32>) -> Self {
            self.desired_capacity = input;
            self
        }
        /// Consumes the builder and constructs a [`HighAvailabilityConfig`](crate::model::HighAvailabilityConfig).
        pub fn build(self) -> crate::model::HighAvailabilityConfig {
            crate::model::HighAvailabilityConfig {
                desired_capacity: self.desired_capacity,
            }
        }
    }
}
impl HighAvailabilityConfig {
    /// Creates a new builder-style object to manufacture [`HighAvailabilityConfig`](crate::model::HighAvailabilityConfig).
    pub fn builder() -> crate::model::high_availability_config::Builder {
        crate::model::high_availability_config::Builder::default()
    }
}

/// <p>Defines the storage configuration for a runtime environment.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum StorageConfiguration {
    /// <p>Defines the storage configuration for an Amazon EFS file system.</p>
    Efs(crate::model::EfsStorageConfiguration),
    /// <p>Defines the storage configuration for an Amazon FSx file system.</p>
    Fsx(crate::model::FsxStorageConfiguration),
    /// The `Unknown` variant represents cases where new union variant was received. Consider upgrading the SDK to the latest available version.
    /// An unknown enum variant
    ///
    /// _Note: If you encounter this error, consider upgrading your SDK to the latest version._
    /// The `Unknown` variant represents cases where the server sent a value that wasn't recognized
    /// by the client. This can happen when the server adds new functionality, but the client has not been updated.
    /// To investigate this, consider turning on debug logging to print the raw HTTP response.
    #[non_exhaustive]
    Unknown,
}
impl StorageConfiguration {
    /// Tries to convert the enum instance into [`Efs`](crate::model::StorageConfiguration::Efs), extracting the inner [`EfsStorageConfiguration`](crate::model::EfsStorageConfiguration).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_efs(&self) -> std::result::Result<&crate::model::EfsStorageConfiguration, &Self> {
        if let StorageConfiguration::Efs(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`Efs`](crate::model::StorageConfiguration::Efs).
    pub fn is_efs(&self) -> bool {
        self.as_efs().is_ok()
    }
    /// Tries to convert the enum instance into [`Fsx`](crate::model::StorageConfiguration::Fsx), extracting the inner [`FsxStorageConfiguration`](crate::model::FsxStorageConfiguration).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_fsx(&self) -> std::result::Result<&crate::model::FsxStorageConfiguration, &Self> {
        if let StorageConfiguration::Fsx(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`Fsx`](crate::model::StorageConfiguration::Fsx).
    pub fn is_fsx(&self) -> bool {
        self.as_fsx().is_ok()
    }
    /// Returns true if the enum instance is the `Unknown` variant.
    pub fn is_unknown(&self) -> bool {
        matches!(self, Self::Unknown)
    }
}

/// <p>Defines the storage configuration for an Amazon FSx file system.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FsxStorageConfiguration {
    /// <p>The file system identifier.</p>
    #[doc(hidden)]
    pub file_system_id: std::option::Option<std::string::String>,
    /// <p>The mount point for the file system.</p>
    #[doc(hidden)]
    pub mount_point: std::option::Option<std::string::String>,
}
impl FsxStorageConfiguration {
    /// <p>The file system identifier.</p>
    pub fn file_system_id(&self) -> std::option::Option<&str> {
        self.file_system_id.as_deref()
    }
    /// <p>The mount point for the file system.</p>
    pub fn mount_point(&self) -> std::option::Option<&str> {
        self.mount_point.as_deref()
    }
}
/// See [`FsxStorageConfiguration`](crate::model::FsxStorageConfiguration).
pub mod fsx_storage_configuration {

    /// A builder for [`FsxStorageConfiguration`](crate::model::FsxStorageConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) file_system_id: std::option::Option<std::string::String>,
        pub(crate) mount_point: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The file system identifier.</p>
        pub fn file_system_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.file_system_id = Some(input.into());
            self
        }
        /// <p>The file system identifier.</p>
        pub fn set_file_system_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.file_system_id = input;
            self
        }
        /// <p>The mount point for the file system.</p>
        pub fn mount_point(mut self, input: impl Into<std::string::String>) -> Self {
            self.mount_point = Some(input.into());
            self
        }
        /// <p>The mount point for the file system.</p>
        pub fn set_mount_point(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.mount_point = input;
            self
        }
        /// Consumes the builder and constructs a [`FsxStorageConfiguration`](crate::model::FsxStorageConfiguration).
        pub fn build(self) -> crate::model::FsxStorageConfiguration {
            crate::model::FsxStorageConfiguration {
                file_system_id: self.file_system_id,
                mount_point: self.mount_point,
            }
        }
    }
}
impl FsxStorageConfiguration {
    /// Creates a new builder-style object to manufacture [`FsxStorageConfiguration`](crate::model::FsxStorageConfiguration).
    pub fn builder() -> crate::model::fsx_storage_configuration::Builder {
        crate::model::fsx_storage_configuration::Builder::default()
    }
}

/// <p>Defines the storage configuration for an Amazon EFS file system.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EfsStorageConfiguration {
    /// <p>The file system identifier.</p>
    #[doc(hidden)]
    pub file_system_id: std::option::Option<std::string::String>,
    /// <p>The mount point for the file system.</p>
    #[doc(hidden)]
    pub mount_point: std::option::Option<std::string::String>,
}
impl EfsStorageConfiguration {
    /// <p>The file system identifier.</p>
    pub fn file_system_id(&self) -> std::option::Option<&str> {
        self.file_system_id.as_deref()
    }
    /// <p>The mount point for the file system.</p>
    pub fn mount_point(&self) -> std::option::Option<&str> {
        self.mount_point.as_deref()
    }
}
/// See [`EfsStorageConfiguration`](crate::model::EfsStorageConfiguration).
pub mod efs_storage_configuration {

    /// A builder for [`EfsStorageConfiguration`](crate::model::EfsStorageConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) file_system_id: std::option::Option<std::string::String>,
        pub(crate) mount_point: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The file system identifier.</p>
        pub fn file_system_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.file_system_id = Some(input.into());
            self
        }
        /// <p>The file system identifier.</p>
        pub fn set_file_system_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.file_system_id = input;
            self
        }
        /// <p>The mount point for the file system.</p>
        pub fn mount_point(mut self, input: impl Into<std::string::String>) -> Self {
            self.mount_point = Some(input.into());
            self
        }
        /// <p>The mount point for the file system.</p>
        pub fn set_mount_point(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.mount_point = input;
            self
        }
        /// Consumes the builder and constructs a [`EfsStorageConfiguration`](crate::model::EfsStorageConfiguration).
        pub fn build(self) -> crate::model::EfsStorageConfiguration {
            crate::model::EfsStorageConfiguration {
                file_system_id: self.file_system_id,
                mount_point: self.mount_point,
            }
        }
    }
}
impl EfsStorageConfiguration {
    /// Creates a new builder-style object to manufacture [`EfsStorageConfiguration`](crate::model::EfsStorageConfiguration).
    pub fn builder() -> crate::model::efs_storage_configuration::Builder {
        crate::model::efs_storage_configuration::Builder::default()
    }
}

/// <p>The scheduled maintenance for a runtime engine.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PendingMaintenance {
    /// <p>The maintenance schedule for the runtime engine version.</p>
    #[doc(hidden)]
    pub schedule: std::option::Option<crate::model::MaintenanceSchedule>,
    /// <p>The specific runtime engine that the maintenance schedule applies to.</p>
    #[doc(hidden)]
    pub engine_version: std::option::Option<std::string::String>,
}
impl PendingMaintenance {
    /// <p>The maintenance schedule for the runtime engine version.</p>
    pub fn schedule(&self) -> std::option::Option<&crate::model::MaintenanceSchedule> {
        self.schedule.as_ref()
    }
    /// <p>The specific runtime engine that the maintenance schedule applies to.</p>
    pub fn engine_version(&self) -> std::option::Option<&str> {
        self.engine_version.as_deref()
    }
}
/// See [`PendingMaintenance`](crate::model::PendingMaintenance).
pub mod pending_maintenance {

    /// A builder for [`PendingMaintenance`](crate::model::PendingMaintenance).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) schedule: std::option::Option<crate::model::MaintenanceSchedule>,
        pub(crate) engine_version: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The maintenance schedule for the runtime engine version.</p>
        pub fn schedule(mut self, input: crate::model::MaintenanceSchedule) -> Self {
            self.schedule = Some(input);
            self
        }
        /// <p>The maintenance schedule for the runtime engine version.</p>
        pub fn set_schedule(
            mut self,
            input: std::option::Option<crate::model::MaintenanceSchedule>,
        ) -> Self {
            self.schedule = input;
            self
        }
        /// <p>The specific runtime engine that the maintenance schedule applies to.</p>
        pub fn engine_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.engine_version = Some(input.into());
            self
        }
        /// <p>The specific runtime engine that the maintenance schedule applies to.</p>
        pub fn set_engine_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.engine_version = input;
            self
        }
        /// Consumes the builder and constructs a [`PendingMaintenance`](crate::model::PendingMaintenance).
        pub fn build(self) -> crate::model::PendingMaintenance {
            crate::model::PendingMaintenance {
                schedule: self.schedule,
                engine_version: self.engine_version,
            }
        }
    }
}
impl PendingMaintenance {
    /// Creates a new builder-style object to manufacture [`PendingMaintenance`](crate::model::PendingMaintenance).
    pub fn builder() -> crate::model::pending_maintenance::Builder {
        crate::model::pending_maintenance::Builder::default()
    }
}

/// <p>The information about the maintenance schedule.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct MaintenanceSchedule {
    /// <p>The time the scheduled maintenance is to start.</p>
    #[doc(hidden)]
    pub start_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time the scheduled maintenance is to end.</p>
    #[doc(hidden)]
    pub end_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl MaintenanceSchedule {
    /// <p>The time the scheduled maintenance is to start.</p>
    pub fn start_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.start_time.as_ref()
    }
    /// <p>The time the scheduled maintenance is to end.</p>
    pub fn end_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.end_time.as_ref()
    }
}
/// See [`MaintenanceSchedule`](crate::model::MaintenanceSchedule).
pub mod maintenance_schedule {

    /// A builder for [`MaintenanceSchedule`](crate::model::MaintenanceSchedule).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) start_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) end_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The time the scheduled maintenance is to start.</p>
        pub fn start_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.start_time = Some(input);
            self
        }
        /// <p>The time the scheduled maintenance is to start.</p>
        pub fn set_start_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.start_time = input;
            self
        }
        /// <p>The time the scheduled maintenance is to end.</p>
        pub fn end_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.end_time = Some(input);
            self
        }
        /// <p>The time the scheduled maintenance is to end.</p>
        pub fn set_end_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.end_time = input;
            self
        }
        /// Consumes the builder and constructs a [`MaintenanceSchedule`](crate::model::MaintenanceSchedule).
        pub fn build(self) -> crate::model::MaintenanceSchedule {
            crate::model::MaintenanceSchedule {
                start_time: self.start_time,
                end_time: self.end_time,
            }
        }
    }
}
impl MaintenanceSchedule {
    /// Creates a new builder-style object to manufacture [`MaintenanceSchedule`](crate::model::MaintenanceSchedule).
    pub fn builder() -> crate::model::maintenance_schedule::Builder {
        crate::model::maintenance_schedule::Builder::default()
    }
}

/// <p>Identifies a specific batch job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum BatchJobIdentifier {
    /// <p>Specifies a file associated with a specific batch job.</p>
    FileBatchJobIdentifier(crate::model::FileBatchJobIdentifier),
    /// <p>A batch job identifier in which the batch job to run is identified by the script name.</p>
    ScriptBatchJobIdentifier(crate::model::ScriptBatchJobIdentifier),
    /// The `Unknown` variant represents cases where new union variant was received. Consider upgrading the SDK to the latest available version.
    /// An unknown enum variant
    ///
    /// _Note: If you encounter this error, consider upgrading your SDK to the latest version._
    /// The `Unknown` variant represents cases where the server sent a value that wasn't recognized
    /// by the client. This can happen when the server adds new functionality, but the client has not been updated.
    /// To investigate this, consider turning on debug logging to print the raw HTTP response.
    #[non_exhaustive]
    Unknown,
}
impl BatchJobIdentifier {
    /// Tries to convert the enum instance into [`FileBatchJobIdentifier`](crate::model::BatchJobIdentifier::FileBatchJobIdentifier), extracting the inner [`FileBatchJobIdentifier`](crate::model::FileBatchJobIdentifier).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_file_batch_job_identifier(
        &self,
    ) -> std::result::Result<&crate::model::FileBatchJobIdentifier, &Self> {
        if let BatchJobIdentifier::FileBatchJobIdentifier(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`FileBatchJobIdentifier`](crate::model::BatchJobIdentifier::FileBatchJobIdentifier).
    pub fn is_file_batch_job_identifier(&self) -> bool {
        self.as_file_batch_job_identifier().is_ok()
    }
    /// Tries to convert the enum instance into [`ScriptBatchJobIdentifier`](crate::model::BatchJobIdentifier::ScriptBatchJobIdentifier), extracting the inner [`ScriptBatchJobIdentifier`](crate::model::ScriptBatchJobIdentifier).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_script_batch_job_identifier(
        &self,
    ) -> std::result::Result<&crate::model::ScriptBatchJobIdentifier, &Self> {
        if let BatchJobIdentifier::ScriptBatchJobIdentifier(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`ScriptBatchJobIdentifier`](crate::model::BatchJobIdentifier::ScriptBatchJobIdentifier).
    pub fn is_script_batch_job_identifier(&self) -> bool {
        self.as_script_batch_job_identifier().is_ok()
    }
    /// Returns true if the enum instance is the `Unknown` variant.
    pub fn is_unknown(&self) -> bool {
        matches!(self, Self::Unknown)
    }
}

/// <p>A batch job identifier in which the batch job to run is identified by the script name.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ScriptBatchJobIdentifier {
    /// <p>The name of the script containing the batch job definition.</p>
    #[doc(hidden)]
    pub script_name: std::option::Option<std::string::String>,
}
impl ScriptBatchJobIdentifier {
    /// <p>The name of the script containing the batch job definition.</p>
    pub fn script_name(&self) -> std::option::Option<&str> {
        self.script_name.as_deref()
    }
}
/// See [`ScriptBatchJobIdentifier`](crate::model::ScriptBatchJobIdentifier).
pub mod script_batch_job_identifier {

    /// A builder for [`ScriptBatchJobIdentifier`](crate::model::ScriptBatchJobIdentifier).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) script_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the script containing the batch job definition.</p>
        pub fn script_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.script_name = Some(input.into());
            self
        }
        /// <p>The name of the script containing the batch job definition.</p>
        pub fn set_script_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.script_name = input;
            self
        }
        /// Consumes the builder and constructs a [`ScriptBatchJobIdentifier`](crate::model::ScriptBatchJobIdentifier).
        pub fn build(self) -> crate::model::ScriptBatchJobIdentifier {
            crate::model::ScriptBatchJobIdentifier {
                script_name: self.script_name,
            }
        }
    }
}
impl ScriptBatchJobIdentifier {
    /// Creates a new builder-style object to manufacture [`ScriptBatchJobIdentifier`](crate::model::ScriptBatchJobIdentifier).
    pub fn builder() -> crate::model::script_batch_job_identifier::Builder {
        crate::model::script_batch_job_identifier::Builder::default()
    }
}

/// <p>A batch job identifier in which the batch job to run is identified by the file name and the relative path to the file name.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FileBatchJobIdentifier {
    /// <p>The file name for the batch job identifier.</p>
    #[doc(hidden)]
    pub file_name: std::option::Option<std::string::String>,
    /// <p>The relative path to the file name for the batch job identifier.</p>
    #[doc(hidden)]
    pub folder_path: std::option::Option<std::string::String>,
}
impl FileBatchJobIdentifier {
    /// <p>The file name for the batch job identifier.</p>
    pub fn file_name(&self) -> std::option::Option<&str> {
        self.file_name.as_deref()
    }
    /// <p>The relative path to the file name for the batch job identifier.</p>
    pub fn folder_path(&self) -> std::option::Option<&str> {
        self.folder_path.as_deref()
    }
}
/// See [`FileBatchJobIdentifier`](crate::model::FileBatchJobIdentifier).
pub mod file_batch_job_identifier {

    /// A builder for [`FileBatchJobIdentifier`](crate::model::FileBatchJobIdentifier).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) file_name: std::option::Option<std::string::String>,
        pub(crate) folder_path: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The file name for the batch job identifier.</p>
        pub fn file_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.file_name = Some(input.into());
            self
        }
        /// <p>The file name for the batch job identifier.</p>
        pub fn set_file_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.file_name = input;
            self
        }
        /// <p>The relative path to the file name for the batch job identifier.</p>
        pub fn folder_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.folder_path = Some(input.into());
            self
        }
        /// <p>The relative path to the file name for the batch job identifier.</p>
        pub fn set_folder_path(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.folder_path = input;
            self
        }
        /// Consumes the builder and constructs a [`FileBatchJobIdentifier`](crate::model::FileBatchJobIdentifier).
        pub fn build(self) -> crate::model::FileBatchJobIdentifier {
            crate::model::FileBatchJobIdentifier {
                file_name: self.file_name,
                folder_path: self.folder_path,
            }
        }
    }
}
impl FileBatchJobIdentifier {
    /// Creates a new builder-style object to manufacture [`FileBatchJobIdentifier`](crate::model::FileBatchJobIdentifier).
    pub fn builder() -> crate::model::file_batch_job_identifier::Builder {
        crate::model::file_batch_job_identifier::Builder::default()
    }
}

/// <p>A subset of information about a specific deployment.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeploymentSummary {
    /// <p>The unique identifier of the deployment.</p>
    #[doc(hidden)]
    pub deployment_id: std::option::Option<std::string::String>,
    /// <p>The unique identifier of the application.</p>
    #[doc(hidden)]
    pub application_id: std::option::Option<std::string::String>,
    /// <p>The unique identifier of the runtime environment.</p>
    #[doc(hidden)]
    pub environment_id: std::option::Option<std::string::String>,
    /// <p>The version of the application.</p>
    #[doc(hidden)]
    pub application_version: std::option::Option<i32>,
    /// <p>The current status of the deployment.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::DeploymentLifecycle>,
    /// <p>The timestamp when the deployment was created.</p>
    #[doc(hidden)]
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The reason for the reported status.</p>
    #[doc(hidden)]
    pub status_reason: std::option::Option<std::string::String>,
}
impl DeploymentSummary {
    /// <p>The unique identifier of the deployment.</p>
    pub fn deployment_id(&self) -> std::option::Option<&str> {
        self.deployment_id.as_deref()
    }
    /// <p>The unique identifier of the application.</p>
    pub fn application_id(&self) -> std::option::Option<&str> {
        self.application_id.as_deref()
    }
    /// <p>The unique identifier of the runtime environment.</p>
    pub fn environment_id(&self) -> std::option::Option<&str> {
        self.environment_id.as_deref()
    }
    /// <p>The version of the application.</p>
    pub fn application_version(&self) -> std::option::Option<i32> {
        self.application_version
    }
    /// <p>The current status of the deployment.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::DeploymentLifecycle> {
        self.status.as_ref()
    }
    /// <p>The timestamp when the deployment was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>The reason for the reported status.</p>
    pub fn status_reason(&self) -> std::option::Option<&str> {
        self.status_reason.as_deref()
    }
}
/// See [`DeploymentSummary`](crate::model::DeploymentSummary).
pub mod deployment_summary {

    /// A builder for [`DeploymentSummary`](crate::model::DeploymentSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) deployment_id: std::option::Option<std::string::String>,
        pub(crate) application_id: std::option::Option<std::string::String>,
        pub(crate) environment_id: std::option::Option<std::string::String>,
        pub(crate) application_version: std::option::Option<i32>,
        pub(crate) status: std::option::Option<crate::model::DeploymentLifecycle>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) status_reason: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique identifier of the deployment.</p>
        pub fn deployment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.deployment_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the deployment.</p>
        pub fn set_deployment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.deployment_id = input;
            self
        }
        /// <p>The unique identifier of the application.</p>
        pub fn application_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.application_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the application.</p>
        pub fn set_application_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.application_id = input;
            self
        }
        /// <p>The unique identifier of the runtime environment.</p>
        pub fn environment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.environment_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the runtime environment.</p>
        pub fn set_environment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.environment_id = input;
            self
        }
        /// <p>The version of the application.</p>
        pub fn application_version(mut self, input: i32) -> Self {
            self.application_version = Some(input);
            self
        }
        /// <p>The version of the application.</p>
        pub fn set_application_version(mut self, input: std::option::Option<i32>) -> Self {
            self.application_version = input;
            self
        }
        /// <p>The current status of the deployment.</p>
        pub fn status(mut self, input: crate::model::DeploymentLifecycle) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The current status of the deployment.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::DeploymentLifecycle>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The timestamp when the deployment was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The timestamp when the deployment was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The reason for the reported status.</p>
        pub fn status_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.status_reason = Some(input.into());
            self
        }
        /// <p>The reason for the reported status.</p>
        pub fn set_status_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.status_reason = input;
            self
        }
        /// Consumes the builder and constructs a [`DeploymentSummary`](crate::model::DeploymentSummary).
        pub fn build(self) -> crate::model::DeploymentSummary {
            crate::model::DeploymentSummary {
                deployment_id: self.deployment_id,
                application_id: self.application_id,
                environment_id: self.environment_id,
                application_version: self.application_version,
                status: self.status,
                creation_time: self.creation_time,
                status_reason: self.status_reason,
            }
        }
    }
}
impl DeploymentSummary {
    /// Creates a new builder-style object to manufacture [`DeploymentSummary`](crate::model::DeploymentSummary).
    pub fn builder() -> crate::model::deployment_summary::Builder {
        crate::model::deployment_summary::Builder::default()
    }
}

/// When writing a match expression against `DeploymentLifecycle`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let deploymentlifecycle = unimplemented!();
/// match deploymentlifecycle {
///     DeploymentLifecycle::Deploying => { /* ... */ },
///     DeploymentLifecycle::Failed => { /* ... */ },
///     DeploymentLifecycle::Succeeded => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `deploymentlifecycle` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `DeploymentLifecycle::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `DeploymentLifecycle::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `DeploymentLifecycle::NewFeature` is defined.
/// Specifically, when `deploymentlifecycle` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `DeploymentLifecycle::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DeploymentLifecycle {
    #[allow(missing_docs)] // documentation missing in model
    Deploying,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    Succeeded,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for DeploymentLifecycle {
    fn from(s: &str) -> Self {
        match s {
            "Deploying" => DeploymentLifecycle::Deploying,
            "Failed" => DeploymentLifecycle::Failed,
            "Succeeded" => DeploymentLifecycle::Succeeded,
            other => {
                DeploymentLifecycle::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for DeploymentLifecycle {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DeploymentLifecycle::from(s))
    }
}
impl DeploymentLifecycle {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DeploymentLifecycle::Deploying => "Deploying",
            DeploymentLifecycle::Failed => "Failed",
            DeploymentLifecycle::Succeeded => "Succeeded",
            DeploymentLifecycle::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["Deploying", "Failed", "Succeeded"]
    }
}
impl AsRef<str> for DeploymentLifecycle {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A subset of the possible data set attributes.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DataSetSummary {
    /// <p>The name of the data set.</p>
    #[doc(hidden)]
    pub data_set_name: std::option::Option<std::string::String>,
    /// <p>The type of data set. The only supported value is VSAM.</p>
    #[doc(hidden)]
    pub data_set_org: std::option::Option<std::string::String>,
    /// <p>The format of the data set. </p>
    #[doc(hidden)]
    pub format: std::option::Option<std::string::String>,
    /// <p>The timestamp when the data set was created.</p>
    #[doc(hidden)]
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The last time the data set was updated.</p>
    #[doc(hidden)]
    pub last_updated_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The last time the data set was referenced.</p>
    #[doc(hidden)]
    pub last_referenced_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl DataSetSummary {
    /// <p>The name of the data set.</p>
    pub fn data_set_name(&self) -> std::option::Option<&str> {
        self.data_set_name.as_deref()
    }
    /// <p>The type of data set. The only supported value is VSAM.</p>
    pub fn data_set_org(&self) -> std::option::Option<&str> {
        self.data_set_org.as_deref()
    }
    /// <p>The format of the data set. </p>
    pub fn format(&self) -> std::option::Option<&str> {
        self.format.as_deref()
    }
    /// <p>The timestamp when the data set was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>The last time the data set was updated.</p>
    pub fn last_updated_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_updated_time.as_ref()
    }
    /// <p>The last time the data set was referenced.</p>
    pub fn last_referenced_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_referenced_time.as_ref()
    }
}
/// See [`DataSetSummary`](crate::model::DataSetSummary).
pub mod data_set_summary {

    /// A builder for [`DataSetSummary`](crate::model::DataSetSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) data_set_name: std::option::Option<std::string::String>,
        pub(crate) data_set_org: std::option::Option<std::string::String>,
        pub(crate) format: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_updated_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_referenced_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The name of the data set.</p>
        pub fn data_set_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.data_set_name = Some(input.into());
            self
        }
        /// <p>The name of the data set.</p>
        pub fn set_data_set_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.data_set_name = input;
            self
        }
        /// <p>The type of data set. The only supported value is VSAM.</p>
        pub fn data_set_org(mut self, input: impl Into<std::string::String>) -> Self {
            self.data_set_org = Some(input.into());
            self
        }
        /// <p>The type of data set. The only supported value is VSAM.</p>
        pub fn set_data_set_org(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.data_set_org = input;
            self
        }
        /// <p>The format of the data set. </p>
        pub fn format(mut self, input: impl Into<std::string::String>) -> Self {
            self.format = Some(input.into());
            self
        }
        /// <p>The format of the data set. </p>
        pub fn set_format(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.format = input;
            self
        }
        /// <p>The timestamp when the data set was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The timestamp when the data set was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The last time the data set was updated.</p>
        pub fn last_updated_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_updated_time = Some(input);
            self
        }
        /// <p>The last time the data set was updated.</p>
        pub fn set_last_updated_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_updated_time = input;
            self
        }
        /// <p>The last time the data set was referenced.</p>
        pub fn last_referenced_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_referenced_time = Some(input);
            self
        }
        /// <p>The last time the data set was referenced.</p>
        pub fn set_last_referenced_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_referenced_time = input;
            self
        }
        /// Consumes the builder and constructs a [`DataSetSummary`](crate::model::DataSetSummary).
        pub fn build(self) -> crate::model::DataSetSummary {
            crate::model::DataSetSummary {
                data_set_name: self.data_set_name,
                data_set_org: self.data_set_org,
                format: self.format,
                creation_time: self.creation_time,
                last_updated_time: self.last_updated_time,
                last_referenced_time: self.last_referenced_time,
            }
        }
    }
}
impl DataSetSummary {
    /// Creates a new builder-style object to manufacture [`DataSetSummary`](crate::model::DataSetSummary).
    pub fn builder() -> crate::model::data_set_summary::Builder {
        crate::model::data_set_summary::Builder::default()
    }
}

/// <p>Contains information about a data set import task.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DataSetImportTask {
    /// <p>The identifier of the data set import task.</p>
    #[doc(hidden)]
    pub task_id: std::option::Option<std::string::String>,
    /// <p>The status of the data set import task.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::DataSetTaskLifecycle>,
    /// <p>A summary of the data set import task.</p>
    #[doc(hidden)]
    pub summary: std::option::Option<crate::model::DataSetImportSummary>,
}
impl DataSetImportTask {
    /// <p>The identifier of the data set import task.</p>
    pub fn task_id(&self) -> std::option::Option<&str> {
        self.task_id.as_deref()
    }
    /// <p>The status of the data set import task.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::DataSetTaskLifecycle> {
        self.status.as_ref()
    }
    /// <p>A summary of the data set import task.</p>
    pub fn summary(&self) -> std::option::Option<&crate::model::DataSetImportSummary> {
        self.summary.as_ref()
    }
}
/// See [`DataSetImportTask`](crate::model::DataSetImportTask).
pub mod data_set_import_task {

    /// A builder for [`DataSetImportTask`](crate::model::DataSetImportTask).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) task_id: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::DataSetTaskLifecycle>,
        pub(crate) summary: std::option::Option<crate::model::DataSetImportSummary>,
    }
    impl Builder {
        /// <p>The identifier of the data set import task.</p>
        pub fn task_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.task_id = Some(input.into());
            self
        }
        /// <p>The identifier of the data set import task.</p>
        pub fn set_task_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.task_id = input;
            self
        }
        /// <p>The status of the data set import task.</p>
        pub fn status(mut self, input: crate::model::DataSetTaskLifecycle) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the data set import task.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::DataSetTaskLifecycle>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>A summary of the data set import task.</p>
        pub fn summary(mut self, input: crate::model::DataSetImportSummary) -> Self {
            self.summary = Some(input);
            self
        }
        /// <p>A summary of the data set import task.</p>
        pub fn set_summary(
            mut self,
            input: std::option::Option<crate::model::DataSetImportSummary>,
        ) -> Self {
            self.summary = input;
            self
        }
        /// Consumes the builder and constructs a [`DataSetImportTask`](crate::model::DataSetImportTask).
        pub fn build(self) -> crate::model::DataSetImportTask {
            crate::model::DataSetImportTask {
                task_id: self.task_id,
                status: self.status,
                summary: self.summary,
            }
        }
    }
}
impl DataSetImportTask {
    /// Creates a new builder-style object to manufacture [`DataSetImportTask`](crate::model::DataSetImportTask).
    pub fn builder() -> crate::model::data_set_import_task::Builder {
        crate::model::data_set_import_task::Builder::default()
    }
}

/// <p>Represents a summary of data set imports.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DataSetImportSummary {
    /// <p>The total number of data set imports.</p>
    #[doc(hidden)]
    pub total: i32,
    /// <p>The number of data set imports that have succeeded.</p>
    #[doc(hidden)]
    pub succeeded: i32,
    /// <p>The number of data set imports that have failed.</p>
    #[doc(hidden)]
    pub failed: i32,
    /// <p>The number of data set imports that are pending.</p>
    #[doc(hidden)]
    pub pending: i32,
    /// <p>The number of data set imports that are in progress.</p>
    #[doc(hidden)]
    pub in_progress: i32,
}
impl DataSetImportSummary {
    /// <p>The total number of data set imports.</p>
    pub fn total(&self) -> i32 {
        self.total
    }
    /// <p>The number of data set imports that have succeeded.</p>
    pub fn succeeded(&self) -> i32 {
        self.succeeded
    }
    /// <p>The number of data set imports that have failed.</p>
    pub fn failed(&self) -> i32 {
        self.failed
    }
    /// <p>The number of data set imports that are pending.</p>
    pub fn pending(&self) -> i32 {
        self.pending
    }
    /// <p>The number of data set imports that are in progress.</p>
    pub fn in_progress(&self) -> i32 {
        self.in_progress
    }
}
/// See [`DataSetImportSummary`](crate::model::DataSetImportSummary).
pub mod data_set_import_summary {

    /// A builder for [`DataSetImportSummary`](crate::model::DataSetImportSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) total: std::option::Option<i32>,
        pub(crate) succeeded: std::option::Option<i32>,
        pub(crate) failed: std::option::Option<i32>,
        pub(crate) pending: std::option::Option<i32>,
        pub(crate) in_progress: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The total number of data set imports.</p>
        pub fn total(mut self, input: i32) -> Self {
            self.total = Some(input);
            self
        }
        /// <p>The total number of data set imports.</p>
        pub fn set_total(mut self, input: std::option::Option<i32>) -> Self {
            self.total = input;
            self
        }
        /// <p>The number of data set imports that have succeeded.</p>
        pub fn succeeded(mut self, input: i32) -> Self {
            self.succeeded = Some(input);
            self
        }
        /// <p>The number of data set imports that have succeeded.</p>
        pub fn set_succeeded(mut self, input: std::option::Option<i32>) -> Self {
            self.succeeded = input;
            self
        }
        /// <p>The number of data set imports that have failed.</p>
        pub fn failed(mut self, input: i32) -> Self {
            self.failed = Some(input);
            self
        }
        /// <p>The number of data set imports that have failed.</p>
        pub fn set_failed(mut self, input: std::option::Option<i32>) -> Self {
            self.failed = input;
            self
        }
        /// <p>The number of data set imports that are pending.</p>
        pub fn pending(mut self, input: i32) -> Self {
            self.pending = Some(input);
            self
        }
        /// <p>The number of data set imports that are pending.</p>
        pub fn set_pending(mut self, input: std::option::Option<i32>) -> Self {
            self.pending = input;
            self
        }
        /// <p>The number of data set imports that are in progress.</p>
        pub fn in_progress(mut self, input: i32) -> Self {
            self.in_progress = Some(input);
            self
        }
        /// <p>The number of data set imports that are in progress.</p>
        pub fn set_in_progress(mut self, input: std::option::Option<i32>) -> Self {
            self.in_progress = input;
            self
        }
        /// Consumes the builder and constructs a [`DataSetImportSummary`](crate::model::DataSetImportSummary).
        pub fn build(self) -> crate::model::DataSetImportSummary {
            crate::model::DataSetImportSummary {
                total: self.total.unwrap_or_default(),
                succeeded: self.succeeded.unwrap_or_default(),
                failed: self.failed.unwrap_or_default(),
                pending: self.pending.unwrap_or_default(),
                in_progress: self.in_progress.unwrap_or_default(),
            }
        }
    }
}
impl DataSetImportSummary {
    /// Creates a new builder-style object to manufacture [`DataSetImportSummary`](crate::model::DataSetImportSummary).
    pub fn builder() -> crate::model::data_set_import_summary::Builder {
        crate::model::data_set_import_summary::Builder::default()
    }
}

/// When writing a match expression against `DataSetTaskLifecycle`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let datasettasklifecycle = unimplemented!();
/// match datasettasklifecycle {
///     DataSetTaskLifecycle::Completed => { /* ... */ },
///     DataSetTaskLifecycle::Creating => { /* ... */ },
///     DataSetTaskLifecycle::Running => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `datasettasklifecycle` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `DataSetTaskLifecycle::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `DataSetTaskLifecycle::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `DataSetTaskLifecycle::NewFeature` is defined.
/// Specifically, when `datasettasklifecycle` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `DataSetTaskLifecycle::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DataSetTaskLifecycle {
    #[allow(missing_docs)] // documentation missing in model
    Completed,
    #[allow(missing_docs)] // documentation missing in model
    Creating,
    #[allow(missing_docs)] // documentation missing in model
    Running,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for DataSetTaskLifecycle {
    fn from(s: &str) -> Self {
        match s {
            "Completed" => DataSetTaskLifecycle::Completed,
            "Creating" => DataSetTaskLifecycle::Creating,
            "Running" => DataSetTaskLifecycle::Running,
            other => {
                DataSetTaskLifecycle::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for DataSetTaskLifecycle {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DataSetTaskLifecycle::from(s))
    }
}
impl DataSetTaskLifecycle {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DataSetTaskLifecycle::Completed => "Completed",
            DataSetTaskLifecycle::Creating => "Creating",
            DataSetTaskLifecycle::Running => "Running",
            DataSetTaskLifecycle::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["Completed", "Creating", "Running"]
    }
}
impl AsRef<str> for DataSetTaskLifecycle {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A subset of the possible batch job attributes. Used in the batch job list.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BatchJobExecutionSummary {
    /// <p>The unique identifier of this execution of the batch job.</p>
    #[doc(hidden)]
    pub execution_id: std::option::Option<std::string::String>,
    /// <p>The unique identifier of the application that hosts this batch job.</p>
    #[doc(hidden)]
    pub application_id: std::option::Option<std::string::String>,
    /// <p>The unique identifier of a particular batch job.</p>
    #[doc(hidden)]
    pub job_id: std::option::Option<std::string::String>,
    /// <p>The name of a particular batch job.</p>
    #[doc(hidden)]
    pub job_name: std::option::Option<std::string::String>,
    /// <p>The type of a particular batch job execution.</p>
    #[doc(hidden)]
    pub job_type: std::option::Option<crate::model::BatchJobType>,
    /// <p>The status of a particular batch job execution.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::BatchJobExecutionStatus>,
    /// <p>The timestamp when a particular batch job execution started.</p>
    #[doc(hidden)]
    pub start_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The timestamp when this batch job execution ended.</p>
    #[doc(hidden)]
    pub end_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl BatchJobExecutionSummary {
    /// <p>The unique identifier of this execution of the batch job.</p>
    pub fn execution_id(&self) -> std::option::Option<&str> {
        self.execution_id.as_deref()
    }
    /// <p>The unique identifier of the application that hosts this batch job.</p>
    pub fn application_id(&self) -> std::option::Option<&str> {
        self.application_id.as_deref()
    }
    /// <p>The unique identifier of a particular batch job.</p>
    pub fn job_id(&self) -> std::option::Option<&str> {
        self.job_id.as_deref()
    }
    /// <p>The name of a particular batch job.</p>
    pub fn job_name(&self) -> std::option::Option<&str> {
        self.job_name.as_deref()
    }
    /// <p>The type of a particular batch job execution.</p>
    pub fn job_type(&self) -> std::option::Option<&crate::model::BatchJobType> {
        self.job_type.as_ref()
    }
    /// <p>The status of a particular batch job execution.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::BatchJobExecutionStatus> {
        self.status.as_ref()
    }
    /// <p>The timestamp when a particular batch job execution started.</p>
    pub fn start_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.start_time.as_ref()
    }
    /// <p>The timestamp when this batch job execution ended.</p>
    pub fn end_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.end_time.as_ref()
    }
}
/// See [`BatchJobExecutionSummary`](crate::model::BatchJobExecutionSummary).
pub mod batch_job_execution_summary {

    /// A builder for [`BatchJobExecutionSummary`](crate::model::BatchJobExecutionSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) execution_id: std::option::Option<std::string::String>,
        pub(crate) application_id: std::option::Option<std::string::String>,
        pub(crate) job_id: std::option::Option<std::string::String>,
        pub(crate) job_name: std::option::Option<std::string::String>,
        pub(crate) job_type: std::option::Option<crate::model::BatchJobType>,
        pub(crate) status: std::option::Option<crate::model::BatchJobExecutionStatus>,
        pub(crate) start_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) end_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The unique identifier of this execution of the batch job.</p>
        pub fn execution_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.execution_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of this execution of the batch job.</p>
        pub fn set_execution_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.execution_id = input;
            self
        }
        /// <p>The unique identifier of the application that hosts this batch job.</p>
        pub fn application_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.application_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the application that hosts this batch job.</p>
        pub fn set_application_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.application_id = input;
            self
        }
        /// <p>The unique identifier of a particular batch job.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of a particular batch job.</p>
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_id = input;
            self
        }
        /// <p>The name of a particular batch job.</p>
        pub fn job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_name = Some(input.into());
            self
        }
        /// <p>The name of a particular batch job.</p>
        pub fn set_job_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_name = input;
            self
        }
        /// <p>The type of a particular batch job execution.</p>
        pub fn job_type(mut self, input: crate::model::BatchJobType) -> Self {
            self.job_type = Some(input);
            self
        }
        /// <p>The type of a particular batch job execution.</p>
        pub fn set_job_type(
            mut self,
            input: std::option::Option<crate::model::BatchJobType>,
        ) -> Self {
            self.job_type = input;
            self
        }
        /// <p>The status of a particular batch job execution.</p>
        pub fn status(mut self, input: crate::model::BatchJobExecutionStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of a particular batch job execution.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::BatchJobExecutionStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The timestamp when a particular batch job execution started.</p>
        pub fn start_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.start_time = Some(input);
            self
        }
        /// <p>The timestamp when a particular batch job execution started.</p>
        pub fn set_start_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.start_time = input;
            self
        }
        /// <p>The timestamp when this batch job execution ended.</p>
        pub fn end_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.end_time = Some(input);
            self
        }
        /// <p>The timestamp when this batch job execution ended.</p>
        pub fn set_end_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.end_time = input;
            self
        }
        /// Consumes the builder and constructs a [`BatchJobExecutionSummary`](crate::model::BatchJobExecutionSummary).
        pub fn build(self) -> crate::model::BatchJobExecutionSummary {
            crate::model::BatchJobExecutionSummary {
                execution_id: self.execution_id,
                application_id: self.application_id,
                job_id: self.job_id,
                job_name: self.job_name,
                job_type: self.job_type,
                status: self.status,
                start_time: self.start_time,
                end_time: self.end_time,
            }
        }
    }
}
impl BatchJobExecutionSummary {
    /// Creates a new builder-style object to manufacture [`BatchJobExecutionSummary`](crate::model::BatchJobExecutionSummary).
    pub fn builder() -> crate::model::batch_job_execution_summary::Builder {
        crate::model::batch_job_execution_summary::Builder::default()
    }
}

/// When writing a match expression against `BatchJobExecutionStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let batchjobexecutionstatus = unimplemented!();
/// match batchjobexecutionstatus {
///     BatchJobExecutionStatus::Cancelled => { /* ... */ },
///     BatchJobExecutionStatus::Cancelling => { /* ... */ },
///     BatchJobExecutionStatus::Dispatch => { /* ... */ },
///     BatchJobExecutionStatus::Failed => { /* ... */ },
///     BatchJobExecutionStatus::Holding => { /* ... */ },
///     BatchJobExecutionStatus::Running => { /* ... */ },
///     BatchJobExecutionStatus::Submitting => { /* ... */ },
///     BatchJobExecutionStatus::Succeeded => { /* ... */ },
///     BatchJobExecutionStatus::SucceededWithWarning => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `batchjobexecutionstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `BatchJobExecutionStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `BatchJobExecutionStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `BatchJobExecutionStatus::NewFeature` is defined.
/// Specifically, when `batchjobexecutionstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `BatchJobExecutionStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum BatchJobExecutionStatus {
    #[allow(missing_docs)] // documentation missing in model
    Cancelled,
    #[allow(missing_docs)] // documentation missing in model
    Cancelling,
    #[allow(missing_docs)] // documentation missing in model
    Dispatch,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    Holding,
    #[allow(missing_docs)] // documentation missing in model
    Running,
    #[allow(missing_docs)] // documentation missing in model
    Submitting,
    #[allow(missing_docs)] // documentation missing in model
    Succeeded,
    #[allow(missing_docs)] // documentation missing in model
    SucceededWithWarning,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for BatchJobExecutionStatus {
    fn from(s: &str) -> Self {
        match s {
            "Cancelled" => BatchJobExecutionStatus::Cancelled,
            "Cancelling" => BatchJobExecutionStatus::Cancelling,
            "Dispatching" => BatchJobExecutionStatus::Dispatch,
            "Failed" => BatchJobExecutionStatus::Failed,
            "Holding" => BatchJobExecutionStatus::Holding,
            "Running" => BatchJobExecutionStatus::Running,
            "Submitting" => BatchJobExecutionStatus::Submitting,
            "Succeeded" => BatchJobExecutionStatus::Succeeded,
            "Succeeded With Warning" => BatchJobExecutionStatus::SucceededWithWarning,
            other => BatchJobExecutionStatus::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for BatchJobExecutionStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(BatchJobExecutionStatus::from(s))
    }
}
impl BatchJobExecutionStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            BatchJobExecutionStatus::Cancelled => "Cancelled",
            BatchJobExecutionStatus::Cancelling => "Cancelling",
            BatchJobExecutionStatus::Dispatch => "Dispatching",
            BatchJobExecutionStatus::Failed => "Failed",
            BatchJobExecutionStatus::Holding => "Holding",
            BatchJobExecutionStatus::Running => "Running",
            BatchJobExecutionStatus::Submitting => "Submitting",
            BatchJobExecutionStatus::Succeeded => "Succeeded",
            BatchJobExecutionStatus::SucceededWithWarning => "Succeeded With Warning",
            BatchJobExecutionStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "Cancelled",
            "Cancelling",
            "Dispatching",
            "Failed",
            "Holding",
            "Running",
            "Submitting",
            "Succeeded",
            "Succeeded With Warning",
        ]
    }
}
impl AsRef<str> for BatchJobExecutionStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `BatchJobType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let batchjobtype = unimplemented!();
/// match batchjobtype {
///     BatchJobType::Jes2 => { /* ... */ },
///     BatchJobType::Jes3 => { /* ... */ },
///     BatchJobType::Vse => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `batchjobtype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `BatchJobType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `BatchJobType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `BatchJobType::NewFeature` is defined.
/// Specifically, when `batchjobtype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `BatchJobType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum BatchJobType {
    #[allow(missing_docs)] // documentation missing in model
    Jes2,
    #[allow(missing_docs)] // documentation missing in model
    Jes3,
    #[allow(missing_docs)] // documentation missing in model
    Vse,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for BatchJobType {
    fn from(s: &str) -> Self {
        match s {
            "JES2" => BatchJobType::Jes2,
            "JES3" => BatchJobType::Jes3,
            "VSE" => BatchJobType::Vse,
            other => BatchJobType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for BatchJobType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(BatchJobType::from(s))
    }
}
impl BatchJobType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            BatchJobType::Jes2 => "JES2",
            BatchJobType::Jes3 => "JES3",
            BatchJobType::Vse => "VSE",
            BatchJobType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["JES2", "JES3", "VSE"]
    }
}
impl AsRef<str> for BatchJobType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Defines the details of a batch job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum BatchJobDefinition {
    /// <p>Specifies a file containing a batch job definition.</p>
    FileBatchJobDefinition(crate::model::FileBatchJobDefinition),
    /// <p>A script containing a batch job definition.</p>
    ScriptBatchJobDefinition(crate::model::ScriptBatchJobDefinition),
    /// The `Unknown` variant represents cases where new union variant was received. Consider upgrading the SDK to the latest available version.
    /// An unknown enum variant
    ///
    /// _Note: If you encounter this error, consider upgrading your SDK to the latest version._
    /// The `Unknown` variant represents cases where the server sent a value that wasn't recognized
    /// by the client. This can happen when the server adds new functionality, but the client has not been updated.
    /// To investigate this, consider turning on debug logging to print the raw HTTP response.
    #[non_exhaustive]
    Unknown,
}
impl BatchJobDefinition {
    /// Tries to convert the enum instance into [`FileBatchJobDefinition`](crate::model::BatchJobDefinition::FileBatchJobDefinition), extracting the inner [`FileBatchJobDefinition`](crate::model::FileBatchJobDefinition).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_file_batch_job_definition(
        &self,
    ) -> std::result::Result<&crate::model::FileBatchJobDefinition, &Self> {
        if let BatchJobDefinition::FileBatchJobDefinition(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`FileBatchJobDefinition`](crate::model::BatchJobDefinition::FileBatchJobDefinition).
    pub fn is_file_batch_job_definition(&self) -> bool {
        self.as_file_batch_job_definition().is_ok()
    }
    /// Tries to convert the enum instance into [`ScriptBatchJobDefinition`](crate::model::BatchJobDefinition::ScriptBatchJobDefinition), extracting the inner [`ScriptBatchJobDefinition`](crate::model::ScriptBatchJobDefinition).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_script_batch_job_definition(
        &self,
    ) -> std::result::Result<&crate::model::ScriptBatchJobDefinition, &Self> {
        if let BatchJobDefinition::ScriptBatchJobDefinition(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`ScriptBatchJobDefinition`](crate::model::BatchJobDefinition::ScriptBatchJobDefinition).
    pub fn is_script_batch_job_definition(&self) -> bool {
        self.as_script_batch_job_definition().is_ok()
    }
    /// Returns true if the enum instance is the `Unknown` variant.
    pub fn is_unknown(&self) -> bool {
        matches!(self, Self::Unknown)
    }
}

/// <p>A batch job definition contained in a script.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ScriptBatchJobDefinition {
    /// <p>The name of the script containing the batch job definition.</p>
    #[doc(hidden)]
    pub script_name: std::option::Option<std::string::String>,
}
impl ScriptBatchJobDefinition {
    /// <p>The name of the script containing the batch job definition.</p>
    pub fn script_name(&self) -> std::option::Option<&str> {
        self.script_name.as_deref()
    }
}
/// See [`ScriptBatchJobDefinition`](crate::model::ScriptBatchJobDefinition).
pub mod script_batch_job_definition {

    /// A builder for [`ScriptBatchJobDefinition`](crate::model::ScriptBatchJobDefinition).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) script_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the script containing the batch job definition.</p>
        pub fn script_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.script_name = Some(input.into());
            self
        }
        /// <p>The name of the script containing the batch job definition.</p>
        pub fn set_script_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.script_name = input;
            self
        }
        /// Consumes the builder and constructs a [`ScriptBatchJobDefinition`](crate::model::ScriptBatchJobDefinition).
        pub fn build(self) -> crate::model::ScriptBatchJobDefinition {
            crate::model::ScriptBatchJobDefinition {
                script_name: self.script_name,
            }
        }
    }
}
impl ScriptBatchJobDefinition {
    /// Creates a new builder-style object to manufacture [`ScriptBatchJobDefinition`](crate::model::ScriptBatchJobDefinition).
    pub fn builder() -> crate::model::script_batch_job_definition::Builder {
        crate::model::script_batch_job_definition::Builder::default()
    }
}

/// <p>A file containing a batch job definition.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FileBatchJobDefinition {
    /// <p>The name of the file containing the batch job definition.</p>
    #[doc(hidden)]
    pub file_name: std::option::Option<std::string::String>,
    /// <p>The path to the file containing the batch job definition.</p>
    #[doc(hidden)]
    pub folder_path: std::option::Option<std::string::String>,
}
impl FileBatchJobDefinition {
    /// <p>The name of the file containing the batch job definition.</p>
    pub fn file_name(&self) -> std::option::Option<&str> {
        self.file_name.as_deref()
    }
    /// <p>The path to the file containing the batch job definition.</p>
    pub fn folder_path(&self) -> std::option::Option<&str> {
        self.folder_path.as_deref()
    }
}
/// See [`FileBatchJobDefinition`](crate::model::FileBatchJobDefinition).
pub mod file_batch_job_definition {

    /// A builder for [`FileBatchJobDefinition`](crate::model::FileBatchJobDefinition).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) file_name: std::option::Option<std::string::String>,
        pub(crate) folder_path: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the file containing the batch job definition.</p>
        pub fn file_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.file_name = Some(input.into());
            self
        }
        /// <p>The name of the file containing the batch job definition.</p>
        pub fn set_file_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.file_name = input;
            self
        }
        /// <p>The path to the file containing the batch job definition.</p>
        pub fn folder_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.folder_path = Some(input.into());
            self
        }
        /// <p>The path to the file containing the batch job definition.</p>
        pub fn set_folder_path(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.folder_path = input;
            self
        }
        /// Consumes the builder and constructs a [`FileBatchJobDefinition`](crate::model::FileBatchJobDefinition).
        pub fn build(self) -> crate::model::FileBatchJobDefinition {
            crate::model::FileBatchJobDefinition {
                file_name: self.file_name,
                folder_path: self.folder_path,
            }
        }
    }
}
impl FileBatchJobDefinition {
    /// Creates a new builder-style object to manufacture [`FileBatchJobDefinition`](crate::model::FileBatchJobDefinition).
    pub fn builder() -> crate::model::file_batch_job_definition::Builder {
        crate::model::file_batch_job_definition::Builder::default()
    }
}

/// <p>Defines an application version summary.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ApplicationVersionSummary {
    /// <p>The application version.</p>
    #[doc(hidden)]
    pub application_version: std::option::Option<i32>,
    /// <p>The status of the application.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::ApplicationVersionLifecycle>,
    /// <p>The reason for the reported status.</p>
    #[doc(hidden)]
    pub status_reason: std::option::Option<std::string::String>,
    /// <p>The timestamp when the application version was created.</p>
    #[doc(hidden)]
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl ApplicationVersionSummary {
    /// <p>The application version.</p>
    pub fn application_version(&self) -> std::option::Option<i32> {
        self.application_version
    }
    /// <p>The status of the application.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::ApplicationVersionLifecycle> {
        self.status.as_ref()
    }
    /// <p>The reason for the reported status.</p>
    pub fn status_reason(&self) -> std::option::Option<&str> {
        self.status_reason.as_deref()
    }
    /// <p>The timestamp when the application version was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
}
/// See [`ApplicationVersionSummary`](crate::model::ApplicationVersionSummary).
pub mod application_version_summary {

    /// A builder for [`ApplicationVersionSummary`](crate::model::ApplicationVersionSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) application_version: std::option::Option<i32>,
        pub(crate) status: std::option::Option<crate::model::ApplicationVersionLifecycle>,
        pub(crate) status_reason: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The application version.</p>
        pub fn application_version(mut self, input: i32) -> Self {
            self.application_version = Some(input);
            self
        }
        /// <p>The application version.</p>
        pub fn set_application_version(mut self, input: std::option::Option<i32>) -> Self {
            self.application_version = input;
            self
        }
        /// <p>The status of the application.</p>
        pub fn status(mut self, input: crate::model::ApplicationVersionLifecycle) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the application.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::ApplicationVersionLifecycle>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The reason for the reported status.</p>
        pub fn status_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.status_reason = Some(input.into());
            self
        }
        /// <p>The reason for the reported status.</p>
        pub fn set_status_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.status_reason = input;
            self
        }
        /// <p>The timestamp when the application version was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The timestamp when the application version was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// Consumes the builder and constructs a [`ApplicationVersionSummary`](crate::model::ApplicationVersionSummary).
        pub fn build(self) -> crate::model::ApplicationVersionSummary {
            crate::model::ApplicationVersionSummary {
                application_version: self.application_version,
                status: self.status,
                status_reason: self.status_reason,
                creation_time: self.creation_time,
            }
        }
    }
}
impl ApplicationVersionSummary {
    /// Creates a new builder-style object to manufacture [`ApplicationVersionSummary`](crate::model::ApplicationVersionSummary).
    pub fn builder() -> crate::model::application_version_summary::Builder {
        crate::model::application_version_summary::Builder::default()
    }
}

/// When writing a match expression against `ApplicationVersionLifecycle`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let applicationversionlifecycle = unimplemented!();
/// match applicationversionlifecycle {
///     ApplicationVersionLifecycle::Available => { /* ... */ },
///     ApplicationVersionLifecycle::Creating => { /* ... */ },
///     ApplicationVersionLifecycle::Failed => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `applicationversionlifecycle` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ApplicationVersionLifecycle::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ApplicationVersionLifecycle::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ApplicationVersionLifecycle::NewFeature` is defined.
/// Specifically, when `applicationversionlifecycle` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ApplicationVersionLifecycle::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ApplicationVersionLifecycle {
    #[allow(missing_docs)] // documentation missing in model
    Available,
    #[allow(missing_docs)] // documentation missing in model
    Creating,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ApplicationVersionLifecycle {
    fn from(s: &str) -> Self {
        match s {
            "Available" => ApplicationVersionLifecycle::Available,
            "Creating" => ApplicationVersionLifecycle::Creating,
            "Failed" => ApplicationVersionLifecycle::Failed,
            other => ApplicationVersionLifecycle::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for ApplicationVersionLifecycle {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ApplicationVersionLifecycle::from(s))
    }
}
impl ApplicationVersionLifecycle {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ApplicationVersionLifecycle::Available => "Available",
            ApplicationVersionLifecycle::Creating => "Creating",
            ApplicationVersionLifecycle::Failed => "Failed",
            ApplicationVersionLifecycle::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["Available", "Creating", "Failed"]
    }
}
impl AsRef<str> for ApplicationVersionLifecycle {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Additional details about the data set. Different attributes correspond to different data set organizations. The values are populated based on datasetOrg, storageType and backend (Blu Age or Micro Focus).</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum DatasetDetailOrgAttributes {
    /// <p>The generation data group of the data set.</p>
    Gdg(crate::model::GdgDetailAttributes),
    /// <p>The details of a VSAM data set.</p>
    Vsam(crate::model::VsamDetailAttributes),
    /// The `Unknown` variant represents cases where new union variant was received. Consider upgrading the SDK to the latest available version.
    /// An unknown enum variant
    ///
    /// _Note: If you encounter this error, consider upgrading your SDK to the latest version._
    /// The `Unknown` variant represents cases where the server sent a value that wasn't recognized
    /// by the client. This can happen when the server adds new functionality, but the client has not been updated.
    /// To investigate this, consider turning on debug logging to print the raw HTTP response.
    #[non_exhaustive]
    Unknown,
}
impl DatasetDetailOrgAttributes {
    /// Tries to convert the enum instance into [`Gdg`](crate::model::DatasetDetailOrgAttributes::Gdg), extracting the inner [`GdgDetailAttributes`](crate::model::GdgDetailAttributes).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_gdg(&self) -> std::result::Result<&crate::model::GdgDetailAttributes, &Self> {
        if let DatasetDetailOrgAttributes::Gdg(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`Gdg`](crate::model::DatasetDetailOrgAttributes::Gdg).
    pub fn is_gdg(&self) -> bool {
        self.as_gdg().is_ok()
    }
    /// Tries to convert the enum instance into [`Vsam`](crate::model::DatasetDetailOrgAttributes::Vsam), extracting the inner [`VsamDetailAttributes`](crate::model::VsamDetailAttributes).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_vsam(&self) -> std::result::Result<&crate::model::VsamDetailAttributes, &Self> {
        if let DatasetDetailOrgAttributes::Vsam(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`Vsam`](crate::model::DatasetDetailOrgAttributes::Vsam).
    pub fn is_vsam(&self) -> bool {
        self.as_vsam().is_ok()
    }
    /// Returns true if the enum instance is the `Unknown` variant.
    pub fn is_unknown(&self) -> bool {
        matches!(self, Self::Unknown)
    }
}

/// <p>The required attributes for a generation data group data set. A generation data set is one of a collection of successive, historically related, catalogued data sets that together are known as a generation data group (GDG). Use this structure when you want to import a GDG. For more information on GDG, see <a href="https://www.ibm.com/docs/en/zos/2.3.0?topic=guide-generation-data-sets">Generation data sets</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GdgDetailAttributes {
    /// <p>The maximum number of generation data sets, up to 255, in a GDG.</p>
    #[doc(hidden)]
    pub limit: i32,
    /// <p>The disposition of the data set in the catalog.</p>
    #[doc(hidden)]
    pub roll_disposition: std::option::Option<std::string::String>,
}
impl GdgDetailAttributes {
    /// <p>The maximum number of generation data sets, up to 255, in a GDG.</p>
    pub fn limit(&self) -> i32 {
        self.limit
    }
    /// <p>The disposition of the data set in the catalog.</p>
    pub fn roll_disposition(&self) -> std::option::Option<&str> {
        self.roll_disposition.as_deref()
    }
}
/// See [`GdgDetailAttributes`](crate::model::GdgDetailAttributes).
pub mod gdg_detail_attributes {

    /// A builder for [`GdgDetailAttributes`](crate::model::GdgDetailAttributes).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) limit: std::option::Option<i32>,
        pub(crate) roll_disposition: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The maximum number of generation data sets, up to 255, in a GDG.</p>
        pub fn limit(mut self, input: i32) -> Self {
            self.limit = Some(input);
            self
        }
        /// <p>The maximum number of generation data sets, up to 255, in a GDG.</p>
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.limit = input;
            self
        }
        /// <p>The disposition of the data set in the catalog.</p>
        pub fn roll_disposition(mut self, input: impl Into<std::string::String>) -> Self {
            self.roll_disposition = Some(input.into());
            self
        }
        /// <p>The disposition of the data set in the catalog.</p>
        pub fn set_roll_disposition(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.roll_disposition = input;
            self
        }
        /// Consumes the builder and constructs a [`GdgDetailAttributes`](crate::model::GdgDetailAttributes).
        pub fn build(self) -> crate::model::GdgDetailAttributes {
            crate::model::GdgDetailAttributes {
                limit: self.limit.unwrap_or_default(),
                roll_disposition: self.roll_disposition,
            }
        }
    }
}
impl GdgDetailAttributes {
    /// Creates a new builder-style object to manufacture [`GdgDetailAttributes`](crate::model::GdgDetailAttributes).
    pub fn builder() -> crate::model::gdg_detail_attributes::Builder {
        crate::model::gdg_detail_attributes::Builder::default()
    }
}

/// <p>The attributes of a VSAM type data set.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct VsamDetailAttributes {
    /// <p>The character set used by the data set. Can be ASCII, EBCDIC, or unknown.</p>
    #[doc(hidden)]
    pub encoding: std::option::Option<std::string::String>,
    /// <p>The record format of the data set.</p>
    #[doc(hidden)]
    pub record_format: std::option::Option<std::string::String>,
    /// <p>Indicates whether indexes for this dataset are stored as compressed values. If you have a large data set (typically &gt; 100 Mb), consider setting this flag to True.</p>
    #[doc(hidden)]
    pub compressed: std::option::Option<bool>,
    /// <p>If set to True, enforces loading the data set into cache before it’s used by the application.</p>
    #[doc(hidden)]
    pub cache_at_startup: std::option::Option<bool>,
    /// <p>The primary key of the data set.</p>
    #[doc(hidden)]
    pub primary_key: std::option::Option<crate::model::PrimaryKey>,
    /// <p>The alternate key definitions, if any. A legacy dataset might not have any alternate key defined, but if those alternate keys definitions exist, provide them as some applications will make use of them.</p>
    #[doc(hidden)]
    pub alternate_keys: std::option::Option<std::vec::Vec<crate::model::AlternateKey>>,
}
impl VsamDetailAttributes {
    /// <p>The character set used by the data set. Can be ASCII, EBCDIC, or unknown.</p>
    pub fn encoding(&self) -> std::option::Option<&str> {
        self.encoding.as_deref()
    }
    /// <p>The record format of the data set.</p>
    pub fn record_format(&self) -> std::option::Option<&str> {
        self.record_format.as_deref()
    }
    /// <p>Indicates whether indexes for this dataset are stored as compressed values. If you have a large data set (typically &gt; 100 Mb), consider setting this flag to True.</p>
    pub fn compressed(&self) -> std::option::Option<bool> {
        self.compressed
    }
    /// <p>If set to True, enforces loading the data set into cache before it’s used by the application.</p>
    pub fn cache_at_startup(&self) -> std::option::Option<bool> {
        self.cache_at_startup
    }
    /// <p>The primary key of the data set.</p>
    pub fn primary_key(&self) -> std::option::Option<&crate::model::PrimaryKey> {
        self.primary_key.as_ref()
    }
    /// <p>The alternate key definitions, if any. A legacy dataset might not have any alternate key defined, but if those alternate keys definitions exist, provide them as some applications will make use of them.</p>
    pub fn alternate_keys(&self) -> std::option::Option<&[crate::model::AlternateKey]> {
        self.alternate_keys.as_deref()
    }
}
/// See [`VsamDetailAttributes`](crate::model::VsamDetailAttributes).
pub mod vsam_detail_attributes {

    /// A builder for [`VsamDetailAttributes`](crate::model::VsamDetailAttributes).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) encoding: std::option::Option<std::string::String>,
        pub(crate) record_format: std::option::Option<std::string::String>,
        pub(crate) compressed: std::option::Option<bool>,
        pub(crate) cache_at_startup: std::option::Option<bool>,
        pub(crate) primary_key: std::option::Option<crate::model::PrimaryKey>,
        pub(crate) alternate_keys: std::option::Option<std::vec::Vec<crate::model::AlternateKey>>,
    }
    impl Builder {
        /// <p>The character set used by the data set. Can be ASCII, EBCDIC, or unknown.</p>
        pub fn encoding(mut self, input: impl Into<std::string::String>) -> Self {
            self.encoding = Some(input.into());
            self
        }
        /// <p>The character set used by the data set. Can be ASCII, EBCDIC, or unknown.</p>
        pub fn set_encoding(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.encoding = input;
            self
        }
        /// <p>The record format of the data set.</p>
        pub fn record_format(mut self, input: impl Into<std::string::String>) -> Self {
            self.record_format = Some(input.into());
            self
        }
        /// <p>The record format of the data set.</p>
        pub fn set_record_format(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.record_format = input;
            self
        }
        /// <p>Indicates whether indexes for this dataset are stored as compressed values. If you have a large data set (typically &gt; 100 Mb), consider setting this flag to True.</p>
        pub fn compressed(mut self, input: bool) -> Self {
            self.compressed = Some(input);
            self
        }
        /// <p>Indicates whether indexes for this dataset are stored as compressed values. If you have a large data set (typically &gt; 100 Mb), consider setting this flag to True.</p>
        pub fn set_compressed(mut self, input: std::option::Option<bool>) -> Self {
            self.compressed = input;
            self
        }
        /// <p>If set to True, enforces loading the data set into cache before it’s used by the application.</p>
        pub fn cache_at_startup(mut self, input: bool) -> Self {
            self.cache_at_startup = Some(input);
            self
        }
        /// <p>If set to True, enforces loading the data set into cache before it’s used by the application.</p>
        pub fn set_cache_at_startup(mut self, input: std::option::Option<bool>) -> Self {
            self.cache_at_startup = input;
            self
        }
        /// <p>The primary key of the data set.</p>
        pub fn primary_key(mut self, input: crate::model::PrimaryKey) -> Self {
            self.primary_key = Some(input);
            self
        }
        /// <p>The primary key of the data set.</p>
        pub fn set_primary_key(
            mut self,
            input: std::option::Option<crate::model::PrimaryKey>,
        ) -> Self {
            self.primary_key = input;
            self
        }
        /// Appends an item to `alternate_keys`.
        ///
        /// To override the contents of this collection use [`set_alternate_keys`](Self::set_alternate_keys).
        ///
        /// <p>The alternate key definitions, if any. A legacy dataset might not have any alternate key defined, but if those alternate keys definitions exist, provide them as some applications will make use of them.</p>
        pub fn alternate_keys(mut self, input: crate::model::AlternateKey) -> Self {
            let mut v = self.alternate_keys.unwrap_or_default();
            v.push(input);
            self.alternate_keys = Some(v);
            self
        }
        /// <p>The alternate key definitions, if any. A legacy dataset might not have any alternate key defined, but if those alternate keys definitions exist, provide them as some applications will make use of them.</p>
        pub fn set_alternate_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AlternateKey>>,
        ) -> Self {
            self.alternate_keys = input;
            self
        }
        /// Consumes the builder and constructs a [`VsamDetailAttributes`](crate::model::VsamDetailAttributes).
        pub fn build(self) -> crate::model::VsamDetailAttributes {
            crate::model::VsamDetailAttributes {
                encoding: self.encoding,
                record_format: self.record_format,
                compressed: self.compressed,
                cache_at_startup: self.cache_at_startup,
                primary_key: self.primary_key,
                alternate_keys: self.alternate_keys,
            }
        }
    }
}
impl VsamDetailAttributes {
    /// Creates a new builder-style object to manufacture [`VsamDetailAttributes`](crate::model::VsamDetailAttributes).
    pub fn builder() -> crate::model::vsam_detail_attributes::Builder {
        crate::model::vsam_detail_attributes::Builder::default()
    }
}

/// <p>Defines an alternate key. This value is optional. A legacy data set might not have any alternate key defined but if those alternate keys definitions exist, provide them, as some applications will make use of them.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AlternateKey {
    /// <p>The name of the alternate key.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>A positive integer value representing the offset to mark the start of the alternate key part in the record byte array.</p>
    #[doc(hidden)]
    pub offset: i32,
    /// <p>A strictly positive integer value representing the length of the alternate key.</p>
    #[doc(hidden)]
    pub length: i32,
    /// <p>Indicates whether the alternate key values are supposed to be unique for the given data set.</p>
    #[doc(hidden)]
    pub allow_duplicates: bool,
}
impl AlternateKey {
    /// <p>The name of the alternate key.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>A positive integer value representing the offset to mark the start of the alternate key part in the record byte array.</p>
    pub fn offset(&self) -> i32 {
        self.offset
    }
    /// <p>A strictly positive integer value representing the length of the alternate key.</p>
    pub fn length(&self) -> i32 {
        self.length
    }
    /// <p>Indicates whether the alternate key values are supposed to be unique for the given data set.</p>
    pub fn allow_duplicates(&self) -> bool {
        self.allow_duplicates
    }
}
/// See [`AlternateKey`](crate::model::AlternateKey).
pub mod alternate_key {

    /// A builder for [`AlternateKey`](crate::model::AlternateKey).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) offset: std::option::Option<i32>,
        pub(crate) length: std::option::Option<i32>,
        pub(crate) allow_duplicates: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The name of the alternate key.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the alternate key.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>A positive integer value representing the offset to mark the start of the alternate key part in the record byte array.</p>
        pub fn offset(mut self, input: i32) -> Self {
            self.offset = Some(input);
            self
        }
        /// <p>A positive integer value representing the offset to mark the start of the alternate key part in the record byte array.</p>
        pub fn set_offset(mut self, input: std::option::Option<i32>) -> Self {
            self.offset = input;
            self
        }
        /// <p>A strictly positive integer value representing the length of the alternate key.</p>
        pub fn length(mut self, input: i32) -> Self {
            self.length = Some(input);
            self
        }
        /// <p>A strictly positive integer value representing the length of the alternate key.</p>
        pub fn set_length(mut self, input: std::option::Option<i32>) -> Self {
            self.length = input;
            self
        }
        /// <p>Indicates whether the alternate key values are supposed to be unique for the given data set.</p>
        pub fn allow_duplicates(mut self, input: bool) -> Self {
            self.allow_duplicates = Some(input);
            self
        }
        /// <p>Indicates whether the alternate key values are supposed to be unique for the given data set.</p>
        pub fn set_allow_duplicates(mut self, input: std::option::Option<bool>) -> Self {
            self.allow_duplicates = input;
            self
        }
        /// Consumes the builder and constructs a [`AlternateKey`](crate::model::AlternateKey).
        pub fn build(self) -> crate::model::AlternateKey {
            crate::model::AlternateKey {
                name: self.name,
                offset: self.offset.unwrap_or_default(),
                length: self.length.unwrap_or_default(),
                allow_duplicates: self.allow_duplicates.unwrap_or_default(),
            }
        }
    }
}
impl AlternateKey {
    /// Creates a new builder-style object to manufacture [`AlternateKey`](crate::model::AlternateKey).
    pub fn builder() -> crate::model::alternate_key::Builder {
        crate::model::alternate_key::Builder::default()
    }
}

/// <p>The primary key for a KSDS data set.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PrimaryKey {
    /// <p>A name for the Primary Key.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>A positive integer value representing the offset to mark the start of the primary key in the record byte array.</p>
    #[doc(hidden)]
    pub offset: i32,
    /// <p>A strictly positive integer value representing the length of the primary key. </p>
    #[doc(hidden)]
    pub length: i32,
}
impl PrimaryKey {
    /// <p>A name for the Primary Key.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>A positive integer value representing the offset to mark the start of the primary key in the record byte array.</p>
    pub fn offset(&self) -> i32 {
        self.offset
    }
    /// <p>A strictly positive integer value representing the length of the primary key. </p>
    pub fn length(&self) -> i32 {
        self.length
    }
}
/// See [`PrimaryKey`](crate::model::PrimaryKey).
pub mod primary_key {

    /// A builder for [`PrimaryKey`](crate::model::PrimaryKey).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) offset: std::option::Option<i32>,
        pub(crate) length: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>A name for the Primary Key.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>A name for the Primary Key.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>A positive integer value representing the offset to mark the start of the primary key in the record byte array.</p>
        pub fn offset(mut self, input: i32) -> Self {
            self.offset = Some(input);
            self
        }
        /// <p>A positive integer value representing the offset to mark the start of the primary key in the record byte array.</p>
        pub fn set_offset(mut self, input: std::option::Option<i32>) -> Self {
            self.offset = input;
            self
        }
        /// <p>A strictly positive integer value representing the length of the primary key. </p>
        pub fn length(mut self, input: i32) -> Self {
            self.length = Some(input);
            self
        }
        /// <p>A strictly positive integer value representing the length of the primary key. </p>
        pub fn set_length(mut self, input: std::option::Option<i32>) -> Self {
            self.length = input;
            self
        }
        /// Consumes the builder and constructs a [`PrimaryKey`](crate::model::PrimaryKey).
        pub fn build(self) -> crate::model::PrimaryKey {
            crate::model::PrimaryKey {
                name: self.name,
                offset: self.offset.unwrap_or_default(),
                length: self.length.unwrap_or_default(),
            }
        }
    }
}
impl PrimaryKey {
    /// Creates a new builder-style object to manufacture [`PrimaryKey`](crate::model::PrimaryKey).
    pub fn builder() -> crate::model::primary_key::Builder {
        crate::model::primary_key::Builder::default()
    }
}

/// <p>Identifies one or more data sets you want to import with the <code>CreateDataSetImportTask</code> operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum DataSetImportConfig {
    /// <p>The data sets.</p>
    DataSets(std::vec::Vec<crate::model::DataSetImportItem>),
    /// <p>The Amazon S3 location of the data sets.</p>
    S3Location(std::string::String),
    /// The `Unknown` variant represents cases where new union variant was received. Consider upgrading the SDK to the latest available version.
    /// An unknown enum variant
    ///
    /// _Note: If you encounter this error, consider upgrading your SDK to the latest version._
    /// The `Unknown` variant represents cases where the server sent a value that wasn't recognized
    /// by the client. This can happen when the server adds new functionality, but the client has not been updated.
    /// To investigate this, consider turning on debug logging to print the raw HTTP response.
    #[non_exhaustive]
    Unknown,
}
impl DataSetImportConfig {
    /// Tries to convert the enum instance into [`DataSets`](crate::model::DataSetImportConfig::DataSets), extracting the inner [`Vec`](std::vec::Vec).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_data_sets(
        &self,
    ) -> std::result::Result<&std::vec::Vec<crate::model::DataSetImportItem>, &Self> {
        if let DataSetImportConfig::DataSets(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`DataSets`](crate::model::DataSetImportConfig::DataSets).
    pub fn is_data_sets(&self) -> bool {
        self.as_data_sets().is_ok()
    }
    /// Tries to convert the enum instance into [`S3Location`](crate::model::DataSetImportConfig::S3Location), extracting the inner [`String`](std::string::String).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_s3_location(&self) -> std::result::Result<&std::string::String, &Self> {
        if let DataSetImportConfig::S3Location(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`S3Location`](crate::model::DataSetImportConfig::S3Location).
    pub fn is_s3_location(&self) -> bool {
        self.as_s3_location().is_ok()
    }
    /// Returns true if the enum instance is the `Unknown` variant.
    pub fn is_unknown(&self) -> bool {
        matches!(self, Self::Unknown)
    }
}

/// <p>Identifies a specific data set to import from an external location.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DataSetImportItem {
    /// <p>The data set.</p>
    #[doc(hidden)]
    pub data_set: std::option::Option<crate::model::DataSet>,
    /// <p>The location of the data set.</p>
    #[doc(hidden)]
    pub external_location: std::option::Option<crate::model::ExternalLocation>,
}
impl DataSetImportItem {
    /// <p>The data set.</p>
    pub fn data_set(&self) -> std::option::Option<&crate::model::DataSet> {
        self.data_set.as_ref()
    }
    /// <p>The location of the data set.</p>
    pub fn external_location(&self) -> std::option::Option<&crate::model::ExternalLocation> {
        self.external_location.as_ref()
    }
}
/// See [`DataSetImportItem`](crate::model::DataSetImportItem).
pub mod data_set_import_item {

    /// A builder for [`DataSetImportItem`](crate::model::DataSetImportItem).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) data_set: std::option::Option<crate::model::DataSet>,
        pub(crate) external_location: std::option::Option<crate::model::ExternalLocation>,
    }
    impl Builder {
        /// <p>The data set.</p>
        pub fn data_set(mut self, input: crate::model::DataSet) -> Self {
            self.data_set = Some(input);
            self
        }
        /// <p>The data set.</p>
        pub fn set_data_set(mut self, input: std::option::Option<crate::model::DataSet>) -> Self {
            self.data_set = input;
            self
        }
        /// <p>The location of the data set.</p>
        pub fn external_location(mut self, input: crate::model::ExternalLocation) -> Self {
            self.external_location = Some(input);
            self
        }
        /// <p>The location of the data set.</p>
        pub fn set_external_location(
            mut self,
            input: std::option::Option<crate::model::ExternalLocation>,
        ) -> Self {
            self.external_location = input;
            self
        }
        /// Consumes the builder and constructs a [`DataSetImportItem`](crate::model::DataSetImportItem).
        pub fn build(self) -> crate::model::DataSetImportItem {
            crate::model::DataSetImportItem {
                data_set: self.data_set,
                external_location: self.external_location,
            }
        }
    }
}
impl DataSetImportItem {
    /// Creates a new builder-style object to manufacture [`DataSetImportItem`](crate::model::DataSetImportItem).
    pub fn builder() -> crate::model::data_set_import_item::Builder {
        crate::model::data_set_import_item::Builder::default()
    }
}

/// <p>Defines an external storage location.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum ExternalLocation {
    /// <p>The URI of the Amazon S3 bucket.</p>
    S3Location(std::string::String),
    /// The `Unknown` variant represents cases where new union variant was received. Consider upgrading the SDK to the latest available version.
    /// An unknown enum variant
    ///
    /// _Note: If you encounter this error, consider upgrading your SDK to the latest version._
    /// The `Unknown` variant represents cases where the server sent a value that wasn't recognized
    /// by the client. This can happen when the server adds new functionality, but the client has not been updated.
    /// To investigate this, consider turning on debug logging to print the raw HTTP response.
    #[non_exhaustive]
    Unknown,
}
impl ExternalLocation {
    #[allow(irrefutable_let_patterns)]
    /// Tries to convert the enum instance into [`S3Location`](crate::model::ExternalLocation::S3Location), extracting the inner [`String`](std::string::String).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_s3_location(&self) -> std::result::Result<&std::string::String, &Self> {
        if let ExternalLocation::S3Location(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`S3Location`](crate::model::ExternalLocation::S3Location).
    pub fn is_s3_location(&self) -> bool {
        self.as_s3_location().is_ok()
    }
    /// Returns true if the enum instance is the `Unknown` variant.
    pub fn is_unknown(&self) -> bool {
        matches!(self, Self::Unknown)
    }
}

/// <p>Defines a data set.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DataSet {
    /// <p>The storage type of the data set: database or file system. For Micro Focus, database corresponds to datastore and file system corresponds to EFS/FSX. For Blu Age, there is no support of file system and database corresponds to Blusam. </p>
    #[doc(hidden)]
    pub storage_type: std::option::Option<std::string::String>,
    /// <p>The logical identifier for a specific data set (in mainframe format).</p>
    #[doc(hidden)]
    pub dataset_name: std::option::Option<std::string::String>,
    /// <p>The type of dataset. The only supported value is VSAM.</p>
    #[doc(hidden)]
    pub dataset_org: std::option::Option<crate::model::DatasetOrgAttributes>,
    /// <p>The relative location of the data set in the database or file system. </p>
    #[doc(hidden)]
    pub relative_path: std::option::Option<std::string::String>,
    /// <p>The length of a record.</p>
    #[doc(hidden)]
    pub record_length: std::option::Option<crate::model::RecordLength>,
}
impl DataSet {
    /// <p>The storage type of the data set: database or file system. For Micro Focus, database corresponds to datastore and file system corresponds to EFS/FSX. For Blu Age, there is no support of file system and database corresponds to Blusam. </p>
    pub fn storage_type(&self) -> std::option::Option<&str> {
        self.storage_type.as_deref()
    }
    /// <p>The logical identifier for a specific data set (in mainframe format).</p>
    pub fn dataset_name(&self) -> std::option::Option<&str> {
        self.dataset_name.as_deref()
    }
    /// <p>The type of dataset. The only supported value is VSAM.</p>
    pub fn dataset_org(&self) -> std::option::Option<&crate::model::DatasetOrgAttributes> {
        self.dataset_org.as_ref()
    }
    /// <p>The relative location of the data set in the database or file system. </p>
    pub fn relative_path(&self) -> std::option::Option<&str> {
        self.relative_path.as_deref()
    }
    /// <p>The length of a record.</p>
    pub fn record_length(&self) -> std::option::Option<&crate::model::RecordLength> {
        self.record_length.as_ref()
    }
}
/// See [`DataSet`](crate::model::DataSet).
pub mod data_set {

    /// A builder for [`DataSet`](crate::model::DataSet).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) storage_type: std::option::Option<std::string::String>,
        pub(crate) dataset_name: std::option::Option<std::string::String>,
        pub(crate) dataset_org: std::option::Option<crate::model::DatasetOrgAttributes>,
        pub(crate) relative_path: std::option::Option<std::string::String>,
        pub(crate) record_length: std::option::Option<crate::model::RecordLength>,
    }
    impl Builder {
        /// <p>The storage type of the data set: database or file system. For Micro Focus, database corresponds to datastore and file system corresponds to EFS/FSX. For Blu Age, there is no support of file system and database corresponds to Blusam. </p>
        pub fn storage_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.storage_type = Some(input.into());
            self
        }
        /// <p>The storage type of the data set: database or file system. For Micro Focus, database corresponds to datastore and file system corresponds to EFS/FSX. For Blu Age, there is no support of file system and database corresponds to Blusam. </p>
        pub fn set_storage_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.storage_type = input;
            self
        }
        /// <p>The logical identifier for a specific data set (in mainframe format).</p>
        pub fn dataset_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.dataset_name = Some(input.into());
            self
        }
        /// <p>The logical identifier for a specific data set (in mainframe format).</p>
        pub fn set_dataset_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.dataset_name = input;
            self
        }
        /// <p>The type of dataset. The only supported value is VSAM.</p>
        pub fn dataset_org(mut self, input: crate::model::DatasetOrgAttributes) -> Self {
            self.dataset_org = Some(input);
            self
        }
        /// <p>The type of dataset. The only supported value is VSAM.</p>
        pub fn set_dataset_org(
            mut self,
            input: std::option::Option<crate::model::DatasetOrgAttributes>,
        ) -> Self {
            self.dataset_org = input;
            self
        }
        /// <p>The relative location of the data set in the database or file system. </p>
        pub fn relative_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.relative_path = Some(input.into());
            self
        }
        /// <p>The relative location of the data set in the database or file system. </p>
        pub fn set_relative_path(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.relative_path = input;
            self
        }
        /// <p>The length of a record.</p>
        pub fn record_length(mut self, input: crate::model::RecordLength) -> Self {
            self.record_length = Some(input);
            self
        }
        /// <p>The length of a record.</p>
        pub fn set_record_length(
            mut self,
            input: std::option::Option<crate::model::RecordLength>,
        ) -> Self {
            self.record_length = input;
            self
        }
        /// Consumes the builder and constructs a [`DataSet`](crate::model::DataSet).
        pub fn build(self) -> crate::model::DataSet {
            crate::model::DataSet {
                storage_type: self.storage_type,
                dataset_name: self.dataset_name,
                dataset_org: self.dataset_org,
                relative_path: self.relative_path,
                record_length: self.record_length,
            }
        }
    }
}
impl DataSet {
    /// Creates a new builder-style object to manufacture [`DataSet`](crate::model::DataSet).
    pub fn builder() -> crate::model::data_set::Builder {
        crate::model::data_set::Builder::default()
    }
}

/// <p>The length of the records in the data set.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RecordLength {
    /// <p>The minimum record length of a record.</p>
    #[doc(hidden)]
    pub min: i32,
    /// <p>The maximum record length. In case of fixed, both minimum and maximum are the same.</p>
    #[doc(hidden)]
    pub max: i32,
}
impl RecordLength {
    /// <p>The minimum record length of a record.</p>
    pub fn min(&self) -> i32 {
        self.min
    }
    /// <p>The maximum record length. In case of fixed, both minimum and maximum are the same.</p>
    pub fn max(&self) -> i32 {
        self.max
    }
}
/// See [`RecordLength`](crate::model::RecordLength).
pub mod record_length {

    /// A builder for [`RecordLength`](crate::model::RecordLength).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) min: std::option::Option<i32>,
        pub(crate) max: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The minimum record length of a record.</p>
        pub fn min(mut self, input: i32) -> Self {
            self.min = Some(input);
            self
        }
        /// <p>The minimum record length of a record.</p>
        pub fn set_min(mut self, input: std::option::Option<i32>) -> Self {
            self.min = input;
            self
        }
        /// <p>The maximum record length. In case of fixed, both minimum and maximum are the same.</p>
        pub fn max(mut self, input: i32) -> Self {
            self.max = Some(input);
            self
        }
        /// <p>The maximum record length. In case of fixed, both minimum and maximum are the same.</p>
        pub fn set_max(mut self, input: std::option::Option<i32>) -> Self {
            self.max = input;
            self
        }
        /// Consumes the builder and constructs a [`RecordLength`](crate::model::RecordLength).
        pub fn build(self) -> crate::model::RecordLength {
            crate::model::RecordLength {
                min: self.min.unwrap_or_default(),
                max: self.max.unwrap_or_default(),
            }
        }
    }
}
impl RecordLength {
    /// Creates a new builder-style object to manufacture [`RecordLength`](crate::model::RecordLength).
    pub fn builder() -> crate::model::record_length::Builder {
        crate::model::record_length::Builder::default()
    }
}

/// <p>Additional details about the data set. Different attributes correspond to different data set organizations. The values are populated based on datasetOrg, storageType and backend (Blu Age or Micro Focus).</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum DatasetOrgAttributes {
    /// <p>The generation data group of the data set.</p>
    Gdg(crate::model::GdgAttributes),
    /// <p>The details of a VSAM data set.</p>
    Vsam(crate::model::VsamAttributes),
    /// The `Unknown` variant represents cases where new union variant was received. Consider upgrading the SDK to the latest available version.
    /// An unknown enum variant
    ///
    /// _Note: If you encounter this error, consider upgrading your SDK to the latest version._
    /// The `Unknown` variant represents cases where the server sent a value that wasn't recognized
    /// by the client. This can happen when the server adds new functionality, but the client has not been updated.
    /// To investigate this, consider turning on debug logging to print the raw HTTP response.
    #[non_exhaustive]
    Unknown,
}
impl DatasetOrgAttributes {
    /// Tries to convert the enum instance into [`Gdg`](crate::model::DatasetOrgAttributes::Gdg), extracting the inner [`GdgAttributes`](crate::model::GdgAttributes).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_gdg(&self) -> std::result::Result<&crate::model::GdgAttributes, &Self> {
        if let DatasetOrgAttributes::Gdg(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`Gdg`](crate::model::DatasetOrgAttributes::Gdg).
    pub fn is_gdg(&self) -> bool {
        self.as_gdg().is_ok()
    }
    /// Tries to convert the enum instance into [`Vsam`](crate::model::DatasetOrgAttributes::Vsam), extracting the inner [`VsamAttributes`](crate::model::VsamAttributes).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_vsam(&self) -> std::result::Result<&crate::model::VsamAttributes, &Self> {
        if let DatasetOrgAttributes::Vsam(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`Vsam`](crate::model::DatasetOrgAttributes::Vsam).
    pub fn is_vsam(&self) -> bool {
        self.as_vsam().is_ok()
    }
    /// Returns true if the enum instance is the `Unknown` variant.
    pub fn is_unknown(&self) -> bool {
        matches!(self, Self::Unknown)
    }
}

/// <p>The required attributes for a generation data group data set. A generation data set is one of a collection of successive, historically related, catalogued data sets that together are known as a generation data group (GDG). Use this structure when you want to import a GDG. For more information on GDG, see <a href="https://www.ibm.com/docs/en/zos/2.3.0?topic=guide-generation-data-sets">Generation data sets</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GdgAttributes {
    /// <p>The maximum number of generation data sets, up to 255, in a GDG.</p>
    #[doc(hidden)]
    pub limit: i32,
    /// <p>The disposition of the data set in the catalog.</p>
    #[doc(hidden)]
    pub roll_disposition: std::option::Option<std::string::String>,
}
impl GdgAttributes {
    /// <p>The maximum number of generation data sets, up to 255, in a GDG.</p>
    pub fn limit(&self) -> i32 {
        self.limit
    }
    /// <p>The disposition of the data set in the catalog.</p>
    pub fn roll_disposition(&self) -> std::option::Option<&str> {
        self.roll_disposition.as_deref()
    }
}
/// See [`GdgAttributes`](crate::model::GdgAttributes).
pub mod gdg_attributes {

    /// A builder for [`GdgAttributes`](crate::model::GdgAttributes).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) limit: std::option::Option<i32>,
        pub(crate) roll_disposition: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The maximum number of generation data sets, up to 255, in a GDG.</p>
        pub fn limit(mut self, input: i32) -> Self {
            self.limit = Some(input);
            self
        }
        /// <p>The maximum number of generation data sets, up to 255, in a GDG.</p>
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.limit = input;
            self
        }
        /// <p>The disposition of the data set in the catalog.</p>
        pub fn roll_disposition(mut self, input: impl Into<std::string::String>) -> Self {
            self.roll_disposition = Some(input.into());
            self
        }
        /// <p>The disposition of the data set in the catalog.</p>
        pub fn set_roll_disposition(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.roll_disposition = input;
            self
        }
        /// Consumes the builder and constructs a [`GdgAttributes`](crate::model::GdgAttributes).
        pub fn build(self) -> crate::model::GdgAttributes {
            crate::model::GdgAttributes {
                limit: self.limit.unwrap_or_default(),
                roll_disposition: self.roll_disposition,
            }
        }
    }
}
impl GdgAttributes {
    /// Creates a new builder-style object to manufacture [`GdgAttributes`](crate::model::GdgAttributes).
    pub fn builder() -> crate::model::gdg_attributes::Builder {
        crate::model::gdg_attributes::Builder::default()
    }
}

/// <p>The attributes of a VSAM type data set.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct VsamAttributes {
    /// <p>The record format of the data set.</p>
    #[doc(hidden)]
    pub format: std::option::Option<std::string::String>,
    /// <p>The character set used by the data set. Can be ASCII, EBCDIC, or unknown.</p>
    #[doc(hidden)]
    pub encoding: std::option::Option<std::string::String>,
    /// <p>Indicates whether indexes for this dataset are stored as compressed values. If you have a large data set (typically &gt; 100 Mb), consider setting this flag to True.</p>
    #[doc(hidden)]
    pub compressed: bool,
    /// <p>The primary key of the data set.</p>
    #[doc(hidden)]
    pub primary_key: std::option::Option<crate::model::PrimaryKey>,
    /// <p>The alternate key definitions, if any. A legacy dataset might not have any alternate key defined, but if those alternate keys definitions exist, provide them as some applications will make use of them.</p>
    #[doc(hidden)]
    pub alternate_keys: std::option::Option<std::vec::Vec<crate::model::AlternateKey>>,
}
impl VsamAttributes {
    /// <p>The record format of the data set.</p>
    pub fn format(&self) -> std::option::Option<&str> {
        self.format.as_deref()
    }
    /// <p>The character set used by the data set. Can be ASCII, EBCDIC, or unknown.</p>
    pub fn encoding(&self) -> std::option::Option<&str> {
        self.encoding.as_deref()
    }
    /// <p>Indicates whether indexes for this dataset are stored as compressed values. If you have a large data set (typically &gt; 100 Mb), consider setting this flag to True.</p>
    pub fn compressed(&self) -> bool {
        self.compressed
    }
    /// <p>The primary key of the data set.</p>
    pub fn primary_key(&self) -> std::option::Option<&crate::model::PrimaryKey> {
        self.primary_key.as_ref()
    }
    /// <p>The alternate key definitions, if any. A legacy dataset might not have any alternate key defined, but if those alternate keys definitions exist, provide them as some applications will make use of them.</p>
    pub fn alternate_keys(&self) -> std::option::Option<&[crate::model::AlternateKey]> {
        self.alternate_keys.as_deref()
    }
}
/// See [`VsamAttributes`](crate::model::VsamAttributes).
pub mod vsam_attributes {

    /// A builder for [`VsamAttributes`](crate::model::VsamAttributes).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) format: std::option::Option<std::string::String>,
        pub(crate) encoding: std::option::Option<std::string::String>,
        pub(crate) compressed: std::option::Option<bool>,
        pub(crate) primary_key: std::option::Option<crate::model::PrimaryKey>,
        pub(crate) alternate_keys: std::option::Option<std::vec::Vec<crate::model::AlternateKey>>,
    }
    impl Builder {
        /// <p>The record format of the data set.</p>
        pub fn format(mut self, input: impl Into<std::string::String>) -> Self {
            self.format = Some(input.into());
            self
        }
        /// <p>The record format of the data set.</p>
        pub fn set_format(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.format = input;
            self
        }
        /// <p>The character set used by the data set. Can be ASCII, EBCDIC, or unknown.</p>
        pub fn encoding(mut self, input: impl Into<std::string::String>) -> Self {
            self.encoding = Some(input.into());
            self
        }
        /// <p>The character set used by the data set. Can be ASCII, EBCDIC, or unknown.</p>
        pub fn set_encoding(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.encoding = input;
            self
        }
        /// <p>Indicates whether indexes for this dataset are stored as compressed values. If you have a large data set (typically &gt; 100 Mb), consider setting this flag to True.</p>
        pub fn compressed(mut self, input: bool) -> Self {
            self.compressed = Some(input);
            self
        }
        /// <p>Indicates whether indexes for this dataset are stored as compressed values. If you have a large data set (typically &gt; 100 Mb), consider setting this flag to True.</p>
        pub fn set_compressed(mut self, input: std::option::Option<bool>) -> Self {
            self.compressed = input;
            self
        }
        /// <p>The primary key of the data set.</p>
        pub fn primary_key(mut self, input: crate::model::PrimaryKey) -> Self {
            self.primary_key = Some(input);
            self
        }
        /// <p>The primary key of the data set.</p>
        pub fn set_primary_key(
            mut self,
            input: std::option::Option<crate::model::PrimaryKey>,
        ) -> Self {
            self.primary_key = input;
            self
        }
        /// Appends an item to `alternate_keys`.
        ///
        /// To override the contents of this collection use [`set_alternate_keys`](Self::set_alternate_keys).
        ///
        /// <p>The alternate key definitions, if any. A legacy dataset might not have any alternate key defined, but if those alternate keys definitions exist, provide them as some applications will make use of them.</p>
        pub fn alternate_keys(mut self, input: crate::model::AlternateKey) -> Self {
            let mut v = self.alternate_keys.unwrap_or_default();
            v.push(input);
            self.alternate_keys = Some(v);
            self
        }
        /// <p>The alternate key definitions, if any. A legacy dataset might not have any alternate key defined, but if those alternate keys definitions exist, provide them as some applications will make use of them.</p>
        pub fn set_alternate_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AlternateKey>>,
        ) -> Self {
            self.alternate_keys = input;
            self
        }
        /// Consumes the builder and constructs a [`VsamAttributes`](crate::model::VsamAttributes).
        pub fn build(self) -> crate::model::VsamAttributes {
            crate::model::VsamAttributes {
                format: self.format,
                encoding: self.encoding,
                compressed: self.compressed.unwrap_or_default(),
                primary_key: self.primary_key,
                alternate_keys: self.alternate_keys,
            }
        }
    }
}
impl VsamAttributes {
    /// Creates a new builder-style object to manufacture [`VsamAttributes`](crate::model::VsamAttributes).
    pub fn builder() -> crate::model::vsam_attributes::Builder {
        crate::model::vsam_attributes::Builder::default()
    }
}

/// <p>A subset of the possible application attributes. Used in the application list.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ApplicationSummary {
    /// <p>The name of the application.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The description of the application.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The unique identifier of the application.</p>
    #[doc(hidden)]
    pub application_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the application.</p>
    #[doc(hidden)]
    pub application_arn: std::option::Option<std::string::String>,
    /// <p>The version of the application.</p>
    #[doc(hidden)]
    pub application_version: std::option::Option<i32>,
    /// <p>The status of the application.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::ApplicationLifecycle>,
    /// <p>The type of the target platform for this application.</p>
    #[doc(hidden)]
    pub engine_type: std::option::Option<crate::model::EngineType>,
    /// <p>The timestamp when the application was created.</p>
    #[doc(hidden)]
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The unique identifier of the runtime environment that hosts this application.</p>
    #[doc(hidden)]
    pub environment_id: std::option::Option<std::string::String>,
    /// <p>The timestamp when you last started the application. Null until the application runs for the first time.</p>
    #[doc(hidden)]
    pub last_start_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Indicates the status of the latest version of the application.</p>
    #[doc(hidden)]
    pub version_status: std::option::Option<crate::model::ApplicationVersionLifecycle>,
    /// <p>Indicates either an ongoing deployment or if the application has ever deployed successfully.</p>
    #[doc(hidden)]
    pub deployment_status: std::option::Option<crate::model::ApplicationDeploymentLifecycle>,
}
impl ApplicationSummary {
    /// <p>The name of the application.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The description of the application.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The unique identifier of the application.</p>
    pub fn application_id(&self) -> std::option::Option<&str> {
        self.application_id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the application.</p>
    pub fn application_arn(&self) -> std::option::Option<&str> {
        self.application_arn.as_deref()
    }
    /// <p>The version of the application.</p>
    pub fn application_version(&self) -> std::option::Option<i32> {
        self.application_version
    }
    /// <p>The status of the application.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::ApplicationLifecycle> {
        self.status.as_ref()
    }
    /// <p>The type of the target platform for this application.</p>
    pub fn engine_type(&self) -> std::option::Option<&crate::model::EngineType> {
        self.engine_type.as_ref()
    }
    /// <p>The timestamp when the application was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>The unique identifier of the runtime environment that hosts this application.</p>
    pub fn environment_id(&self) -> std::option::Option<&str> {
        self.environment_id.as_deref()
    }
    /// <p>The timestamp when you last started the application. Null until the application runs for the first time.</p>
    pub fn last_start_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_start_time.as_ref()
    }
    /// <p>Indicates the status of the latest version of the application.</p>
    pub fn version_status(
        &self,
    ) -> std::option::Option<&crate::model::ApplicationVersionLifecycle> {
        self.version_status.as_ref()
    }
    /// <p>Indicates either an ongoing deployment or if the application has ever deployed successfully.</p>
    pub fn deployment_status(
        &self,
    ) -> std::option::Option<&crate::model::ApplicationDeploymentLifecycle> {
        self.deployment_status.as_ref()
    }
}
/// See [`ApplicationSummary`](crate::model::ApplicationSummary).
pub mod application_summary {

    /// A builder for [`ApplicationSummary`](crate::model::ApplicationSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) application_id: std::option::Option<std::string::String>,
        pub(crate) application_arn: std::option::Option<std::string::String>,
        pub(crate) application_version: std::option::Option<i32>,
        pub(crate) status: std::option::Option<crate::model::ApplicationLifecycle>,
        pub(crate) engine_type: std::option::Option<crate::model::EngineType>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) environment_id: std::option::Option<std::string::String>,
        pub(crate) last_start_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) version_status: std::option::Option<crate::model::ApplicationVersionLifecycle>,
        pub(crate) deployment_status:
            std::option::Option<crate::model::ApplicationDeploymentLifecycle>,
    }
    impl Builder {
        /// <p>The name of the application.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the application.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The description of the application.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the application.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The unique identifier of the application.</p>
        pub fn application_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.application_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the application.</p>
        pub fn set_application_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.application_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the application.</p>
        pub fn application_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.application_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the application.</p>
        pub fn set_application_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.application_arn = input;
            self
        }
        /// <p>The version of the application.</p>
        pub fn application_version(mut self, input: i32) -> Self {
            self.application_version = Some(input);
            self
        }
        /// <p>The version of the application.</p>
        pub fn set_application_version(mut self, input: std::option::Option<i32>) -> Self {
            self.application_version = input;
            self
        }
        /// <p>The status of the application.</p>
        pub fn status(mut self, input: crate::model::ApplicationLifecycle) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the application.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::ApplicationLifecycle>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The type of the target platform for this application.</p>
        pub fn engine_type(mut self, input: crate::model::EngineType) -> Self {
            self.engine_type = Some(input);
            self
        }
        /// <p>The type of the target platform for this application.</p>
        pub fn set_engine_type(
            mut self,
            input: std::option::Option<crate::model::EngineType>,
        ) -> Self {
            self.engine_type = input;
            self
        }
        /// <p>The timestamp when the application was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The timestamp when the application was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The unique identifier of the runtime environment that hosts this application.</p>
        pub fn environment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.environment_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the runtime environment that hosts this application.</p>
        pub fn set_environment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.environment_id = input;
            self
        }
        /// <p>The timestamp when you last started the application. Null until the application runs for the first time.</p>
        pub fn last_start_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_start_time = Some(input);
            self
        }
        /// <p>The timestamp when you last started the application. Null until the application runs for the first time.</p>
        pub fn set_last_start_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_start_time = input;
            self
        }
        /// <p>Indicates the status of the latest version of the application.</p>
        pub fn version_status(mut self, input: crate::model::ApplicationVersionLifecycle) -> Self {
            self.version_status = Some(input);
            self
        }
        /// <p>Indicates the status of the latest version of the application.</p>
        pub fn set_version_status(
            mut self,
            input: std::option::Option<crate::model::ApplicationVersionLifecycle>,
        ) -> Self {
            self.version_status = input;
            self
        }
        /// <p>Indicates either an ongoing deployment or if the application has ever deployed successfully.</p>
        pub fn deployment_status(
            mut self,
            input: crate::model::ApplicationDeploymentLifecycle,
        ) -> Self {
            self.deployment_status = Some(input);
            self
        }
        /// <p>Indicates either an ongoing deployment or if the application has ever deployed successfully.</p>
        pub fn set_deployment_status(
            mut self,
            input: std::option::Option<crate::model::ApplicationDeploymentLifecycle>,
        ) -> Self {
            self.deployment_status = input;
            self
        }
        /// Consumes the builder and constructs a [`ApplicationSummary`](crate::model::ApplicationSummary).
        pub fn build(self) -> crate::model::ApplicationSummary {
            crate::model::ApplicationSummary {
                name: self.name,
                description: self.description,
                application_id: self.application_id,
                application_arn: self.application_arn,
                application_version: self.application_version,
                status: self.status,
                engine_type: self.engine_type,
                creation_time: self.creation_time,
                environment_id: self.environment_id,
                last_start_time: self.last_start_time,
                version_status: self.version_status,
                deployment_status: self.deployment_status,
            }
        }
    }
}
impl ApplicationSummary {
    /// Creates a new builder-style object to manufacture [`ApplicationSummary`](crate::model::ApplicationSummary).
    pub fn builder() -> crate::model::application_summary::Builder {
        crate::model::application_summary::Builder::default()
    }
}

/// When writing a match expression against `ApplicationDeploymentLifecycle`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let applicationdeploymentlifecycle = unimplemented!();
/// match applicationdeploymentlifecycle {
///     ApplicationDeploymentLifecycle::Deployed => { /* ... */ },
///     ApplicationDeploymentLifecycle::Deploying => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `applicationdeploymentlifecycle` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ApplicationDeploymentLifecycle::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ApplicationDeploymentLifecycle::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ApplicationDeploymentLifecycle::NewFeature` is defined.
/// Specifically, when `applicationdeploymentlifecycle` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ApplicationDeploymentLifecycle::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ApplicationDeploymentLifecycle {
    #[allow(missing_docs)] // documentation missing in model
    Deployed,
    #[allow(missing_docs)] // documentation missing in model
    Deploying,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ApplicationDeploymentLifecycle {
    fn from(s: &str) -> Self {
        match s {
            "Deployed" => ApplicationDeploymentLifecycle::Deployed,
            "Deploying" => ApplicationDeploymentLifecycle::Deploying,
            other => ApplicationDeploymentLifecycle::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for ApplicationDeploymentLifecycle {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ApplicationDeploymentLifecycle::from(s))
    }
}
impl ApplicationDeploymentLifecycle {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ApplicationDeploymentLifecycle::Deployed => "Deployed",
            ApplicationDeploymentLifecycle::Deploying => "Deploying",
            ApplicationDeploymentLifecycle::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["Deployed", "Deploying"]
    }
}
impl AsRef<str> for ApplicationDeploymentLifecycle {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `ApplicationLifecycle`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let applicationlifecycle = unimplemented!();
/// match applicationlifecycle {
///     ApplicationLifecycle::Available => { /* ... */ },
///     ApplicationLifecycle::Created => { /* ... */ },
///     ApplicationLifecycle::Creating => { /* ... */ },
///     ApplicationLifecycle::Deleting => { /* ... */ },
///     ApplicationLifecycle::DeletingFromEnvironment => { /* ... */ },
///     ApplicationLifecycle::Failed => { /* ... */ },
///     ApplicationLifecycle::Ready => { /* ... */ },
///     ApplicationLifecycle::Running => { /* ... */ },
///     ApplicationLifecycle::Starting => { /* ... */ },
///     ApplicationLifecycle::Stopped => { /* ... */ },
///     ApplicationLifecycle::Stopping => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `applicationlifecycle` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ApplicationLifecycle::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ApplicationLifecycle::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ApplicationLifecycle::NewFeature` is defined.
/// Specifically, when `applicationlifecycle` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ApplicationLifecycle::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ApplicationLifecycle {
    #[allow(missing_docs)] // documentation missing in model
    Available,
    #[allow(missing_docs)] // documentation missing in model
    Created,
    #[allow(missing_docs)] // documentation missing in model
    Creating,
    #[allow(missing_docs)] // documentation missing in model
    Deleting,
    #[allow(missing_docs)] // documentation missing in model
    DeletingFromEnvironment,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    Ready,
    #[allow(missing_docs)] // documentation missing in model
    Running,
    #[allow(missing_docs)] // documentation missing in model
    Starting,
    #[allow(missing_docs)] // documentation missing in model
    Stopped,
    #[allow(missing_docs)] // documentation missing in model
    Stopping,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ApplicationLifecycle {
    fn from(s: &str) -> Self {
        match s {
            "Available" => ApplicationLifecycle::Available,
            "Created" => ApplicationLifecycle::Created,
            "Creating" => ApplicationLifecycle::Creating,
            "Deleting" => ApplicationLifecycle::Deleting,
            "Deleting From Environment" => ApplicationLifecycle::DeletingFromEnvironment,
            "Failed" => ApplicationLifecycle::Failed,
            "Ready" => ApplicationLifecycle::Ready,
            "Running" => ApplicationLifecycle::Running,
            "Starting" => ApplicationLifecycle::Starting,
            "Stopped" => ApplicationLifecycle::Stopped,
            "Stopping" => ApplicationLifecycle::Stopping,
            other => {
                ApplicationLifecycle::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for ApplicationLifecycle {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ApplicationLifecycle::from(s))
    }
}
impl ApplicationLifecycle {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ApplicationLifecycle::Available => "Available",
            ApplicationLifecycle::Created => "Created",
            ApplicationLifecycle::Creating => "Creating",
            ApplicationLifecycle::Deleting => "Deleting",
            ApplicationLifecycle::DeletingFromEnvironment => "Deleting From Environment",
            ApplicationLifecycle::Failed => "Failed",
            ApplicationLifecycle::Ready => "Ready",
            ApplicationLifecycle::Running => "Running",
            ApplicationLifecycle::Starting => "Starting",
            ApplicationLifecycle::Stopped => "Stopped",
            ApplicationLifecycle::Stopping => "Stopping",
            ApplicationLifecycle::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "Available",
            "Created",
            "Creating",
            "Deleting",
            "Deleting From Environment",
            "Failed",
            "Ready",
            "Running",
            "Starting",
            "Stopped",
            "Stopping",
        ]
    }
}
impl AsRef<str> for ApplicationLifecycle {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The application definition for a particular application. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum Definition {
    /// <p>The content of the application definition. This is a JSON object that contains the resource configuration/definitions that identify an application.</p>
    Content(std::string::String),
    /// <p>The S3 bucket that contains the application definition.</p>
    S3Location(std::string::String),
    /// The `Unknown` variant represents cases where new union variant was received. Consider upgrading the SDK to the latest available version.
    /// An unknown enum variant
    ///
    /// _Note: If you encounter this error, consider upgrading your SDK to the latest version._
    /// The `Unknown` variant represents cases where the server sent a value that wasn't recognized
    /// by the client. This can happen when the server adds new functionality, but the client has not been updated.
    /// To investigate this, consider turning on debug logging to print the raw HTTP response.
    #[non_exhaustive]
    Unknown,
}
impl Definition {
    /// Tries to convert the enum instance into [`Content`](crate::model::Definition::Content), extracting the inner [`String`](std::string::String).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_content(&self) -> std::result::Result<&std::string::String, &Self> {
        if let Definition::Content(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`Content`](crate::model::Definition::Content).
    pub fn is_content(&self) -> bool {
        self.as_content().is_ok()
    }
    /// Tries to convert the enum instance into [`S3Location`](crate::model::Definition::S3Location), extracting the inner [`String`](std::string::String).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_s3_location(&self) -> std::result::Result<&std::string::String, &Self> {
        if let Definition::S3Location(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`S3Location`](crate::model::Definition::S3Location).
    pub fn is_s3_location(&self) -> bool {
        self.as_s3_location().is_ok()
    }
    /// Returns true if the enum instance is the `Unknown` variant.
    pub fn is_unknown(&self) -> bool {
        matches!(self, Self::Unknown)
    }
}

/// <p>A subset of the attributes that describe a log group. In CloudWatch a log group is a group of log streams that share the same retention, monitoring, and access control settings.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LogGroupSummary {
    /// <p>The type of log.</p>
    #[doc(hidden)]
    pub log_type: std::option::Option<std::string::String>,
    /// <p>The name of the log group.</p>
    #[doc(hidden)]
    pub log_group_name: std::option::Option<std::string::String>,
}
impl LogGroupSummary {
    /// <p>The type of log.</p>
    pub fn log_type(&self) -> std::option::Option<&str> {
        self.log_type.as_deref()
    }
    /// <p>The name of the log group.</p>
    pub fn log_group_name(&self) -> std::option::Option<&str> {
        self.log_group_name.as_deref()
    }
}
/// See [`LogGroupSummary`](crate::model::LogGroupSummary).
pub mod log_group_summary {

    /// A builder for [`LogGroupSummary`](crate::model::LogGroupSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) log_type: std::option::Option<std::string::String>,
        pub(crate) log_group_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The type of log.</p>
        pub fn log_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.log_type = Some(input.into());
            self
        }
        /// <p>The type of log.</p>
        pub fn set_log_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.log_type = input;
            self
        }
        /// <p>The name of the log group.</p>
        pub fn log_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.log_group_name = Some(input.into());
            self
        }
        /// <p>The name of the log group.</p>
        pub fn set_log_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.log_group_name = input;
            self
        }
        /// Consumes the builder and constructs a [`LogGroupSummary`](crate::model::LogGroupSummary).
        pub fn build(self) -> crate::model::LogGroupSummary {
            crate::model::LogGroupSummary {
                log_type: self.log_type,
                log_group_name: self.log_group_name,
            }
        }
    }
}
impl LogGroupSummary {
    /// Creates a new builder-style object to manufacture [`LogGroupSummary`](crate::model::LogGroupSummary).
    pub fn builder() -> crate::model::log_group_summary::Builder {
        crate::model::log_group_summary::Builder::default()
    }
}

/// <p>Contains a summary of a deployed application.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeployedVersionSummary {
    /// <p>The version of the deployed application.</p>
    #[doc(hidden)]
    pub application_version: std::option::Option<i32>,
    /// <p>The status of the deployment.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::DeploymentLifecycle>,
    /// <p>The reason for the reported status.</p>
    #[doc(hidden)]
    pub status_reason: std::option::Option<std::string::String>,
}
impl DeployedVersionSummary {
    /// <p>The version of the deployed application.</p>
    pub fn application_version(&self) -> std::option::Option<i32> {
        self.application_version
    }
    /// <p>The status of the deployment.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::DeploymentLifecycle> {
        self.status.as_ref()
    }
    /// <p>The reason for the reported status.</p>
    pub fn status_reason(&self) -> std::option::Option<&str> {
        self.status_reason.as_deref()
    }
}
/// See [`DeployedVersionSummary`](crate::model::DeployedVersionSummary).
pub mod deployed_version_summary {

    /// A builder for [`DeployedVersionSummary`](crate::model::DeployedVersionSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) application_version: std::option::Option<i32>,
        pub(crate) status: std::option::Option<crate::model::DeploymentLifecycle>,
        pub(crate) status_reason: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The version of the deployed application.</p>
        pub fn application_version(mut self, input: i32) -> Self {
            self.application_version = Some(input);
            self
        }
        /// <p>The version of the deployed application.</p>
        pub fn set_application_version(mut self, input: std::option::Option<i32>) -> Self {
            self.application_version = input;
            self
        }
        /// <p>The status of the deployment.</p>
        pub fn status(mut self, input: crate::model::DeploymentLifecycle) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the deployment.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::DeploymentLifecycle>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The reason for the reported status.</p>
        pub fn status_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.status_reason = Some(input.into());
            self
        }
        /// <p>The reason for the reported status.</p>
        pub fn set_status_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.status_reason = input;
            self
        }
        /// Consumes the builder and constructs a [`DeployedVersionSummary`](crate::model::DeployedVersionSummary).
        pub fn build(self) -> crate::model::DeployedVersionSummary {
            crate::model::DeployedVersionSummary {
                application_version: self.application_version,
                status: self.status,
                status_reason: self.status_reason,
            }
        }
    }
}
impl DeployedVersionSummary {
    /// Creates a new builder-style object to manufacture [`DeployedVersionSummary`](crate::model::DeployedVersionSummary).
    pub fn builder() -> crate::model::deployed_version_summary::Builder {
        crate::model::deployed_version_summary::Builder::default()
    }
}

/// <p>A subset of information about the engine version for a specific application.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EngineVersionsSummary {
    /// <p>The type of target platform for the application.</p>
    #[doc(hidden)]
    pub engine_type: std::option::Option<std::string::String>,
    /// <p>The version of the engine type used by the application.</p>
    #[doc(hidden)]
    pub engine_version: std::option::Option<std::string::String>,
}
impl EngineVersionsSummary {
    /// <p>The type of target platform for the application.</p>
    pub fn engine_type(&self) -> std::option::Option<&str> {
        self.engine_type.as_deref()
    }
    /// <p>The version of the engine type used by the application.</p>
    pub fn engine_version(&self) -> std::option::Option<&str> {
        self.engine_version.as_deref()
    }
}
/// See [`EngineVersionsSummary`](crate::model::EngineVersionsSummary).
pub mod engine_versions_summary {

    /// A builder for [`EngineVersionsSummary`](crate::model::EngineVersionsSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) engine_type: std::option::Option<std::string::String>,
        pub(crate) engine_version: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The type of target platform for the application.</p>
        pub fn engine_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.engine_type = Some(input.into());
            self
        }
        /// <p>The type of target platform for the application.</p>
        pub fn set_engine_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.engine_type = input;
            self
        }
        /// <p>The version of the engine type used by the application.</p>
        pub fn engine_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.engine_version = Some(input.into());
            self
        }
        /// <p>The version of the engine type used by the application.</p>
        pub fn set_engine_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.engine_version = input;
            self
        }
        /// Consumes the builder and constructs a [`EngineVersionsSummary`](crate::model::EngineVersionsSummary).
        pub fn build(self) -> crate::model::EngineVersionsSummary {
            crate::model::EngineVersionsSummary {
                engine_type: self.engine_type,
                engine_version: self.engine_version,
            }
        }
    }
}
impl EngineVersionsSummary {
    /// Creates a new builder-style object to manufacture [`EngineVersionsSummary`](crate::model::EngineVersionsSummary).
    pub fn builder() -> crate::model::engine_versions_summary::Builder {
        crate::model::engine_versions_summary::Builder::default()
    }
}
