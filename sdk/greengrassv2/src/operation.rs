// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// <p>Associate a list of client devices with a core device. Use this API operation to specify
/// which client devices can discover a core device through cloud discovery. With cloud discovery,
/// client devices connect to IoT Greengrass to retrieve associated core devices' connectivity information
/// and certificates. For more information, see <a href="https://docs.aws.amazon.com/greengrass/v2/developerguide/configure-cloud-discovery.html">Configure cloud
/// discovery</a> in the <i>IoT Greengrass V2 Developer Guide</i>.</p>
/// <note>
/// <p>Client devices are local IoT devices that connect to and communicate with an IoT Greengrass core
/// device over MQTT. You can connect client devices to a core device to sync MQTT messages and
/// data to Amazon Web Services IoT Core and interact with client devices in Greengrass components. For more information,
/// see <a href="https://docs.aws.amazon.com/greengrass/v2/developerguide/interact-with-local-iot-devices.html">Interact with
/// local IoT devices</a> in the <i>IoT Greengrass V2 Developer Guide</i>.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct BatchAssociateClientDeviceWithCoreDevice {
    _private: (),
}
impl BatchAssociateClientDeviceWithCoreDevice {
    /// Creates a new builder-style object to manufacture [`BatchAssociateClientDeviceWithCoreDeviceInput`](crate::input::BatchAssociateClientDeviceWithCoreDeviceInput)
    pub fn builder() -> crate::input::batch_associate_client_device_with_core_device_input::Builder
    {
        crate::input::batch_associate_client_device_with_core_device_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for BatchAssociateClientDeviceWithCoreDevice {
    type Output = std::result::Result<
        crate::output::BatchAssociateClientDeviceWithCoreDeviceOutput,
        crate::error::BatchAssociateClientDeviceWithCoreDeviceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_batch_associate_client_device_with_core_device_error(
                response,
            )
        } else {
            crate::operation_deser::parse_batch_associate_client_device_with_core_device_response(
                response,
            )
        }
    }
}

/// <p>Disassociate a list of client devices from a core device. After you disassociate a client
/// device from a core device, the client device won't be able to use cloud discovery to retrieve
/// the core device's connectivity information and certificates.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct BatchDisassociateClientDeviceFromCoreDevice {
    _private: (),
}
impl BatchDisassociateClientDeviceFromCoreDevice {
    /// Creates a new builder-style object to manufacture [`BatchDisassociateClientDeviceFromCoreDeviceInput`](crate::input::BatchDisassociateClientDeviceFromCoreDeviceInput)
    pub fn builder(
    ) -> crate::input::batch_disassociate_client_device_from_core_device_input::Builder {
        crate::input::batch_disassociate_client_device_from_core_device_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for BatchDisassociateClientDeviceFromCoreDevice {
    type Output = std::result::Result<
        crate::output::BatchDisassociateClientDeviceFromCoreDeviceOutput,
        crate::error::BatchDisassociateClientDeviceFromCoreDeviceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_batch_disassociate_client_device_from_core_device_error(
                response,
            )
        } else {
            crate::operation_deser::parse_batch_disassociate_client_device_from_core_device_response(
                response,
            )
        }
    }
}

/// <p>Cancels a deployment. This operation cancels the deployment for devices that haven't yet
/// received it. If a device already received the deployment, this operation doesn't change
/// anything for that device.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CancelDeployment {
    _private: (),
}
impl CancelDeployment {
    /// Creates a new builder-style object to manufacture [`CancelDeploymentInput`](crate::input::CancelDeploymentInput)
    pub fn builder() -> crate::input::cancel_deployment_input::Builder {
        crate::input::cancel_deployment_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CancelDeployment {
    type Output = std::result::Result<
        crate::output::CancelDeploymentOutput,
        crate::error::CancelDeploymentError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_cancel_deployment_error(response)
        } else {
            crate::operation_deser::parse_cancel_deployment_response(response)
        }
    }
}

/// <p>Creates a component. Components are software that run on Greengrass core devices. After you
/// develop and test a component on your core device, you can use this operation to upload your
/// component to IoT Greengrass. Then, you can deploy the component to other core devices.</p>
/// <p>You can use this operation to do the following:</p>
/// <ul>
/// <li>
/// <p>
/// <b>Create components from recipes</b>
/// </p>
/// <p>Create a component from a recipe, which is a file that defines the component's
/// metadata, parameters, dependencies, lifecycle, artifacts, and platform capability. For
/// more information, see <a href="https://docs.aws.amazon.com/greengrass/v2/developerguide/component-recipe-reference.html">IoT Greengrass component recipe
/// reference</a> in the <i>IoT Greengrass V2 Developer Guide</i>.</p>
/// <p>To create a component from a recipe, specify <code>inlineRecipe</code> when you call
/// this operation.</p>
/// </li>
/// <li>
/// <p>
/// <b>Create components from Lambda functions</b>
/// </p>
/// <p>Create a component from an Lambda function that runs on IoT Greengrass. This creates a recipe
/// and artifacts from the Lambda function's deployment package. You can use this operation to
/// migrate Lambda functions from IoT Greengrass V1 to IoT Greengrass V2.</p>
/// <p>This function only accepts Lambda functions that use the following runtimes:</p>
/// <ul>
/// <li>
/// <p>Python 2.7 – <code>python2.7</code>
/// </p>
/// </li>
/// <li>
/// <p>Python 3.7 – <code>python3.7</code>
/// </p>
/// </li>
/// <li>
/// <p>Python 3.8 – <code>python3.8</code>
/// </p>
/// </li>
/// <li>
/// <p>Java 8 – <code>java8</code>
/// </p>
/// </li>
/// <li>
/// <p>Node.js 10 – <code>nodejs10.x</code>
/// </p>
/// </li>
/// <li>
/// <p>Node.js 12 – <code>nodejs12.x</code>
/// </p>
/// </li>
/// </ul>
/// <p>To create a component from a Lambda function, specify <code>lambdaFunction</code>
/// when you call this operation.</p>
/// </li>
/// </ul>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateComponentVersion {
    _private: (),
}
impl CreateComponentVersion {
    /// Creates a new builder-style object to manufacture [`CreateComponentVersionInput`](crate::input::CreateComponentVersionInput)
    pub fn builder() -> crate::input::create_component_version_input::Builder {
        crate::input::create_component_version_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateComponentVersion {
    type Output = std::result::Result<
        crate::output::CreateComponentVersionOutput,
        crate::error::CreateComponentVersionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 201 {
            crate::operation_deser::parse_create_component_version_error(response)
        } else {
            crate::operation_deser::parse_create_component_version_response(response)
        }
    }
}

/// <p>Creates a continuous deployment for a target, which is a Greengrass core device or group of core
/// devices. When you add a new core device to a group of core devices that has a deployment, IoT Greengrass
/// deploys that group's deployment to the new device.</p>
/// <p>You can define one deployment for each target. When you create a new deployment for a
/// target that has an existing deployment, you replace the previous deployment. IoT Greengrass applies the
/// new deployment to the target devices.</p>
/// <p>Every deployment has a revision number that indicates how many deployment revisions you
/// define for a target. Use this operation to create a new revision of an existing deployment.
/// This operation returns the revision number of the new deployment when you create it.</p>
/// <p>For more information, see the <a href="https://docs.aws.amazon.com/greengrass/v2/developerguide/create-deployments.html">Create deployments</a> in the
/// <i>IoT Greengrass V2 Developer Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateDeployment {
    _private: (),
}
impl CreateDeployment {
    /// Creates a new builder-style object to manufacture [`CreateDeploymentInput`](crate::input::CreateDeploymentInput)
    pub fn builder() -> crate::input::create_deployment_input::Builder {
        crate::input::create_deployment_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateDeployment {
    type Output = std::result::Result<
        crate::output::CreateDeploymentOutput,
        crate::error::CreateDeploymentError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 201 {
            crate::operation_deser::parse_create_deployment_error(response)
        } else {
            crate::operation_deser::parse_create_deployment_response(response)
        }
    }
}

/// <p>Deletes a version of a component from IoT Greengrass.</p>
/// <note>
/// <p>This operation deletes the component's recipe and artifacts. As a result, deployments
/// that refer to this component version will fail. If you have deployments that use this
/// component version, you can remove the component from the deployment or update the deployment
/// to use a valid version.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteComponent {
    _private: (),
}
impl DeleteComponent {
    /// Creates a new builder-style object to manufacture [`DeleteComponentInput`](crate::input::DeleteComponentInput)
    pub fn builder() -> crate::input::delete_component_input::Builder {
        crate::input::delete_component_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteComponent {
    type Output = std::result::Result<
        crate::output::DeleteComponentOutput,
        crate::error::DeleteComponentError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 204 {
            crate::operation_deser::parse_delete_component_error(response)
        } else {
            crate::operation_deser::parse_delete_component_response(response)
        }
    }
}

/// <p>Deletes a Greengrass core device, which is an IoT thing. This operation removes the core
/// device from the list of core devices. This operation doesn't delete the IoT thing. For more
/// information about how to delete the IoT thing, see <a href="https://docs.aws.amazon.com/iot/latest/apireference/API_DeleteThing.html">DeleteThing</a> in the
/// <i>IoT API Reference</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteCoreDevice {
    _private: (),
}
impl DeleteCoreDevice {
    /// Creates a new builder-style object to manufacture [`DeleteCoreDeviceInput`](crate::input::DeleteCoreDeviceInput)
    pub fn builder() -> crate::input::delete_core_device_input::Builder {
        crate::input::delete_core_device_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteCoreDevice {
    type Output = std::result::Result<
        crate::output::DeleteCoreDeviceOutput,
        crate::error::DeleteCoreDeviceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 204 {
            crate::operation_deser::parse_delete_core_device_error(response)
        } else {
            crate::operation_deser::parse_delete_core_device_response(response)
        }
    }
}

/// <p>Retrieves metadata for a version of a component.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeComponent {
    _private: (),
}
impl DescribeComponent {
    /// Creates a new builder-style object to manufacture [`DescribeComponentInput`](crate::input::DescribeComponentInput)
    pub fn builder() -> crate::input::describe_component_input::Builder {
        crate::input::describe_component_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeComponent {
    type Output = std::result::Result<
        crate::output::DescribeComponentOutput,
        crate::error::DescribeComponentError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_component_error(response)
        } else {
            crate::operation_deser::parse_describe_component_response(response)
        }
    }
}

/// <p>Gets the recipe for a version of a component. Core devices can call this operation to
/// identify the artifacts and requirements to install a component.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetComponent {
    _private: (),
}
impl GetComponent {
    /// Creates a new builder-style object to manufacture [`GetComponentInput`](crate::input::GetComponentInput)
    pub fn builder() -> crate::input::get_component_input::Builder {
        crate::input::get_component_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetComponent {
    type Output =
        std::result::Result<crate::output::GetComponentOutput, crate::error::GetComponentError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_component_error(response)
        } else {
            crate::operation_deser::parse_get_component_response(response)
        }
    }
}

/// <p>Gets the pre-signed URL to download a public component artifact. Core devices call this
/// operation to identify the URL that they can use to download an artifact to install.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetComponentVersionArtifact {
    _private: (),
}
impl GetComponentVersionArtifact {
    /// Creates a new builder-style object to manufacture [`GetComponentVersionArtifactInput`](crate::input::GetComponentVersionArtifactInput)
    pub fn builder() -> crate::input::get_component_version_artifact_input::Builder {
        crate::input::get_component_version_artifact_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetComponentVersionArtifact {
    type Output = std::result::Result<
        crate::output::GetComponentVersionArtifactOutput,
        crate::error::GetComponentVersionArtifactError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_component_version_artifact_error(response)
        } else {
            crate::operation_deser::parse_get_component_version_artifact_response(response)
        }
    }
}

/// <p>Retrieves metadata for a Greengrass core device.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetCoreDevice {
    _private: (),
}
impl GetCoreDevice {
    /// Creates a new builder-style object to manufacture [`GetCoreDeviceInput`](crate::input::GetCoreDeviceInput)
    pub fn builder() -> crate::input::get_core_device_input::Builder {
        crate::input::get_core_device_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetCoreDevice {
    type Output =
        std::result::Result<crate::output::GetCoreDeviceOutput, crate::error::GetCoreDeviceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_core_device_error(response)
        } else {
            crate::operation_deser::parse_get_core_device_response(response)
        }
    }
}

/// <p>Gets a deployment. Deployments define the components that run on Greengrass core devices.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetDeployment {
    _private: (),
}
impl GetDeployment {
    /// Creates a new builder-style object to manufacture [`GetDeploymentInput`](crate::input::GetDeploymentInput)
    pub fn builder() -> crate::input::get_deployment_input::Builder {
        crate::input::get_deployment_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetDeployment {
    type Output =
        std::result::Result<crate::output::GetDeploymentOutput, crate::error::GetDeploymentError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_deployment_error(response)
        } else {
            crate::operation_deser::parse_get_deployment_response(response)
        }
    }
}

/// <p>Retrieves a paginated list of client devices that are associated with a core
/// device.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListClientDevicesAssociatedWithCoreDevice {
    _private: (),
}
impl ListClientDevicesAssociatedWithCoreDevice {
    /// Creates a new builder-style object to manufacture [`ListClientDevicesAssociatedWithCoreDeviceInput`](crate::input::ListClientDevicesAssociatedWithCoreDeviceInput)
    pub fn builder() -> crate::input::list_client_devices_associated_with_core_device_input::Builder
    {
        crate::input::list_client_devices_associated_with_core_device_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListClientDevicesAssociatedWithCoreDevice {
    type Output = std::result::Result<
        crate::output::ListClientDevicesAssociatedWithCoreDeviceOutput,
        crate::error::ListClientDevicesAssociatedWithCoreDeviceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_client_devices_associated_with_core_device_error(
                response,
            )
        } else {
            crate::operation_deser::parse_list_client_devices_associated_with_core_device_response(
                response,
            )
        }
    }
}

/// <p>Retrieves a paginated list of component summaries. This list includes components that you
/// have permission to view.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListComponents {
    _private: (),
}
impl ListComponents {
    /// Creates a new builder-style object to manufacture [`ListComponentsInput`](crate::input::ListComponentsInput)
    pub fn builder() -> crate::input::list_components_input::Builder {
        crate::input::list_components_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListComponents {
    type Output =
        std::result::Result<crate::output::ListComponentsOutput, crate::error::ListComponentsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_components_error(response)
        } else {
            crate::operation_deser::parse_list_components_response(response)
        }
    }
}

/// <p>Retrieves a paginated list of all versions for a component. Greater versions are listed first.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListComponentVersions {
    _private: (),
}
impl ListComponentVersions {
    /// Creates a new builder-style object to manufacture [`ListComponentVersionsInput`](crate::input::ListComponentVersionsInput)
    pub fn builder() -> crate::input::list_component_versions_input::Builder {
        crate::input::list_component_versions_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListComponentVersions {
    type Output = std::result::Result<
        crate::output::ListComponentVersionsOutput,
        crate::error::ListComponentVersionsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_component_versions_error(response)
        } else {
            crate::operation_deser::parse_list_component_versions_response(response)
        }
    }
}

/// <p>Retrieves a paginated list of Greengrass core devices.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListCoreDevices {
    _private: (),
}
impl ListCoreDevices {
    /// Creates a new builder-style object to manufacture [`ListCoreDevicesInput`](crate::input::ListCoreDevicesInput)
    pub fn builder() -> crate::input::list_core_devices_input::Builder {
        crate::input::list_core_devices_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListCoreDevices {
    type Output = std::result::Result<
        crate::output::ListCoreDevicesOutput,
        crate::error::ListCoreDevicesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_core_devices_error(response)
        } else {
            crate::operation_deser::parse_list_core_devices_response(response)
        }
    }
}

/// <p>Retrieves a paginated list of deployments.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListDeployments {
    _private: (),
}
impl ListDeployments {
    /// Creates a new builder-style object to manufacture [`ListDeploymentsInput`](crate::input::ListDeploymentsInput)
    pub fn builder() -> crate::input::list_deployments_input::Builder {
        crate::input::list_deployments_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListDeployments {
    type Output = std::result::Result<
        crate::output::ListDeploymentsOutput,
        crate::error::ListDeploymentsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_deployments_error(response)
        } else {
            crate::operation_deser::parse_list_deployments_response(response)
        }
    }
}

/// <p>Retrieves a paginated list of deployment jobs that IoT Greengrass sends to Greengrass core
/// devices.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListEffectiveDeployments {
    _private: (),
}
impl ListEffectiveDeployments {
    /// Creates a new builder-style object to manufacture [`ListEffectiveDeploymentsInput`](crate::input::ListEffectiveDeploymentsInput)
    pub fn builder() -> crate::input::list_effective_deployments_input::Builder {
        crate::input::list_effective_deployments_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListEffectiveDeployments {
    type Output = std::result::Result<
        crate::output::ListEffectiveDeploymentsOutput,
        crate::error::ListEffectiveDeploymentsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_effective_deployments_error(response)
        } else {
            crate::operation_deser::parse_list_effective_deployments_response(response)
        }
    }
}

/// <p>Retrieves a paginated list of the components that a Greengrass core device runs.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListInstalledComponents {
    _private: (),
}
impl ListInstalledComponents {
    /// Creates a new builder-style object to manufacture [`ListInstalledComponentsInput`](crate::input::ListInstalledComponentsInput)
    pub fn builder() -> crate::input::list_installed_components_input::Builder {
        crate::input::list_installed_components_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListInstalledComponents {
    type Output = std::result::Result<
        crate::output::ListInstalledComponentsOutput,
        crate::error::ListInstalledComponentsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_installed_components_error(response)
        } else {
            crate::operation_deser::parse_list_installed_components_response(response)
        }
    }
}

/// <p>Retrieves the list of tags for an IoT Greengrass resource.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListTagsForResource {
    _private: (),
}
impl ListTagsForResource {
    /// Creates a new builder-style object to manufacture [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput)
    pub fn builder() -> crate::input::list_tags_for_resource_input::Builder {
        crate::input::list_tags_for_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListTagsForResource {
    type Output = std::result::Result<
        crate::output::ListTagsForResourceOutput,
        crate::error::ListTagsForResourceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_tags_for_resource_error(response)
        } else {
            crate::operation_deser::parse_list_tags_for_resource_response(response)
        }
    }
}

/// <p>Retrieves a list of components that meet the component, version, and platform requirements
/// of a deployment. Greengrass core devices call this operation when they receive a deployment to
/// identify the components to install.</p>
/// <p>This operation identifies components that meet all dependency requirements for a
/// deployment. If the requirements conflict, then this operation returns an error and the
/// deployment fails. For example, this occurs if component <code>A</code> requires version
/// <code>>2.0.0</code> and component <code>B</code> requires version <code><2.0.0</code>
/// of a component dependency.</p>
/// <p>When you specify the component candidates to resolve, IoT Greengrass compares each component's
/// digest from the core device with the component's digest in the Amazon Web Services Cloud. If the digests don't
/// match, then IoT Greengrass specifies to use the version from the Amazon Web Services Cloud.</p>
/// <important>
/// <p>To use this operation, you must use the data plane API endpoint and authenticate with an
/// IoT device certificate. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/greengrass.html">IoT Greengrass endpoints and quotas</a>.</p>
/// </important>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ResolveComponentCandidates {
    _private: (),
}
impl ResolveComponentCandidates {
    /// Creates a new builder-style object to manufacture [`ResolveComponentCandidatesInput`](crate::input::ResolveComponentCandidatesInput)
    pub fn builder() -> crate::input::resolve_component_candidates_input::Builder {
        crate::input::resolve_component_candidates_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ResolveComponentCandidates {
    type Output = std::result::Result<
        crate::output::ResolveComponentCandidatesOutput,
        crate::error::ResolveComponentCandidatesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_resolve_component_candidates_error(response)
        } else {
            crate::operation_deser::parse_resolve_component_candidates_response(response)
        }
    }
}

/// <p>Adds tags to an IoT Greengrass resource. If a tag already exists for the resource, this operation
/// updates the tag's value.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct TagResource {
    _private: (),
}
impl TagResource {
    /// Creates a new builder-style object to manufacture [`TagResourceInput`](crate::input::TagResourceInput)
    pub fn builder() -> crate::input::tag_resource_input::Builder {
        crate::input::tag_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for TagResource {
    type Output =
        std::result::Result<crate::output::TagResourceOutput, crate::error::TagResourceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_tag_resource_error(response)
        } else {
            crate::operation_deser::parse_tag_resource_response(response)
        }
    }
}

/// <p>Removes a tag from an IoT Greengrass resource.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UntagResource {
    _private: (),
}
impl UntagResource {
    /// Creates a new builder-style object to manufacture [`UntagResourceInput`](crate::input::UntagResourceInput)
    pub fn builder() -> crate::input::untag_resource_input::Builder {
        crate::input::untag_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UntagResource {
    type Output =
        std::result::Result<crate::output::UntagResourceOutput, crate::error::UntagResourceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_untag_resource_error(response)
        } else {
            crate::operation_deser::parse_untag_resource_response(response)
        }
    }
}
