// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// When writing a match expression against `ResourceType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let resourcetype = unimplemented!();
/// match resourcetype {
///     ResourceType::Order => { /* ... */ },
///     ResourceType::Outpost => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `resourcetype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ResourceType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ResourceType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ResourceType::NewFeature` is defined.
/// Specifically, when `resourcetype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ResourceType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ResourceType {
    #[allow(missing_docs)] // documentation missing in model
    Order,
    #[allow(missing_docs)] // documentation missing in model
    Outpost,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ResourceType {
    fn from(s: &str) -> Self {
        match s {
            "ORDER" => ResourceType::Order,
            "OUTPOST" => ResourceType::Outpost,
            other => ResourceType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ResourceType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ResourceType::from(s))
    }
}
impl ResourceType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ResourceType::Order => "ORDER",
            ResourceType::Outpost => "OUTPOST",
            ResourceType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ORDER", "OUTPOST"]
    }
}
impl AsRef<str> for ResourceType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information about a site.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Site {
    /// <p>The ID of the site.</p>
    #[doc(hidden)]
    pub site_id: std::option::Option<std::string::String>,
    /// <p>The ID of the Amazon Web Services account.</p>
    #[doc(hidden)]
    pub account_id: std::option::Option<std::string::String>,
    /// <p>The name of the site.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The description of the site.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The site tags.</p>
    #[doc(hidden)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The Amazon Resource Name (ARN) of the site.</p>
    #[doc(hidden)]
    pub site_arn: std::option::Option<std::string::String>,
    /// <p> Notes about a site. </p>
    #[doc(hidden)]
    pub notes: std::option::Option<std::string::String>,
    /// <p> The ISO-3166 two-letter country code where the hardware is installed and powered on. </p>
    #[doc(hidden)]
    pub operating_address_country_code: std::option::Option<std::string::String>,
    /// <p> State or region where the hardware is installed and powered on. </p>
    #[doc(hidden)]
    pub operating_address_state_or_region: std::option::Option<std::string::String>,
    /// <p> City where the hardware is installed and powered on. </p>
    #[doc(hidden)]
    pub operating_address_city: std::option::Option<std::string::String>,
    /// <p> Information about the physical and logistical details for a rack at the site. </p>
    #[doc(hidden)]
    pub rack_physical_properties: std::option::Option<crate::model::RackPhysicalProperties>,
}
impl Site {
    /// <p>The ID of the site.</p>
    pub fn site_id(&self) -> std::option::Option<&str> {
        self.site_id.as_deref()
    }
    /// <p>The ID of the Amazon Web Services account.</p>
    pub fn account_id(&self) -> std::option::Option<&str> {
        self.account_id.as_deref()
    }
    /// <p>The name of the site.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The description of the site.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The site tags.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
    /// <p>The Amazon Resource Name (ARN) of the site.</p>
    pub fn site_arn(&self) -> std::option::Option<&str> {
        self.site_arn.as_deref()
    }
    /// <p> Notes about a site. </p>
    pub fn notes(&self) -> std::option::Option<&str> {
        self.notes.as_deref()
    }
    /// <p> The ISO-3166 two-letter country code where the hardware is installed and powered on. </p>
    pub fn operating_address_country_code(&self) -> std::option::Option<&str> {
        self.operating_address_country_code.as_deref()
    }
    /// <p> State or region where the hardware is installed and powered on. </p>
    pub fn operating_address_state_or_region(&self) -> std::option::Option<&str> {
        self.operating_address_state_or_region.as_deref()
    }
    /// <p> City where the hardware is installed and powered on. </p>
    pub fn operating_address_city(&self) -> std::option::Option<&str> {
        self.operating_address_city.as_deref()
    }
    /// <p> Information about the physical and logistical details for a rack at the site. </p>
    pub fn rack_physical_properties(
        &self,
    ) -> std::option::Option<&crate::model::RackPhysicalProperties> {
        self.rack_physical_properties.as_ref()
    }
}
impl Site {
    /// Creates a new builder-style object to manufacture [`Site`](crate::model::Site).
    pub fn builder() -> crate::model::site::Builder {
        crate::model::site::Builder::default()
    }
}

/// See [`Site`](crate::model::Site).
pub mod site {

    /// A builder for [`Site`](crate::model::Site).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) site_id: std::option::Option<std::string::String>,
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) site_arn: std::option::Option<std::string::String>,
        pub(crate) notes: std::option::Option<std::string::String>,
        pub(crate) operating_address_country_code: std::option::Option<std::string::String>,
        pub(crate) operating_address_state_or_region: std::option::Option<std::string::String>,
        pub(crate) operating_address_city: std::option::Option<std::string::String>,
        pub(crate) rack_physical_properties:
            std::option::Option<crate::model::RackPhysicalProperties>,
    }
    impl Builder {
        /// <p>The ID of the site.</p>
        pub fn site_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.site_id = Some(input.into());
            self
        }
        /// <p>The ID of the site.</p>
        pub fn set_site_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.site_id = input;
            self
        }
        /// <p>The ID of the Amazon Web Services account.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The ID of the Amazon Web Services account.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input;
            self
        }
        /// <p>The name of the site.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the site.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The description of the site.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the site.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The site tags.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>The site tags.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the site.</p>
        pub fn site_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.site_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the site.</p>
        pub fn set_site_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.site_arn = input;
            self
        }
        /// <p> Notes about a site. </p>
        pub fn notes(mut self, input: impl Into<std::string::String>) -> Self {
            self.notes = Some(input.into());
            self
        }
        /// <p> Notes about a site. </p>
        pub fn set_notes(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.notes = input;
            self
        }
        /// <p> The ISO-3166 two-letter country code where the hardware is installed and powered on. </p>
        pub fn operating_address_country_code(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.operating_address_country_code = Some(input.into());
            self
        }
        /// <p> The ISO-3166 two-letter country code where the hardware is installed and powered on. </p>
        pub fn set_operating_address_country_code(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.operating_address_country_code = input;
            self
        }
        /// <p> State or region where the hardware is installed and powered on. </p>
        pub fn operating_address_state_or_region(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.operating_address_state_or_region = Some(input.into());
            self
        }
        /// <p> State or region where the hardware is installed and powered on. </p>
        pub fn set_operating_address_state_or_region(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.operating_address_state_or_region = input;
            self
        }
        /// <p> City where the hardware is installed and powered on. </p>
        pub fn operating_address_city(mut self, input: impl Into<std::string::String>) -> Self {
            self.operating_address_city = Some(input.into());
            self
        }
        /// <p> City where the hardware is installed and powered on. </p>
        pub fn set_operating_address_city(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.operating_address_city = input;
            self
        }
        /// <p> Information about the physical and logistical details for a rack at the site. </p>
        pub fn rack_physical_properties(
            mut self,
            input: crate::model::RackPhysicalProperties,
        ) -> Self {
            self.rack_physical_properties = Some(input);
            self
        }
        /// <p> Information about the physical and logistical details for a rack at the site. </p>
        pub fn set_rack_physical_properties(
            mut self,
            input: std::option::Option<crate::model::RackPhysicalProperties>,
        ) -> Self {
            self.rack_physical_properties = input;
            self
        }
        /// Consumes the builder and constructs a [`Site`](crate::model::Site).
        pub fn build(self) -> crate::model::Site {
            crate::model::Site {
                site_id: self.site_id,
                account_id: self.account_id,
                name: self.name,
                description: self.description,
                tags: self.tags,
                site_arn: self.site_arn,
                notes: self.notes,
                operating_address_country_code: self.operating_address_country_code,
                operating_address_state_or_region: self.operating_address_state_or_region,
                operating_address_city: self.operating_address_city,
                rack_physical_properties: self.rack_physical_properties,
            }
        }
    }
}

/// <p> Information about the physical and logistical details for racks at sites. For more information about hardware requirements for racks, see <a href="https://docs.aws.amazon.com/outposts/latest/userguide/outposts-requirements.html#checklist">Network readiness checklist</a> in the Amazon Web Services Outposts User Guide. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RackPhysicalProperties {
    /// <p>The power draw available at the hardware placement position for the rack. </p>
    #[doc(hidden)]
    pub power_draw_kva: std::option::Option<crate::model::PowerDrawKva>,
    /// <p>The power option that you can provide for hardware.</p>
    #[doc(hidden)]
    pub power_phase: std::option::Option<crate::model::PowerPhase>,
    /// <p>The power connector for the hardware. </p>
    #[doc(hidden)]
    pub power_connector: std::option::Option<crate::model::PowerConnector>,
    /// <p>The position of the power feed.</p>
    #[doc(hidden)]
    pub power_feed_drop: std::option::Option<crate::model::PowerFeedDrop>,
    /// <p>The uplink speed the rack supports for the connection to the Region. </p>
    #[doc(hidden)]
    pub uplink_gbps: std::option::Option<crate::model::UplinkGbps>,
    /// <p>The number of uplinks each Outpost network device.</p>
    #[doc(hidden)]
    pub uplink_count: std::option::Option<crate::model::UplinkCount>,
    /// <p>The type of fiber used to attach the Outpost to the network. </p>
    #[doc(hidden)]
    pub fiber_optic_cable_type: std::option::Option<crate::model::FiberOpticCableType>,
    /// <p>The type of optical standard used to attach the Outpost to the network. This field is dependent on uplink speed, fiber type, and distance to the upstream device. For more information about networking requirements for racks, see <a href="https://docs.aws.amazon.com/outposts/latest/userguide/outposts-requirements.html#facility-networking">Network</a> in the Amazon Web Services Outposts User Guide. </p>
    #[doc(hidden)]
    pub optical_standard: std::option::Option<crate::model::OpticalStandard>,
    /// <p>The maximum rack weight that this site can support. <code>NO_LIMIT</code> is over 2000 lbs (907 kg). </p>
    #[doc(hidden)]
    pub maximum_supported_weight_lbs: std::option::Option<crate::model::MaximumSupportedWeightLbs>,
}
impl RackPhysicalProperties {
    /// <p>The power draw available at the hardware placement position for the rack. </p>
    pub fn power_draw_kva(&self) -> std::option::Option<&crate::model::PowerDrawKva> {
        self.power_draw_kva.as_ref()
    }
    /// <p>The power option that you can provide for hardware.</p>
    pub fn power_phase(&self) -> std::option::Option<&crate::model::PowerPhase> {
        self.power_phase.as_ref()
    }
    /// <p>The power connector for the hardware. </p>
    pub fn power_connector(&self) -> std::option::Option<&crate::model::PowerConnector> {
        self.power_connector.as_ref()
    }
    /// <p>The position of the power feed.</p>
    pub fn power_feed_drop(&self) -> std::option::Option<&crate::model::PowerFeedDrop> {
        self.power_feed_drop.as_ref()
    }
    /// <p>The uplink speed the rack supports for the connection to the Region. </p>
    pub fn uplink_gbps(&self) -> std::option::Option<&crate::model::UplinkGbps> {
        self.uplink_gbps.as_ref()
    }
    /// <p>The number of uplinks each Outpost network device.</p>
    pub fn uplink_count(&self) -> std::option::Option<&crate::model::UplinkCount> {
        self.uplink_count.as_ref()
    }
    /// <p>The type of fiber used to attach the Outpost to the network. </p>
    pub fn fiber_optic_cable_type(
        &self,
    ) -> std::option::Option<&crate::model::FiberOpticCableType> {
        self.fiber_optic_cable_type.as_ref()
    }
    /// <p>The type of optical standard used to attach the Outpost to the network. This field is dependent on uplink speed, fiber type, and distance to the upstream device. For more information about networking requirements for racks, see <a href="https://docs.aws.amazon.com/outposts/latest/userguide/outposts-requirements.html#facility-networking">Network</a> in the Amazon Web Services Outposts User Guide. </p>
    pub fn optical_standard(&self) -> std::option::Option<&crate::model::OpticalStandard> {
        self.optical_standard.as_ref()
    }
    /// <p>The maximum rack weight that this site can support. <code>NO_LIMIT</code> is over 2000 lbs (907 kg). </p>
    pub fn maximum_supported_weight_lbs(
        &self,
    ) -> std::option::Option<&crate::model::MaximumSupportedWeightLbs> {
        self.maximum_supported_weight_lbs.as_ref()
    }
}
impl RackPhysicalProperties {
    /// Creates a new builder-style object to manufacture [`RackPhysicalProperties`](crate::model::RackPhysicalProperties).
    pub fn builder() -> crate::model::rack_physical_properties::Builder {
        crate::model::rack_physical_properties::Builder::default()
    }
}

/// See [`RackPhysicalProperties`](crate::model::RackPhysicalProperties).
pub mod rack_physical_properties {

    /// A builder for [`RackPhysicalProperties`](crate::model::RackPhysicalProperties).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) power_draw_kva: std::option::Option<crate::model::PowerDrawKva>,
        pub(crate) power_phase: std::option::Option<crate::model::PowerPhase>,
        pub(crate) power_connector: std::option::Option<crate::model::PowerConnector>,
        pub(crate) power_feed_drop: std::option::Option<crate::model::PowerFeedDrop>,
        pub(crate) uplink_gbps: std::option::Option<crate::model::UplinkGbps>,
        pub(crate) uplink_count: std::option::Option<crate::model::UplinkCount>,
        pub(crate) fiber_optic_cable_type: std::option::Option<crate::model::FiberOpticCableType>,
        pub(crate) optical_standard: std::option::Option<crate::model::OpticalStandard>,
        pub(crate) maximum_supported_weight_lbs:
            std::option::Option<crate::model::MaximumSupportedWeightLbs>,
    }
    impl Builder {
        /// <p>The power draw available at the hardware placement position for the rack. </p>
        pub fn power_draw_kva(mut self, input: crate::model::PowerDrawKva) -> Self {
            self.power_draw_kva = Some(input);
            self
        }
        /// <p>The power draw available at the hardware placement position for the rack. </p>
        pub fn set_power_draw_kva(
            mut self,
            input: std::option::Option<crate::model::PowerDrawKva>,
        ) -> Self {
            self.power_draw_kva = input;
            self
        }
        /// <p>The power option that you can provide for hardware.</p>
        pub fn power_phase(mut self, input: crate::model::PowerPhase) -> Self {
            self.power_phase = Some(input);
            self
        }
        /// <p>The power option that you can provide for hardware.</p>
        pub fn set_power_phase(
            mut self,
            input: std::option::Option<crate::model::PowerPhase>,
        ) -> Self {
            self.power_phase = input;
            self
        }
        /// <p>The power connector for the hardware. </p>
        pub fn power_connector(mut self, input: crate::model::PowerConnector) -> Self {
            self.power_connector = Some(input);
            self
        }
        /// <p>The power connector for the hardware. </p>
        pub fn set_power_connector(
            mut self,
            input: std::option::Option<crate::model::PowerConnector>,
        ) -> Self {
            self.power_connector = input;
            self
        }
        /// <p>The position of the power feed.</p>
        pub fn power_feed_drop(mut self, input: crate::model::PowerFeedDrop) -> Self {
            self.power_feed_drop = Some(input);
            self
        }
        /// <p>The position of the power feed.</p>
        pub fn set_power_feed_drop(
            mut self,
            input: std::option::Option<crate::model::PowerFeedDrop>,
        ) -> Self {
            self.power_feed_drop = input;
            self
        }
        /// <p>The uplink speed the rack supports for the connection to the Region. </p>
        pub fn uplink_gbps(mut self, input: crate::model::UplinkGbps) -> Self {
            self.uplink_gbps = Some(input);
            self
        }
        /// <p>The uplink speed the rack supports for the connection to the Region. </p>
        pub fn set_uplink_gbps(
            mut self,
            input: std::option::Option<crate::model::UplinkGbps>,
        ) -> Self {
            self.uplink_gbps = input;
            self
        }
        /// <p>The number of uplinks each Outpost network device.</p>
        pub fn uplink_count(mut self, input: crate::model::UplinkCount) -> Self {
            self.uplink_count = Some(input);
            self
        }
        /// <p>The number of uplinks each Outpost network device.</p>
        pub fn set_uplink_count(
            mut self,
            input: std::option::Option<crate::model::UplinkCount>,
        ) -> Self {
            self.uplink_count = input;
            self
        }
        /// <p>The type of fiber used to attach the Outpost to the network. </p>
        pub fn fiber_optic_cable_type(mut self, input: crate::model::FiberOpticCableType) -> Self {
            self.fiber_optic_cable_type = Some(input);
            self
        }
        /// <p>The type of fiber used to attach the Outpost to the network. </p>
        pub fn set_fiber_optic_cable_type(
            mut self,
            input: std::option::Option<crate::model::FiberOpticCableType>,
        ) -> Self {
            self.fiber_optic_cable_type = input;
            self
        }
        /// <p>The type of optical standard used to attach the Outpost to the network. This field is dependent on uplink speed, fiber type, and distance to the upstream device. For more information about networking requirements for racks, see <a href="https://docs.aws.amazon.com/outposts/latest/userguide/outposts-requirements.html#facility-networking">Network</a> in the Amazon Web Services Outposts User Guide. </p>
        pub fn optical_standard(mut self, input: crate::model::OpticalStandard) -> Self {
            self.optical_standard = Some(input);
            self
        }
        /// <p>The type of optical standard used to attach the Outpost to the network. This field is dependent on uplink speed, fiber type, and distance to the upstream device. For more information about networking requirements for racks, see <a href="https://docs.aws.amazon.com/outposts/latest/userguide/outposts-requirements.html#facility-networking">Network</a> in the Amazon Web Services Outposts User Guide. </p>
        pub fn set_optical_standard(
            mut self,
            input: std::option::Option<crate::model::OpticalStandard>,
        ) -> Self {
            self.optical_standard = input;
            self
        }
        /// <p>The maximum rack weight that this site can support. <code>NO_LIMIT</code> is over 2000 lbs (907 kg). </p>
        pub fn maximum_supported_weight_lbs(
            mut self,
            input: crate::model::MaximumSupportedWeightLbs,
        ) -> Self {
            self.maximum_supported_weight_lbs = Some(input);
            self
        }
        /// <p>The maximum rack weight that this site can support. <code>NO_LIMIT</code> is over 2000 lbs (907 kg). </p>
        pub fn set_maximum_supported_weight_lbs(
            mut self,
            input: std::option::Option<crate::model::MaximumSupportedWeightLbs>,
        ) -> Self {
            self.maximum_supported_weight_lbs = input;
            self
        }
        /// Consumes the builder and constructs a [`RackPhysicalProperties`](crate::model::RackPhysicalProperties).
        pub fn build(self) -> crate::model::RackPhysicalProperties {
            crate::model::RackPhysicalProperties {
                power_draw_kva: self.power_draw_kva,
                power_phase: self.power_phase,
                power_connector: self.power_connector,
                power_feed_drop: self.power_feed_drop,
                uplink_gbps: self.uplink_gbps,
                uplink_count: self.uplink_count,
                fiber_optic_cable_type: self.fiber_optic_cable_type,
                optical_standard: self.optical_standard,
                maximum_supported_weight_lbs: self.maximum_supported_weight_lbs,
            }
        }
    }
}

/// When writing a match expression against `MaximumSupportedWeightLbs`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let maximumsupportedweightlbs = unimplemented!();
/// match maximumsupportedweightlbs {
///     MaximumSupportedWeightLbs::Max1400Lbs => { /* ... */ },
///     MaximumSupportedWeightLbs::Max1600Lbs => { /* ... */ },
///     MaximumSupportedWeightLbs::Max1800Lbs => { /* ... */ },
///     MaximumSupportedWeightLbs::Max2000Lbs => { /* ... */ },
///     MaximumSupportedWeightLbs::NoLimit => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `maximumsupportedweightlbs` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `MaximumSupportedWeightLbs::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `MaximumSupportedWeightLbs::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `MaximumSupportedWeightLbs::NewFeature` is defined.
/// Specifically, when `maximumsupportedweightlbs` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `MaximumSupportedWeightLbs::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum MaximumSupportedWeightLbs {
    #[allow(missing_docs)] // documentation missing in model
    Max1400Lbs,
    #[allow(missing_docs)] // documentation missing in model
    Max1600Lbs,
    #[allow(missing_docs)] // documentation missing in model
    Max1800Lbs,
    #[allow(missing_docs)] // documentation missing in model
    Max2000Lbs,
    #[allow(missing_docs)] // documentation missing in model
    NoLimit,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for MaximumSupportedWeightLbs {
    fn from(s: &str) -> Self {
        match s {
            "MAX_1400_LBS" => MaximumSupportedWeightLbs::Max1400Lbs,
            "MAX_1600_LBS" => MaximumSupportedWeightLbs::Max1600Lbs,
            "MAX_1800_LBS" => MaximumSupportedWeightLbs::Max1800Lbs,
            "MAX_2000_LBS" => MaximumSupportedWeightLbs::Max2000Lbs,
            "NO_LIMIT" => MaximumSupportedWeightLbs::NoLimit,
            other => MaximumSupportedWeightLbs::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for MaximumSupportedWeightLbs {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(MaximumSupportedWeightLbs::from(s))
    }
}
impl MaximumSupportedWeightLbs {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            MaximumSupportedWeightLbs::Max1400Lbs => "MAX_1400_LBS",
            MaximumSupportedWeightLbs::Max1600Lbs => "MAX_1600_LBS",
            MaximumSupportedWeightLbs::Max1800Lbs => "MAX_1800_LBS",
            MaximumSupportedWeightLbs::Max2000Lbs => "MAX_2000_LBS",
            MaximumSupportedWeightLbs::NoLimit => "NO_LIMIT",
            MaximumSupportedWeightLbs::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "MAX_1400_LBS",
            "MAX_1600_LBS",
            "MAX_1800_LBS",
            "MAX_2000_LBS",
            "NO_LIMIT",
        ]
    }
}
impl AsRef<str> for MaximumSupportedWeightLbs {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `OpticalStandard`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let opticalstandard = unimplemented!();
/// match opticalstandard {
///     OpticalStandard::Optic1000BaseLx => { /* ... */ },
///     OpticalStandard::Optic1000BaseSx => { /* ... */ },
///     OpticalStandard::Optic100GbaseCwdm4 => { /* ... */ },
///     OpticalStandard::Optic100GbaseLr4 => { /* ... */ },
///     OpticalStandard::Optic100GbaseSr4 => { /* ... */ },
///     OpticalStandard::Optic100GPsm4Msa => { /* ... */ },
///     OpticalStandard::Optic10GbaseIr => { /* ... */ },
///     OpticalStandard::Optic10GbaseLr => { /* ... */ },
///     OpticalStandard::Optic10GbaseSr => { /* ... */ },
///     OpticalStandard::Optic40GbaseEsr => { /* ... */ },
///     OpticalStandard::Optic40GbaseIr4Lr4L => { /* ... */ },
///     OpticalStandard::Optic40GbaseLr4 => { /* ... */ },
///     OpticalStandard::Optic40GbaseSr => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `opticalstandard` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `OpticalStandard::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `OpticalStandard::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `OpticalStandard::NewFeature` is defined.
/// Specifically, when `opticalstandard` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `OpticalStandard::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum OpticalStandard {
    #[allow(missing_docs)] // documentation missing in model
    Optic1000BaseLx,
    #[allow(missing_docs)] // documentation missing in model
    Optic1000BaseSx,
    #[allow(missing_docs)] // documentation missing in model
    Optic100GbaseCwdm4,
    #[allow(missing_docs)] // documentation missing in model
    Optic100GbaseLr4,
    #[allow(missing_docs)] // documentation missing in model
    Optic100GbaseSr4,
    #[allow(missing_docs)] // documentation missing in model
    Optic100GPsm4Msa,
    #[allow(missing_docs)] // documentation missing in model
    Optic10GbaseIr,
    #[allow(missing_docs)] // documentation missing in model
    Optic10GbaseLr,
    #[allow(missing_docs)] // documentation missing in model
    Optic10GbaseSr,
    #[allow(missing_docs)] // documentation missing in model
    Optic40GbaseEsr,
    #[allow(missing_docs)] // documentation missing in model
    Optic40GbaseIr4Lr4L,
    #[allow(missing_docs)] // documentation missing in model
    Optic40GbaseLr4,
    #[allow(missing_docs)] // documentation missing in model
    Optic40GbaseSr,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for OpticalStandard {
    fn from(s: &str) -> Self {
        match s {
            "OPTIC_1000BASE_LX" => OpticalStandard::Optic1000BaseLx,
            "OPTIC_1000BASE_SX" => OpticalStandard::Optic1000BaseSx,
            "OPTIC_100GBASE_CWDM4" => OpticalStandard::Optic100GbaseCwdm4,
            "OPTIC_100GBASE_LR4" => OpticalStandard::Optic100GbaseLr4,
            "OPTIC_100GBASE_SR4" => OpticalStandard::Optic100GbaseSr4,
            "OPTIC_100G_PSM4_MSA" => OpticalStandard::Optic100GPsm4Msa,
            "OPTIC_10GBASE_IR" => OpticalStandard::Optic10GbaseIr,
            "OPTIC_10GBASE_LR" => OpticalStandard::Optic10GbaseLr,
            "OPTIC_10GBASE_SR" => OpticalStandard::Optic10GbaseSr,
            "OPTIC_40GBASE_ESR" => OpticalStandard::Optic40GbaseEsr,
            "OPTIC_40GBASE_IR4_LR4L" => OpticalStandard::Optic40GbaseIr4Lr4L,
            "OPTIC_40GBASE_LR4" => OpticalStandard::Optic40GbaseLr4,
            "OPTIC_40GBASE_SR" => OpticalStandard::Optic40GbaseSr,
            other => OpticalStandard::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for OpticalStandard {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(OpticalStandard::from(s))
    }
}
impl OpticalStandard {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            OpticalStandard::Optic1000BaseLx => "OPTIC_1000BASE_LX",
            OpticalStandard::Optic1000BaseSx => "OPTIC_1000BASE_SX",
            OpticalStandard::Optic100GbaseCwdm4 => "OPTIC_100GBASE_CWDM4",
            OpticalStandard::Optic100GbaseLr4 => "OPTIC_100GBASE_LR4",
            OpticalStandard::Optic100GbaseSr4 => "OPTIC_100GBASE_SR4",
            OpticalStandard::Optic100GPsm4Msa => "OPTIC_100G_PSM4_MSA",
            OpticalStandard::Optic10GbaseIr => "OPTIC_10GBASE_IR",
            OpticalStandard::Optic10GbaseLr => "OPTIC_10GBASE_LR",
            OpticalStandard::Optic10GbaseSr => "OPTIC_10GBASE_SR",
            OpticalStandard::Optic40GbaseEsr => "OPTIC_40GBASE_ESR",
            OpticalStandard::Optic40GbaseIr4Lr4L => "OPTIC_40GBASE_IR4_LR4L",
            OpticalStandard::Optic40GbaseLr4 => "OPTIC_40GBASE_LR4",
            OpticalStandard::Optic40GbaseSr => "OPTIC_40GBASE_SR",
            OpticalStandard::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "OPTIC_1000BASE_LX",
            "OPTIC_1000BASE_SX",
            "OPTIC_100GBASE_CWDM4",
            "OPTIC_100GBASE_LR4",
            "OPTIC_100GBASE_SR4",
            "OPTIC_100G_PSM4_MSA",
            "OPTIC_10GBASE_IR",
            "OPTIC_10GBASE_LR",
            "OPTIC_10GBASE_SR",
            "OPTIC_40GBASE_ESR",
            "OPTIC_40GBASE_IR4_LR4L",
            "OPTIC_40GBASE_LR4",
            "OPTIC_40GBASE_SR",
        ]
    }
}
impl AsRef<str> for OpticalStandard {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `FiberOpticCableType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let fiberopticcabletype = unimplemented!();
/// match fiberopticcabletype {
///     FiberOpticCableType::MultiMode => { /* ... */ },
///     FiberOpticCableType::SingleMode => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `fiberopticcabletype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `FiberOpticCableType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `FiberOpticCableType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `FiberOpticCableType::NewFeature` is defined.
/// Specifically, when `fiberopticcabletype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `FiberOpticCableType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum FiberOpticCableType {
    #[allow(missing_docs)] // documentation missing in model
    MultiMode,
    #[allow(missing_docs)] // documentation missing in model
    SingleMode,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for FiberOpticCableType {
    fn from(s: &str) -> Self {
        match s {
            "MULTI_MODE" => FiberOpticCableType::MultiMode,
            "SINGLE_MODE" => FiberOpticCableType::SingleMode,
            other => {
                FiberOpticCableType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for FiberOpticCableType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(FiberOpticCableType::from(s))
    }
}
impl FiberOpticCableType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            FiberOpticCableType::MultiMode => "MULTI_MODE",
            FiberOpticCableType::SingleMode => "SINGLE_MODE",
            FiberOpticCableType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["MULTI_MODE", "SINGLE_MODE"]
    }
}
impl AsRef<str> for FiberOpticCableType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `UplinkCount`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let uplinkcount = unimplemented!();
/// match uplinkcount {
///     UplinkCount::UplinkCount1 => { /* ... */ },
///     UplinkCount::UplinkCount12 => { /* ... */ },
///     UplinkCount::UplinkCount16 => { /* ... */ },
///     UplinkCount::UplinkCount2 => { /* ... */ },
///     UplinkCount::UplinkCount3 => { /* ... */ },
///     UplinkCount::UplinkCount4 => { /* ... */ },
///     UplinkCount::UplinkCount5 => { /* ... */ },
///     UplinkCount::UplinkCount6 => { /* ... */ },
///     UplinkCount::UplinkCount7 => { /* ... */ },
///     UplinkCount::UplinkCount8 => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `uplinkcount` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `UplinkCount::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `UplinkCount::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `UplinkCount::NewFeature` is defined.
/// Specifically, when `uplinkcount` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `UplinkCount::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum UplinkCount {
    #[allow(missing_docs)] // documentation missing in model
    UplinkCount1,
    #[allow(missing_docs)] // documentation missing in model
    UplinkCount12,
    #[allow(missing_docs)] // documentation missing in model
    UplinkCount16,
    #[allow(missing_docs)] // documentation missing in model
    UplinkCount2,
    #[allow(missing_docs)] // documentation missing in model
    UplinkCount3,
    #[allow(missing_docs)] // documentation missing in model
    UplinkCount4,
    #[allow(missing_docs)] // documentation missing in model
    UplinkCount5,
    #[allow(missing_docs)] // documentation missing in model
    UplinkCount6,
    #[allow(missing_docs)] // documentation missing in model
    UplinkCount7,
    #[allow(missing_docs)] // documentation missing in model
    UplinkCount8,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for UplinkCount {
    fn from(s: &str) -> Self {
        match s {
            "UPLINK_COUNT_1" => UplinkCount::UplinkCount1,
            "UPLINK_COUNT_12" => UplinkCount::UplinkCount12,
            "UPLINK_COUNT_16" => UplinkCount::UplinkCount16,
            "UPLINK_COUNT_2" => UplinkCount::UplinkCount2,
            "UPLINK_COUNT_3" => UplinkCount::UplinkCount3,
            "UPLINK_COUNT_4" => UplinkCount::UplinkCount4,
            "UPLINK_COUNT_5" => UplinkCount::UplinkCount5,
            "UPLINK_COUNT_6" => UplinkCount::UplinkCount6,
            "UPLINK_COUNT_7" => UplinkCount::UplinkCount7,
            "UPLINK_COUNT_8" => UplinkCount::UplinkCount8,
            other => UplinkCount::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for UplinkCount {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(UplinkCount::from(s))
    }
}
impl UplinkCount {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            UplinkCount::UplinkCount1 => "UPLINK_COUNT_1",
            UplinkCount::UplinkCount12 => "UPLINK_COUNT_12",
            UplinkCount::UplinkCount16 => "UPLINK_COUNT_16",
            UplinkCount::UplinkCount2 => "UPLINK_COUNT_2",
            UplinkCount::UplinkCount3 => "UPLINK_COUNT_3",
            UplinkCount::UplinkCount4 => "UPLINK_COUNT_4",
            UplinkCount::UplinkCount5 => "UPLINK_COUNT_5",
            UplinkCount::UplinkCount6 => "UPLINK_COUNT_6",
            UplinkCount::UplinkCount7 => "UPLINK_COUNT_7",
            UplinkCount::UplinkCount8 => "UPLINK_COUNT_8",
            UplinkCount::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "UPLINK_COUNT_1",
            "UPLINK_COUNT_12",
            "UPLINK_COUNT_16",
            "UPLINK_COUNT_2",
            "UPLINK_COUNT_3",
            "UPLINK_COUNT_4",
            "UPLINK_COUNT_5",
            "UPLINK_COUNT_6",
            "UPLINK_COUNT_7",
            "UPLINK_COUNT_8",
        ]
    }
}
impl AsRef<str> for UplinkCount {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `UplinkGbps`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let uplinkgbps = unimplemented!();
/// match uplinkgbps {
///     UplinkGbps::Uplink100G => { /* ... */ },
///     UplinkGbps::Uplink10G => { /* ... */ },
///     UplinkGbps::Uplink1G => { /* ... */ },
///     UplinkGbps::Uplink40G => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `uplinkgbps` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `UplinkGbps::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `UplinkGbps::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `UplinkGbps::NewFeature` is defined.
/// Specifically, when `uplinkgbps` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `UplinkGbps::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum UplinkGbps {
    #[allow(missing_docs)] // documentation missing in model
    Uplink100G,
    #[allow(missing_docs)] // documentation missing in model
    Uplink10G,
    #[allow(missing_docs)] // documentation missing in model
    Uplink1G,
    #[allow(missing_docs)] // documentation missing in model
    Uplink40G,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for UplinkGbps {
    fn from(s: &str) -> Self {
        match s {
            "UPLINK_100G" => UplinkGbps::Uplink100G,
            "UPLINK_10G" => UplinkGbps::Uplink10G,
            "UPLINK_1G" => UplinkGbps::Uplink1G,
            "UPLINK_40G" => UplinkGbps::Uplink40G,
            other => UplinkGbps::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for UplinkGbps {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(UplinkGbps::from(s))
    }
}
impl UplinkGbps {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            UplinkGbps::Uplink100G => "UPLINK_100G",
            UplinkGbps::Uplink10G => "UPLINK_10G",
            UplinkGbps::Uplink1G => "UPLINK_1G",
            UplinkGbps::Uplink40G => "UPLINK_40G",
            UplinkGbps::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["UPLINK_100G", "UPLINK_10G", "UPLINK_1G", "UPLINK_40G"]
    }
}
impl AsRef<str> for UplinkGbps {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `PowerFeedDrop`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let powerfeeddrop = unimplemented!();
/// match powerfeeddrop {
///     PowerFeedDrop::AboveRack => { /* ... */ },
///     PowerFeedDrop::BelowRack => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `powerfeeddrop` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `PowerFeedDrop::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `PowerFeedDrop::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `PowerFeedDrop::NewFeature` is defined.
/// Specifically, when `powerfeeddrop` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `PowerFeedDrop::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PowerFeedDrop {
    #[allow(missing_docs)] // documentation missing in model
    AboveRack,
    #[allow(missing_docs)] // documentation missing in model
    BelowRack,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for PowerFeedDrop {
    fn from(s: &str) -> Self {
        match s {
            "ABOVE_RACK" => PowerFeedDrop::AboveRack,
            "BELOW_RACK" => PowerFeedDrop::BelowRack,
            other => PowerFeedDrop::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for PowerFeedDrop {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PowerFeedDrop::from(s))
    }
}
impl PowerFeedDrop {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            PowerFeedDrop::AboveRack => "ABOVE_RACK",
            PowerFeedDrop::BelowRack => "BELOW_RACK",
            PowerFeedDrop::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ABOVE_RACK", "BELOW_RACK"]
    }
}
impl AsRef<str> for PowerFeedDrop {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `PowerConnector`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let powerconnector = unimplemented!();
/// match powerconnector {
///     PowerConnector::Ah530P7W => { /* ... */ },
///     PowerConnector::Ah532P6W => { /* ... */ },
///     PowerConnector::Iec309 => { /* ... */ },
///     PowerConnector::L630P => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `powerconnector` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `PowerConnector::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `PowerConnector::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `PowerConnector::NewFeature` is defined.
/// Specifically, when `powerconnector` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `PowerConnector::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PowerConnector {
    #[allow(missing_docs)] // documentation missing in model
    Ah530P7W,
    #[allow(missing_docs)] // documentation missing in model
    Ah532P6W,
    #[allow(missing_docs)] // documentation missing in model
    Iec309,
    #[allow(missing_docs)] // documentation missing in model
    L630P,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for PowerConnector {
    fn from(s: &str) -> Self {
        match s {
            "AH530P7W" => PowerConnector::Ah530P7W,
            "AH532P6W" => PowerConnector::Ah532P6W,
            "IEC309" => PowerConnector::Iec309,
            "L6_30P" => PowerConnector::L630P,
            other => PowerConnector::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for PowerConnector {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PowerConnector::from(s))
    }
}
impl PowerConnector {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            PowerConnector::Ah530P7W => "AH530P7W",
            PowerConnector::Ah532P6W => "AH532P6W",
            PowerConnector::Iec309 => "IEC309",
            PowerConnector::L630P => "L6_30P",
            PowerConnector::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["AH530P7W", "AH532P6W", "IEC309", "L6_30P"]
    }
}
impl AsRef<str> for PowerConnector {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `PowerPhase`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let powerphase = unimplemented!();
/// match powerphase {
///     PowerPhase::SinglePhase => { /* ... */ },
///     PowerPhase::ThreePhase => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `powerphase` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `PowerPhase::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `PowerPhase::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `PowerPhase::NewFeature` is defined.
/// Specifically, when `powerphase` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `PowerPhase::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PowerPhase {
    #[allow(missing_docs)] // documentation missing in model
    SinglePhase,
    #[allow(missing_docs)] // documentation missing in model
    ThreePhase,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for PowerPhase {
    fn from(s: &str) -> Self {
        match s {
            "SINGLE_PHASE" => PowerPhase::SinglePhase,
            "THREE_PHASE" => PowerPhase::ThreePhase,
            other => PowerPhase::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for PowerPhase {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PowerPhase::from(s))
    }
}
impl PowerPhase {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            PowerPhase::SinglePhase => "SINGLE_PHASE",
            PowerPhase::ThreePhase => "THREE_PHASE",
            PowerPhase::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["SINGLE_PHASE", "THREE_PHASE"]
    }
}
impl AsRef<str> for PowerPhase {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `PowerDrawKva`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let powerdrawkva = unimplemented!();
/// match powerdrawkva {
///     PowerDrawKva::Power10Kva => { /* ... */ },
///     PowerDrawKva::Power15Kva => { /* ... */ },
///     PowerDrawKva::Power30Kva => { /* ... */ },
///     PowerDrawKva::Power5Kva => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `powerdrawkva` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `PowerDrawKva::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `PowerDrawKva::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `PowerDrawKva::NewFeature` is defined.
/// Specifically, when `powerdrawkva` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `PowerDrawKva::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PowerDrawKva {
    #[allow(missing_docs)] // documentation missing in model
    Power10Kva,
    #[allow(missing_docs)] // documentation missing in model
    Power15Kva,
    #[allow(missing_docs)] // documentation missing in model
    Power30Kva,
    #[allow(missing_docs)] // documentation missing in model
    Power5Kva,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for PowerDrawKva {
    fn from(s: &str) -> Self {
        match s {
            "POWER_10_KVA" => PowerDrawKva::Power10Kva,
            "POWER_15_KVA" => PowerDrawKva::Power15Kva,
            "POWER_30_KVA" => PowerDrawKva::Power30Kva,
            "POWER_5_KVA" => PowerDrawKva::Power5Kva,
            other => PowerDrawKva::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for PowerDrawKva {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PowerDrawKva::from(s))
    }
}
impl PowerDrawKva {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            PowerDrawKva::Power10Kva => "POWER_10_KVA",
            PowerDrawKva::Power15Kva => "POWER_15_KVA",
            PowerDrawKva::Power30Kva => "POWER_30_KVA",
            PowerDrawKva::Power5Kva => "POWER_5_KVA",
            PowerDrawKva::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "POWER_10_KVA",
            "POWER_15_KVA",
            "POWER_30_KVA",
            "POWER_5_KVA",
        ]
    }
}
impl AsRef<str> for PowerDrawKva {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p> Information about an address. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Address {
    /// <p>The name of the contact.</p>
    #[doc(hidden)]
    pub contact_name: std::option::Option<std::string::String>,
    /// <p>The phone number of the contact.</p>
    #[doc(hidden)]
    pub contact_phone_number: std::option::Option<std::string::String>,
    /// <p>The first line of the address.</p>
    #[doc(hidden)]
    pub address_line1: std::option::Option<std::string::String>,
    /// <p>The second line of the address.</p>
    #[doc(hidden)]
    pub address_line2: std::option::Option<std::string::String>,
    /// <p>The third line of the address.</p>
    #[doc(hidden)]
    pub address_line3: std::option::Option<std::string::String>,
    /// <p>The city for the address.</p>
    #[doc(hidden)]
    pub city: std::option::Option<std::string::String>,
    /// <p>The state for the address.</p>
    #[doc(hidden)]
    pub state_or_region: std::option::Option<std::string::String>,
    /// <p>The district or county for the address.</p>
    #[doc(hidden)]
    pub district_or_county: std::option::Option<std::string::String>,
    /// <p>The postal code for the address.</p>
    #[doc(hidden)]
    pub postal_code: std::option::Option<std::string::String>,
    /// <p>The ISO-3166 two-letter country code for the address.</p>
    #[doc(hidden)]
    pub country_code: std::option::Option<std::string::String>,
    /// <p>The municipality for the address.</p>
    #[doc(hidden)]
    pub municipality: std::option::Option<std::string::String>,
}
impl Address {
    /// <p>The name of the contact.</p>
    pub fn contact_name(&self) -> std::option::Option<&str> {
        self.contact_name.as_deref()
    }
    /// <p>The phone number of the contact.</p>
    pub fn contact_phone_number(&self) -> std::option::Option<&str> {
        self.contact_phone_number.as_deref()
    }
    /// <p>The first line of the address.</p>
    pub fn address_line1(&self) -> std::option::Option<&str> {
        self.address_line1.as_deref()
    }
    /// <p>The second line of the address.</p>
    pub fn address_line2(&self) -> std::option::Option<&str> {
        self.address_line2.as_deref()
    }
    /// <p>The third line of the address.</p>
    pub fn address_line3(&self) -> std::option::Option<&str> {
        self.address_line3.as_deref()
    }
    /// <p>The city for the address.</p>
    pub fn city(&self) -> std::option::Option<&str> {
        self.city.as_deref()
    }
    /// <p>The state for the address.</p>
    pub fn state_or_region(&self) -> std::option::Option<&str> {
        self.state_or_region.as_deref()
    }
    /// <p>The district or county for the address.</p>
    pub fn district_or_county(&self) -> std::option::Option<&str> {
        self.district_or_county.as_deref()
    }
    /// <p>The postal code for the address.</p>
    pub fn postal_code(&self) -> std::option::Option<&str> {
        self.postal_code.as_deref()
    }
    /// <p>The ISO-3166 two-letter country code for the address.</p>
    pub fn country_code(&self) -> std::option::Option<&str> {
        self.country_code.as_deref()
    }
    /// <p>The municipality for the address.</p>
    pub fn municipality(&self) -> std::option::Option<&str> {
        self.municipality.as_deref()
    }
}
impl Address {
    /// Creates a new builder-style object to manufacture [`Address`](crate::model::Address).
    pub fn builder() -> crate::model::address::Builder {
        crate::model::address::Builder::default()
    }
}

/// See [`Address`](crate::model::Address).
pub mod address {

    /// A builder for [`Address`](crate::model::Address).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) contact_name: std::option::Option<std::string::String>,
        pub(crate) contact_phone_number: std::option::Option<std::string::String>,
        pub(crate) address_line1: std::option::Option<std::string::String>,
        pub(crate) address_line2: std::option::Option<std::string::String>,
        pub(crate) address_line3: std::option::Option<std::string::String>,
        pub(crate) city: std::option::Option<std::string::String>,
        pub(crate) state_or_region: std::option::Option<std::string::String>,
        pub(crate) district_or_county: std::option::Option<std::string::String>,
        pub(crate) postal_code: std::option::Option<std::string::String>,
        pub(crate) country_code: std::option::Option<std::string::String>,
        pub(crate) municipality: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the contact.</p>
        pub fn contact_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.contact_name = Some(input.into());
            self
        }
        /// <p>The name of the contact.</p>
        pub fn set_contact_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.contact_name = input;
            self
        }
        /// <p>The phone number of the contact.</p>
        pub fn contact_phone_number(mut self, input: impl Into<std::string::String>) -> Self {
            self.contact_phone_number = Some(input.into());
            self
        }
        /// <p>The phone number of the contact.</p>
        pub fn set_contact_phone_number(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.contact_phone_number = input;
            self
        }
        /// <p>The first line of the address.</p>
        pub fn address_line1(mut self, input: impl Into<std::string::String>) -> Self {
            self.address_line1 = Some(input.into());
            self
        }
        /// <p>The first line of the address.</p>
        pub fn set_address_line1(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.address_line1 = input;
            self
        }
        /// <p>The second line of the address.</p>
        pub fn address_line2(mut self, input: impl Into<std::string::String>) -> Self {
            self.address_line2 = Some(input.into());
            self
        }
        /// <p>The second line of the address.</p>
        pub fn set_address_line2(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.address_line2 = input;
            self
        }
        /// <p>The third line of the address.</p>
        pub fn address_line3(mut self, input: impl Into<std::string::String>) -> Self {
            self.address_line3 = Some(input.into());
            self
        }
        /// <p>The third line of the address.</p>
        pub fn set_address_line3(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.address_line3 = input;
            self
        }
        /// <p>The city for the address.</p>
        pub fn city(mut self, input: impl Into<std::string::String>) -> Self {
            self.city = Some(input.into());
            self
        }
        /// <p>The city for the address.</p>
        pub fn set_city(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.city = input;
            self
        }
        /// <p>The state for the address.</p>
        pub fn state_or_region(mut self, input: impl Into<std::string::String>) -> Self {
            self.state_or_region = Some(input.into());
            self
        }
        /// <p>The state for the address.</p>
        pub fn set_state_or_region(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.state_or_region = input;
            self
        }
        /// <p>The district or county for the address.</p>
        pub fn district_or_county(mut self, input: impl Into<std::string::String>) -> Self {
            self.district_or_county = Some(input.into());
            self
        }
        /// <p>The district or county for the address.</p>
        pub fn set_district_or_county(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.district_or_county = input;
            self
        }
        /// <p>The postal code for the address.</p>
        pub fn postal_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.postal_code = Some(input.into());
            self
        }
        /// <p>The postal code for the address.</p>
        pub fn set_postal_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.postal_code = input;
            self
        }
        /// <p>The ISO-3166 two-letter country code for the address.</p>
        pub fn country_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.country_code = Some(input.into());
            self
        }
        /// <p>The ISO-3166 two-letter country code for the address.</p>
        pub fn set_country_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.country_code = input;
            self
        }
        /// <p>The municipality for the address.</p>
        pub fn municipality(mut self, input: impl Into<std::string::String>) -> Self {
            self.municipality = Some(input.into());
            self
        }
        /// <p>The municipality for the address.</p>
        pub fn set_municipality(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.municipality = input;
            self
        }
        /// Consumes the builder and constructs a [`Address`](crate::model::Address).
        pub fn build(self) -> crate::model::Address {
            crate::model::Address {
                contact_name: self.contact_name,
                contact_phone_number: self.contact_phone_number,
                address_line1: self.address_line1,
                address_line2: self.address_line2,
                address_line3: self.address_line3,
                city: self.city,
                state_or_region: self.state_or_region,
                district_or_county: self.district_or_county,
                postal_code: self.postal_code,
                country_code: self.country_code,
                municipality: self.municipality,
            }
        }
    }
}

/// When writing a match expression against `AddressType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let addresstype = unimplemented!();
/// match addresstype {
///     AddressType::OperatingAddress => { /* ... */ },
///     AddressType::ShippingAddress => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `addresstype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `AddressType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `AddressType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `AddressType::NewFeature` is defined.
/// Specifically, when `addresstype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `AddressType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AddressType {
    #[allow(missing_docs)] // documentation missing in model
    OperatingAddress,
    #[allow(missing_docs)] // documentation missing in model
    ShippingAddress,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for AddressType {
    fn from(s: &str) -> Self {
        match s {
            "OPERATING_ADDRESS" => AddressType::OperatingAddress,
            "SHIPPING_ADDRESS" => AddressType::ShippingAddress,
            other => AddressType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for AddressType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AddressType::from(s))
    }
}
impl AddressType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AddressType::OperatingAddress => "OPERATING_ADDRESS",
            AddressType::ShippingAddress => "SHIPPING_ADDRESS",
            AddressType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["OPERATING_ADDRESS", "SHIPPING_ADDRESS"]
    }
}
impl AsRef<str> for AddressType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information about an Outpost.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Outpost {
    /// <p> The ID of the Outpost. </p>
    #[doc(hidden)]
    pub outpost_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services account ID of the Outpost owner.</p>
    #[doc(hidden)]
    pub owner_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the Outpost.</p>
    #[doc(hidden)]
    pub outpost_arn: std::option::Option<std::string::String>,
    /// <p>The ID of the site.</p>
    #[doc(hidden)]
    pub site_id: std::option::Option<std::string::String>,
    /// <p>The name of the Outpost.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The description of the Outpost.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The life cycle status.</p>
    #[doc(hidden)]
    pub life_cycle_status: std::option::Option<std::string::String>,
    /// <p>The Availability Zone.</p>
    #[doc(hidden)]
    pub availability_zone: std::option::Option<std::string::String>,
    /// <p>The ID of the Availability Zone.</p>
    #[doc(hidden)]
    pub availability_zone_id: std::option::Option<std::string::String>,
    /// <p>The Outpost tags.</p>
    #[doc(hidden)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The Amazon Resource Name (ARN) of the site.</p>
    #[doc(hidden)]
    pub site_arn: std::option::Option<std::string::String>,
    /// <p> The hardware type. </p>
    #[doc(hidden)]
    pub supported_hardware_type: std::option::Option<crate::model::SupportedHardwareType>,
}
impl Outpost {
    /// <p> The ID of the Outpost. </p>
    pub fn outpost_id(&self) -> std::option::Option<&str> {
        self.outpost_id.as_deref()
    }
    /// <p>The Amazon Web Services account ID of the Outpost owner.</p>
    pub fn owner_id(&self) -> std::option::Option<&str> {
        self.owner_id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the Outpost.</p>
    pub fn outpost_arn(&self) -> std::option::Option<&str> {
        self.outpost_arn.as_deref()
    }
    /// <p>The ID of the site.</p>
    pub fn site_id(&self) -> std::option::Option<&str> {
        self.site_id.as_deref()
    }
    /// <p>The name of the Outpost.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The description of the Outpost.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The life cycle status.</p>
    pub fn life_cycle_status(&self) -> std::option::Option<&str> {
        self.life_cycle_status.as_deref()
    }
    /// <p>The Availability Zone.</p>
    pub fn availability_zone(&self) -> std::option::Option<&str> {
        self.availability_zone.as_deref()
    }
    /// <p>The ID of the Availability Zone.</p>
    pub fn availability_zone_id(&self) -> std::option::Option<&str> {
        self.availability_zone_id.as_deref()
    }
    /// <p>The Outpost tags.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
    /// <p>The Amazon Resource Name (ARN) of the site.</p>
    pub fn site_arn(&self) -> std::option::Option<&str> {
        self.site_arn.as_deref()
    }
    /// <p> The hardware type. </p>
    pub fn supported_hardware_type(
        &self,
    ) -> std::option::Option<&crate::model::SupportedHardwareType> {
        self.supported_hardware_type.as_ref()
    }
}
impl Outpost {
    /// Creates a new builder-style object to manufacture [`Outpost`](crate::model::Outpost).
    pub fn builder() -> crate::model::outpost::Builder {
        crate::model::outpost::Builder::default()
    }
}

/// See [`Outpost`](crate::model::Outpost).
pub mod outpost {

    /// A builder for [`Outpost`](crate::model::Outpost).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) outpost_id: std::option::Option<std::string::String>,
        pub(crate) owner_id: std::option::Option<std::string::String>,
        pub(crate) outpost_arn: std::option::Option<std::string::String>,
        pub(crate) site_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) life_cycle_status: std::option::Option<std::string::String>,
        pub(crate) availability_zone: std::option::Option<std::string::String>,
        pub(crate) availability_zone_id: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) site_arn: std::option::Option<std::string::String>,
        pub(crate) supported_hardware_type:
            std::option::Option<crate::model::SupportedHardwareType>,
    }
    impl Builder {
        /// <p> The ID of the Outpost. </p>
        pub fn outpost_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.outpost_id = Some(input.into());
            self
        }
        /// <p> The ID of the Outpost. </p>
        pub fn set_outpost_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.outpost_id = input;
            self
        }
        /// <p>The Amazon Web Services account ID of the Outpost owner.</p>
        pub fn owner_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.owner_id = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services account ID of the Outpost owner.</p>
        pub fn set_owner_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.owner_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Outpost.</p>
        pub fn outpost_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.outpost_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Outpost.</p>
        pub fn set_outpost_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.outpost_arn = input;
            self
        }
        /// <p>The ID of the site.</p>
        pub fn site_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.site_id = Some(input.into());
            self
        }
        /// <p>The ID of the site.</p>
        pub fn set_site_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.site_id = input;
            self
        }
        /// <p>The name of the Outpost.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the Outpost.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The description of the Outpost.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the Outpost.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The life cycle status.</p>
        pub fn life_cycle_status(mut self, input: impl Into<std::string::String>) -> Self {
            self.life_cycle_status = Some(input.into());
            self
        }
        /// <p>The life cycle status.</p>
        pub fn set_life_cycle_status(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.life_cycle_status = input;
            self
        }
        /// <p>The Availability Zone.</p>
        pub fn availability_zone(mut self, input: impl Into<std::string::String>) -> Self {
            self.availability_zone = Some(input.into());
            self
        }
        /// <p>The Availability Zone.</p>
        pub fn set_availability_zone(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.availability_zone = input;
            self
        }
        /// <p>The ID of the Availability Zone.</p>
        pub fn availability_zone_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.availability_zone_id = Some(input.into());
            self
        }
        /// <p>The ID of the Availability Zone.</p>
        pub fn set_availability_zone_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.availability_zone_id = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The Outpost tags.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>The Outpost tags.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the site.</p>
        pub fn site_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.site_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the site.</p>
        pub fn set_site_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.site_arn = input;
            self
        }
        /// <p> The hardware type. </p>
        pub fn supported_hardware_type(
            mut self,
            input: crate::model::SupportedHardwareType,
        ) -> Self {
            self.supported_hardware_type = Some(input);
            self
        }
        /// <p> The hardware type. </p>
        pub fn set_supported_hardware_type(
            mut self,
            input: std::option::Option<crate::model::SupportedHardwareType>,
        ) -> Self {
            self.supported_hardware_type = input;
            self
        }
        /// Consumes the builder and constructs a [`Outpost`](crate::model::Outpost).
        pub fn build(self) -> crate::model::Outpost {
            crate::model::Outpost {
                outpost_id: self.outpost_id,
                owner_id: self.owner_id,
                outpost_arn: self.outpost_arn,
                site_id: self.site_id,
                name: self.name,
                description: self.description,
                life_cycle_status: self.life_cycle_status,
                availability_zone: self.availability_zone,
                availability_zone_id: self.availability_zone_id,
                tags: self.tags,
                site_arn: self.site_arn,
                supported_hardware_type: self.supported_hardware_type,
            }
        }
    }
}

/// When writing a match expression against `SupportedHardwareType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let supportedhardwaretype = unimplemented!();
/// match supportedhardwaretype {
///     SupportedHardwareType::Rack => { /* ... */ },
///     SupportedHardwareType::Server => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `supportedhardwaretype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `SupportedHardwareType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `SupportedHardwareType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `SupportedHardwareType::NewFeature` is defined.
/// Specifically, when `supportedhardwaretype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `SupportedHardwareType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SupportedHardwareType {
    #[allow(missing_docs)] // documentation missing in model
    Rack,
    #[allow(missing_docs)] // documentation missing in model
    Server,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for SupportedHardwareType {
    fn from(s: &str) -> Self {
        match s {
            "RACK" => SupportedHardwareType::Rack,
            "SERVER" => SupportedHardwareType::Server,
            other => {
                SupportedHardwareType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for SupportedHardwareType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SupportedHardwareType::from(s))
    }
}
impl SupportedHardwareType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SupportedHardwareType::Rack => "RACK",
            SupportedHardwareType::Server => "SERVER",
            SupportedHardwareType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["RACK", "SERVER"]
    }
}
impl AsRef<str> for SupportedHardwareType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p> A summary of line items in your order. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct OrderSummary {
    /// <p> The ID of the Outpost. </p>
    #[doc(hidden)]
    pub outpost_id: std::option::Option<std::string::String>,
    /// <p> The ID of the order. </p>
    #[doc(hidden)]
    pub order_id: std::option::Option<std::string::String>,
    /// <p> The type of order. </p>
    #[doc(hidden)]
    pub order_type: std::option::Option<crate::model::OrderType>,
    /// <p>The status of the order.</p>
    /// <ul>
    /// <li> <p> <code>PREPARING</code> - Order is received and is being prepared.</p> </li>
    /// <li> <p> <code>IN_PROGRESS</code> - Order is either being built, shipped, or installed. For more information, see the <code>LineItem</code> status.</p> </li>
    /// <li> <p> <code>COMPLETED</code> - Order is complete.</p> </li>
    /// <li> <p> <code>CANCELLED</code> - Order is cancelled.</p> </li>
    /// <li> <p> <code>ERROR</code> - Customer should contact support.</p> </li>
    /// </ul> <note>
    /// <p>The following statuses are deprecated: <code>RECEIVED</code>, <code>PENDING</code>, <code>PROCESSING</code>, <code>INSTALLING</code>, and <code>FULFILLED</code>. </p>
    /// </note>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::OrderStatus>,
    /// <p> The status of all line items in the order. </p>
    #[doc(hidden)]
    pub line_item_counts_by_status:
        std::option::Option<std::collections::HashMap<crate::model::LineItemStatus, i32>>,
    /// <p> The submission date for the order. </p>
    #[doc(hidden)]
    pub order_submission_date: std::option::Option<aws_smithy_types::DateTime>,
    /// <p> The fulfilment date for the order. </p>
    #[doc(hidden)]
    pub order_fulfilled_date: std::option::Option<aws_smithy_types::DateTime>,
}
impl OrderSummary {
    /// <p> The ID of the Outpost. </p>
    pub fn outpost_id(&self) -> std::option::Option<&str> {
        self.outpost_id.as_deref()
    }
    /// <p> The ID of the order. </p>
    pub fn order_id(&self) -> std::option::Option<&str> {
        self.order_id.as_deref()
    }
    /// <p> The type of order. </p>
    pub fn order_type(&self) -> std::option::Option<&crate::model::OrderType> {
        self.order_type.as_ref()
    }
    /// <p>The status of the order.</p>
    /// <ul>
    /// <li> <p> <code>PREPARING</code> - Order is received and is being prepared.</p> </li>
    /// <li> <p> <code>IN_PROGRESS</code> - Order is either being built, shipped, or installed. For more information, see the <code>LineItem</code> status.</p> </li>
    /// <li> <p> <code>COMPLETED</code> - Order is complete.</p> </li>
    /// <li> <p> <code>CANCELLED</code> - Order is cancelled.</p> </li>
    /// <li> <p> <code>ERROR</code> - Customer should contact support.</p> </li>
    /// </ul> <note>
    /// <p>The following statuses are deprecated: <code>RECEIVED</code>, <code>PENDING</code>, <code>PROCESSING</code>, <code>INSTALLING</code>, and <code>FULFILLED</code>. </p>
    /// </note>
    pub fn status(&self) -> std::option::Option<&crate::model::OrderStatus> {
        self.status.as_ref()
    }
    /// <p> The status of all line items in the order. </p>
    pub fn line_item_counts_by_status(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<crate::model::LineItemStatus, i32>> {
        self.line_item_counts_by_status.as_ref()
    }
    /// <p> The submission date for the order. </p>
    pub fn order_submission_date(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.order_submission_date.as_ref()
    }
    /// <p> The fulfilment date for the order. </p>
    pub fn order_fulfilled_date(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.order_fulfilled_date.as_ref()
    }
}
impl OrderSummary {
    /// Creates a new builder-style object to manufacture [`OrderSummary`](crate::model::OrderSummary).
    pub fn builder() -> crate::model::order_summary::Builder {
        crate::model::order_summary::Builder::default()
    }
}

/// See [`OrderSummary`](crate::model::OrderSummary).
pub mod order_summary {

    /// A builder for [`OrderSummary`](crate::model::OrderSummary).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) outpost_id: std::option::Option<std::string::String>,
        pub(crate) order_id: std::option::Option<std::string::String>,
        pub(crate) order_type: std::option::Option<crate::model::OrderType>,
        pub(crate) status: std::option::Option<crate::model::OrderStatus>,
        pub(crate) line_item_counts_by_status:
            std::option::Option<std::collections::HashMap<crate::model::LineItemStatus, i32>>,
        pub(crate) order_submission_date: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) order_fulfilled_date: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p> The ID of the Outpost. </p>
        pub fn outpost_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.outpost_id = Some(input.into());
            self
        }
        /// <p> The ID of the Outpost. </p>
        pub fn set_outpost_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.outpost_id = input;
            self
        }
        /// <p> The ID of the order. </p>
        pub fn order_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.order_id = Some(input.into());
            self
        }
        /// <p> The ID of the order. </p>
        pub fn set_order_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.order_id = input;
            self
        }
        /// <p> The type of order. </p>
        pub fn order_type(mut self, input: crate::model::OrderType) -> Self {
            self.order_type = Some(input);
            self
        }
        /// <p> The type of order. </p>
        pub fn set_order_type(
            mut self,
            input: std::option::Option<crate::model::OrderType>,
        ) -> Self {
            self.order_type = input;
            self
        }
        /// <p>The status of the order.</p>
        /// <ul>
        /// <li> <p> <code>PREPARING</code> - Order is received and is being prepared.</p> </li>
        /// <li> <p> <code>IN_PROGRESS</code> - Order is either being built, shipped, or installed. For more information, see the <code>LineItem</code> status.</p> </li>
        /// <li> <p> <code>COMPLETED</code> - Order is complete.</p> </li>
        /// <li> <p> <code>CANCELLED</code> - Order is cancelled.</p> </li>
        /// <li> <p> <code>ERROR</code> - Customer should contact support.</p> </li>
        /// </ul> <note>
        /// <p>The following statuses are deprecated: <code>RECEIVED</code>, <code>PENDING</code>, <code>PROCESSING</code>, <code>INSTALLING</code>, and <code>FULFILLED</code>. </p>
        /// </note>
        pub fn status(mut self, input: crate::model::OrderStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the order.</p>
        /// <ul>
        /// <li> <p> <code>PREPARING</code> - Order is received and is being prepared.</p> </li>
        /// <li> <p> <code>IN_PROGRESS</code> - Order is either being built, shipped, or installed. For more information, see the <code>LineItem</code> status.</p> </li>
        /// <li> <p> <code>COMPLETED</code> - Order is complete.</p> </li>
        /// <li> <p> <code>CANCELLED</code> - Order is cancelled.</p> </li>
        /// <li> <p> <code>ERROR</code> - Customer should contact support.</p> </li>
        /// </ul> <note>
        /// <p>The following statuses are deprecated: <code>RECEIVED</code>, <code>PENDING</code>, <code>PROCESSING</code>, <code>INSTALLING</code>, and <code>FULFILLED</code>. </p>
        /// </note>
        pub fn set_status(mut self, input: std::option::Option<crate::model::OrderStatus>) -> Self {
            self.status = input;
            self
        }
        /// Adds a key-value pair to `line_item_counts_by_status`.
        ///
        /// To override the contents of this collection use [`set_line_item_counts_by_status`](Self::set_line_item_counts_by_status).
        ///
        /// <p> The status of all line items in the order. </p>
        pub fn line_item_counts_by_status(
            mut self,
            k: crate::model::LineItemStatus,
            v: i32,
        ) -> Self {
            let mut hash_map = self.line_item_counts_by_status.unwrap_or_default();
            hash_map.insert(k, v);
            self.line_item_counts_by_status = Some(hash_map);
            self
        }
        /// <p> The status of all line items in the order. </p>
        pub fn set_line_item_counts_by_status(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<crate::model::LineItemStatus, i32>,
            >,
        ) -> Self {
            self.line_item_counts_by_status = input;
            self
        }
        /// <p> The submission date for the order. </p>
        pub fn order_submission_date(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.order_submission_date = Some(input);
            self
        }
        /// <p> The submission date for the order. </p>
        pub fn set_order_submission_date(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.order_submission_date = input;
            self
        }
        /// <p> The fulfilment date for the order. </p>
        pub fn order_fulfilled_date(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.order_fulfilled_date = Some(input);
            self
        }
        /// <p> The fulfilment date for the order. </p>
        pub fn set_order_fulfilled_date(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.order_fulfilled_date = input;
            self
        }
        /// Consumes the builder and constructs a [`OrderSummary`](crate::model::OrderSummary).
        pub fn build(self) -> crate::model::OrderSummary {
            crate::model::OrderSummary {
                outpost_id: self.outpost_id,
                order_id: self.order_id,
                order_type: self.order_type,
                status: self.status,
                line_item_counts_by_status: self.line_item_counts_by_status,
                order_submission_date: self.order_submission_date,
                order_fulfilled_date: self.order_fulfilled_date,
            }
        }
    }
}

/// When writing a match expression against `LineItemStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let lineitemstatus = unimplemented!();
/// match lineitemstatus {
///     LineItemStatus::Building => { /* ... */ },
///     LineItemStatus::Cancelled => { /* ... */ },
///     LineItemStatus::Delivered => { /* ... */ },
///     LineItemStatus::Error => { /* ... */ },
///     LineItemStatus::Installed => { /* ... */ },
///     LineItemStatus::Installing => { /* ... */ },
///     LineItemStatus::Preparing => { /* ... */ },
///     LineItemStatus::Shipped => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `lineitemstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `LineItemStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `LineItemStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `LineItemStatus::NewFeature` is defined.
/// Specifically, when `lineitemstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `LineItemStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum LineItemStatus {
    #[allow(missing_docs)] // documentation missing in model
    Building,
    #[allow(missing_docs)] // documentation missing in model
    Cancelled,
    #[allow(missing_docs)] // documentation missing in model
    Delivered,
    #[allow(missing_docs)] // documentation missing in model
    Error,
    #[allow(missing_docs)] // documentation missing in model
    Installed,
    #[allow(missing_docs)] // documentation missing in model
    Installing,
    #[allow(missing_docs)] // documentation missing in model
    Preparing,
    #[allow(missing_docs)] // documentation missing in model
    Shipped,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for LineItemStatus {
    fn from(s: &str) -> Self {
        match s {
            "BUILDING" => LineItemStatus::Building,
            "CANCELLED" => LineItemStatus::Cancelled,
            "DELIVERED" => LineItemStatus::Delivered,
            "ERROR" => LineItemStatus::Error,
            "INSTALLED" => LineItemStatus::Installed,
            "INSTALLING" => LineItemStatus::Installing,
            "PREPARING" => LineItemStatus::Preparing,
            "SHIPPED" => LineItemStatus::Shipped,
            other => LineItemStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for LineItemStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(LineItemStatus::from(s))
    }
}
impl LineItemStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            LineItemStatus::Building => "BUILDING",
            LineItemStatus::Cancelled => "CANCELLED",
            LineItemStatus::Delivered => "DELIVERED",
            LineItemStatus::Error => "ERROR",
            LineItemStatus::Installed => "INSTALLED",
            LineItemStatus::Installing => "INSTALLING",
            LineItemStatus::Preparing => "PREPARING",
            LineItemStatus::Shipped => "SHIPPED",
            LineItemStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "BUILDING",
            "CANCELLED",
            "DELIVERED",
            "ERROR",
            "INSTALLED",
            "INSTALLING",
            "PREPARING",
            "SHIPPED",
        ]
    }
}
impl AsRef<str> for LineItemStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `OrderStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let orderstatus = unimplemented!();
/// match orderstatus {
///     OrderStatus::Cancelled => { /* ... */ },
///     OrderStatus::Completed => { /* ... */ },
///     OrderStatus::Error => { /* ... */ },
///     OrderStatus::Fulfilled => { /* ... */ },
///     OrderStatus::Installing => { /* ... */ },
///     OrderStatus::InProgress => { /* ... */ },
///     OrderStatus::Pending => { /* ... */ },
///     OrderStatus::Preparing => { /* ... */ },
///     OrderStatus::Processing => { /* ... */ },
///     OrderStatus::Received => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `orderstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `OrderStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `OrderStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `OrderStatus::NewFeature` is defined.
/// Specifically, when `orderstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `OrderStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum OrderStatus {
    #[allow(missing_docs)] // documentation missing in model
    Cancelled,
    #[allow(missing_docs)] // documentation missing in model
    Completed,
    #[allow(missing_docs)] // documentation missing in model
    Error,
    #[allow(missing_docs)] // documentation missing in model
    Fulfilled,
    #[allow(missing_docs)] // documentation missing in model
    Installing,
    #[allow(missing_docs)] // documentation missing in model
    InProgress,
    #[allow(missing_docs)] // documentation missing in model
    Pending,
    #[allow(missing_docs)] // documentation missing in model
    Preparing,
    #[allow(missing_docs)] // documentation missing in model
    Processing,
    #[allow(missing_docs)] // documentation missing in model
    Received,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for OrderStatus {
    fn from(s: &str) -> Self {
        match s {
            "CANCELLED" => OrderStatus::Cancelled,
            "COMPLETED" => OrderStatus::Completed,
            "ERROR" => OrderStatus::Error,
            "FULFILLED" => OrderStatus::Fulfilled,
            "INSTALLING" => OrderStatus::Installing,
            "IN_PROGRESS" => OrderStatus::InProgress,
            "PENDING" => OrderStatus::Pending,
            "PREPARING" => OrderStatus::Preparing,
            "PROCESSING" => OrderStatus::Processing,
            "RECEIVED" => OrderStatus::Received,
            other => OrderStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for OrderStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(OrderStatus::from(s))
    }
}
impl OrderStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            OrderStatus::Cancelled => "CANCELLED",
            OrderStatus::Completed => "COMPLETED",
            OrderStatus::Error => "ERROR",
            OrderStatus::Fulfilled => "FULFILLED",
            OrderStatus::Installing => "INSTALLING",
            OrderStatus::InProgress => "IN_PROGRESS",
            OrderStatus::Pending => "PENDING",
            OrderStatus::Preparing => "PREPARING",
            OrderStatus::Processing => "PROCESSING",
            OrderStatus::Received => "RECEIVED",
            OrderStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "CANCELLED",
            "COMPLETED",
            "ERROR",
            "FULFILLED",
            "INSTALLING",
            "IN_PROGRESS",
            "PENDING",
            "PREPARING",
            "PROCESSING",
            "RECEIVED",
        ]
    }
}
impl AsRef<str> for OrderStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `OrderType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let ordertype = unimplemented!();
/// match ordertype {
///     OrderType::Outpost => { /* ... */ },
///     OrderType::Replacement => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `ordertype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `OrderType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `OrderType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `OrderType::NewFeature` is defined.
/// Specifically, when `ordertype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `OrderType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum OrderType {
    #[allow(missing_docs)] // documentation missing in model
    Outpost,
    #[allow(missing_docs)] // documentation missing in model
    Replacement,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for OrderType {
    fn from(s: &str) -> Self {
        match s {
            "OUTPOST" => OrderType::Outpost,
            "REPLACEMENT" => OrderType::Replacement,
            other => OrderType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for OrderType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(OrderType::from(s))
    }
}
impl OrderType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            OrderType::Outpost => "OUTPOST",
            OrderType::Replacement => "REPLACEMENT",
            OrderType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["OUTPOST", "REPLACEMENT"]
    }
}
impl AsRef<str> for OrderType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p> Information about a catalog item. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CatalogItem {
    /// <p> The ID of the catalog item. </p>
    #[doc(hidden)]
    pub catalog_item_id: std::option::Option<std::string::String>,
    /// <p> The status of a catalog item. </p>
    #[doc(hidden)]
    pub item_status: std::option::Option<crate::model::CatalogItemStatus>,
    /// <p> Information about the EC2 capacity of an item. </p>
    #[doc(hidden)]
    pub ec2_capacities: std::option::Option<std::vec::Vec<crate::model::Ec2Capacity>>,
    /// <p> Information about the power draw of an item. </p>
    #[doc(hidden)]
    pub power_kva: std::option::Option<f32>,
    /// <p> The weight of the item in pounds. </p>
    #[doc(hidden)]
    pub weight_lbs: std::option::Option<i32>,
    /// <p> The uplink speed this catalog item requires for the connection to the Region. </p>
    #[doc(hidden)]
    pub supported_uplink_gbps: std::option::Option<std::vec::Vec<i32>>,
    /// <p> The supported storage options for the catalog item. </p>
    #[doc(hidden)]
    pub supported_storage: std::option::Option<std::vec::Vec<crate::model::SupportedStorageEnum>>,
}
impl CatalogItem {
    /// <p> The ID of the catalog item. </p>
    pub fn catalog_item_id(&self) -> std::option::Option<&str> {
        self.catalog_item_id.as_deref()
    }
    /// <p> The status of a catalog item. </p>
    pub fn item_status(&self) -> std::option::Option<&crate::model::CatalogItemStatus> {
        self.item_status.as_ref()
    }
    /// <p> Information about the EC2 capacity of an item. </p>
    pub fn ec2_capacities(&self) -> std::option::Option<&[crate::model::Ec2Capacity]> {
        self.ec2_capacities.as_deref()
    }
    /// <p> Information about the power draw of an item. </p>
    pub fn power_kva(&self) -> std::option::Option<f32> {
        self.power_kva
    }
    /// <p> The weight of the item in pounds. </p>
    pub fn weight_lbs(&self) -> std::option::Option<i32> {
        self.weight_lbs
    }
    /// <p> The uplink speed this catalog item requires for the connection to the Region. </p>
    pub fn supported_uplink_gbps(&self) -> std::option::Option<&[i32]> {
        self.supported_uplink_gbps.as_deref()
    }
    /// <p> The supported storage options for the catalog item. </p>
    pub fn supported_storage(&self) -> std::option::Option<&[crate::model::SupportedStorageEnum]> {
        self.supported_storage.as_deref()
    }
}
impl CatalogItem {
    /// Creates a new builder-style object to manufacture [`CatalogItem`](crate::model::CatalogItem).
    pub fn builder() -> crate::model::catalog_item::Builder {
        crate::model::catalog_item::Builder::default()
    }
}

/// See [`CatalogItem`](crate::model::CatalogItem).
pub mod catalog_item {

    /// A builder for [`CatalogItem`](crate::model::CatalogItem).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) catalog_item_id: std::option::Option<std::string::String>,
        pub(crate) item_status: std::option::Option<crate::model::CatalogItemStatus>,
        pub(crate) ec2_capacities: std::option::Option<std::vec::Vec<crate::model::Ec2Capacity>>,
        pub(crate) power_kva: std::option::Option<f32>,
        pub(crate) weight_lbs: std::option::Option<i32>,
        pub(crate) supported_uplink_gbps: std::option::Option<std::vec::Vec<i32>>,
        pub(crate) supported_storage:
            std::option::Option<std::vec::Vec<crate::model::SupportedStorageEnum>>,
    }
    impl Builder {
        /// <p> The ID of the catalog item. </p>
        pub fn catalog_item_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.catalog_item_id = Some(input.into());
            self
        }
        /// <p> The ID of the catalog item. </p>
        pub fn set_catalog_item_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.catalog_item_id = input;
            self
        }
        /// <p> The status of a catalog item. </p>
        pub fn item_status(mut self, input: crate::model::CatalogItemStatus) -> Self {
            self.item_status = Some(input);
            self
        }
        /// <p> The status of a catalog item. </p>
        pub fn set_item_status(
            mut self,
            input: std::option::Option<crate::model::CatalogItemStatus>,
        ) -> Self {
            self.item_status = input;
            self
        }
        /// Appends an item to `ec2_capacities`.
        ///
        /// To override the contents of this collection use [`set_ec2_capacities`](Self::set_ec2_capacities).
        ///
        /// <p> Information about the EC2 capacity of an item. </p>
        pub fn ec2_capacities(mut self, input: crate::model::Ec2Capacity) -> Self {
            let mut v = self.ec2_capacities.unwrap_or_default();
            v.push(input);
            self.ec2_capacities = Some(v);
            self
        }
        /// <p> Information about the EC2 capacity of an item. </p>
        pub fn set_ec2_capacities(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Ec2Capacity>>,
        ) -> Self {
            self.ec2_capacities = input;
            self
        }
        /// <p> Information about the power draw of an item. </p>
        pub fn power_kva(mut self, input: f32) -> Self {
            self.power_kva = Some(input);
            self
        }
        /// <p> Information about the power draw of an item. </p>
        pub fn set_power_kva(mut self, input: std::option::Option<f32>) -> Self {
            self.power_kva = input;
            self
        }
        /// <p> The weight of the item in pounds. </p>
        pub fn weight_lbs(mut self, input: i32) -> Self {
            self.weight_lbs = Some(input);
            self
        }
        /// <p> The weight of the item in pounds. </p>
        pub fn set_weight_lbs(mut self, input: std::option::Option<i32>) -> Self {
            self.weight_lbs = input;
            self
        }
        /// Appends an item to `supported_uplink_gbps`.
        ///
        /// To override the contents of this collection use [`set_supported_uplink_gbps`](Self::set_supported_uplink_gbps).
        ///
        /// <p> The uplink speed this catalog item requires for the connection to the Region. </p>
        pub fn supported_uplink_gbps(mut self, input: i32) -> Self {
            let mut v = self.supported_uplink_gbps.unwrap_or_default();
            v.push(input);
            self.supported_uplink_gbps = Some(v);
            self
        }
        /// <p> The uplink speed this catalog item requires for the connection to the Region. </p>
        pub fn set_supported_uplink_gbps(
            mut self,
            input: std::option::Option<std::vec::Vec<i32>>,
        ) -> Self {
            self.supported_uplink_gbps = input;
            self
        }
        /// Appends an item to `supported_storage`.
        ///
        /// To override the contents of this collection use [`set_supported_storage`](Self::set_supported_storage).
        ///
        /// <p> The supported storage options for the catalog item. </p>
        pub fn supported_storage(mut self, input: crate::model::SupportedStorageEnum) -> Self {
            let mut v = self.supported_storage.unwrap_or_default();
            v.push(input);
            self.supported_storage = Some(v);
            self
        }
        /// <p> The supported storage options for the catalog item. </p>
        pub fn set_supported_storage(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SupportedStorageEnum>>,
        ) -> Self {
            self.supported_storage = input;
            self
        }
        /// Consumes the builder and constructs a [`CatalogItem`](crate::model::CatalogItem).
        pub fn build(self) -> crate::model::CatalogItem {
            crate::model::CatalogItem {
                catalog_item_id: self.catalog_item_id,
                item_status: self.item_status,
                ec2_capacities: self.ec2_capacities,
                power_kva: self.power_kva,
                weight_lbs: self.weight_lbs,
                supported_uplink_gbps: self.supported_uplink_gbps,
                supported_storage: self.supported_storage,
            }
        }
    }
}

/// When writing a match expression against `SupportedStorageEnum`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let supportedstorageenum = unimplemented!();
/// match supportedstorageenum {
///     SupportedStorageEnum::Ebs => { /* ... */ },
///     SupportedStorageEnum::S3 => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `supportedstorageenum` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `SupportedStorageEnum::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `SupportedStorageEnum::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `SupportedStorageEnum::NewFeature` is defined.
/// Specifically, when `supportedstorageenum` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `SupportedStorageEnum::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SupportedStorageEnum {
    #[allow(missing_docs)] // documentation missing in model
    Ebs,
    #[allow(missing_docs)] // documentation missing in model
    S3,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for SupportedStorageEnum {
    fn from(s: &str) -> Self {
        match s {
            "EBS" => SupportedStorageEnum::Ebs,
            "S3" => SupportedStorageEnum::S3,
            other => {
                SupportedStorageEnum::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for SupportedStorageEnum {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SupportedStorageEnum::from(s))
    }
}
impl SupportedStorageEnum {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SupportedStorageEnum::Ebs => "EBS",
            SupportedStorageEnum::S3 => "S3",
            SupportedStorageEnum::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["EBS", "S3"]
    }
}
impl AsRef<str> for SupportedStorageEnum {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p> Information about EC2 capacity. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Ec2Capacity {
    /// <p> The family of the EC2 capacity. </p>
    #[doc(hidden)]
    pub family: std::option::Option<std::string::String>,
    /// <p> The maximum size of the EC2 capacity. </p>
    #[doc(hidden)]
    pub max_size: std::option::Option<std::string::String>,
    /// <p> The quantity of the EC2 capacity. </p>
    #[doc(hidden)]
    pub quantity: std::option::Option<std::string::String>,
}
impl Ec2Capacity {
    /// <p> The family of the EC2 capacity. </p>
    pub fn family(&self) -> std::option::Option<&str> {
        self.family.as_deref()
    }
    /// <p> The maximum size of the EC2 capacity. </p>
    pub fn max_size(&self) -> std::option::Option<&str> {
        self.max_size.as_deref()
    }
    /// <p> The quantity of the EC2 capacity. </p>
    pub fn quantity(&self) -> std::option::Option<&str> {
        self.quantity.as_deref()
    }
}
impl Ec2Capacity {
    /// Creates a new builder-style object to manufacture [`Ec2Capacity`](crate::model::Ec2Capacity).
    pub fn builder() -> crate::model::ec2_capacity::Builder {
        crate::model::ec2_capacity::Builder::default()
    }
}

/// See [`Ec2Capacity`](crate::model::Ec2Capacity).
pub mod ec2_capacity {

    /// A builder for [`Ec2Capacity`](crate::model::Ec2Capacity).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) family: std::option::Option<std::string::String>,
        pub(crate) max_size: std::option::Option<std::string::String>,
        pub(crate) quantity: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The family of the EC2 capacity. </p>
        pub fn family(mut self, input: impl Into<std::string::String>) -> Self {
            self.family = Some(input.into());
            self
        }
        /// <p> The family of the EC2 capacity. </p>
        pub fn set_family(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.family = input;
            self
        }
        /// <p> The maximum size of the EC2 capacity. </p>
        pub fn max_size(mut self, input: impl Into<std::string::String>) -> Self {
            self.max_size = Some(input.into());
            self
        }
        /// <p> The maximum size of the EC2 capacity. </p>
        pub fn set_max_size(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.max_size = input;
            self
        }
        /// <p> The quantity of the EC2 capacity. </p>
        pub fn quantity(mut self, input: impl Into<std::string::String>) -> Self {
            self.quantity = Some(input.into());
            self
        }
        /// <p> The quantity of the EC2 capacity. </p>
        pub fn set_quantity(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.quantity = input;
            self
        }
        /// Consumes the builder and constructs a [`Ec2Capacity`](crate::model::Ec2Capacity).
        pub fn build(self) -> crate::model::Ec2Capacity {
            crate::model::Ec2Capacity {
                family: self.family,
                max_size: self.max_size,
                quantity: self.quantity,
            }
        }
    }
}

/// When writing a match expression against `CatalogItemStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let catalogitemstatus = unimplemented!();
/// match catalogitemstatus {
///     CatalogItemStatus::Available => { /* ... */ },
///     CatalogItemStatus::Discontinued => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `catalogitemstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `CatalogItemStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `CatalogItemStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `CatalogItemStatus::NewFeature` is defined.
/// Specifically, when `catalogitemstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `CatalogItemStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum CatalogItemStatus {
    #[allow(missing_docs)] // documentation missing in model
    Available,
    #[allow(missing_docs)] // documentation missing in model
    Discontinued,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for CatalogItemStatus {
    fn from(s: &str) -> Self {
        match s {
            "AVAILABLE" => CatalogItemStatus::Available,
            "DISCONTINUED" => CatalogItemStatus::Discontinued,
            other => {
                CatalogItemStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for CatalogItemStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(CatalogItemStatus::from(s))
    }
}
impl CatalogItemStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            CatalogItemStatus::Available => "AVAILABLE",
            CatalogItemStatus::Discontinued => "DISCONTINUED",
            CatalogItemStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["AVAILABLE", "DISCONTINUED"]
    }
}
impl AsRef<str> for CatalogItemStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `CatalogItemClass`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let catalogitemclass = unimplemented!();
/// match catalogitemclass {
///     CatalogItemClass::Rack => { /* ... */ },
///     CatalogItemClass::Server => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `catalogitemclass` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `CatalogItemClass::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `CatalogItemClass::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `CatalogItemClass::NewFeature` is defined.
/// Specifically, when `catalogitemclass` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `CatalogItemClass::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum CatalogItemClass {
    #[allow(missing_docs)] // documentation missing in model
    Rack,
    #[allow(missing_docs)] // documentation missing in model
    Server,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for CatalogItemClass {
    fn from(s: &str) -> Self {
        match s {
            "RACK" => CatalogItemClass::Rack,
            "SERVER" => CatalogItemClass::Server,
            other => CatalogItemClass::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for CatalogItemClass {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(CatalogItemClass::from(s))
    }
}
impl CatalogItemClass {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            CatalogItemClass::Rack => "RACK",
            CatalogItemClass::Server => "SERVER",
            CatalogItemClass::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["RACK", "SERVER"]
    }
}
impl AsRef<str> for CatalogItemClass {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p> Information about hardware assets. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AssetInfo {
    /// <p> The ID of the asset. </p>
    #[doc(hidden)]
    pub asset_id: std::option::Option<std::string::String>,
    /// <p> The rack ID of the asset. </p>
    #[doc(hidden)]
    pub rack_id: std::option::Option<std::string::String>,
    /// <p> The type of the asset. </p>
    #[doc(hidden)]
    pub asset_type: std::option::Option<crate::model::AssetType>,
    /// <p> Information about compute hardware assets. </p>
    #[doc(hidden)]
    pub compute_attributes: std::option::Option<crate::model::ComputeAttributes>,
    /// <p> The position of an asset in a rack. </p>
    #[doc(hidden)]
    pub asset_location: std::option::Option<crate::model::AssetLocation>,
}
impl AssetInfo {
    /// <p> The ID of the asset. </p>
    pub fn asset_id(&self) -> std::option::Option<&str> {
        self.asset_id.as_deref()
    }
    /// <p> The rack ID of the asset. </p>
    pub fn rack_id(&self) -> std::option::Option<&str> {
        self.rack_id.as_deref()
    }
    /// <p> The type of the asset. </p>
    pub fn asset_type(&self) -> std::option::Option<&crate::model::AssetType> {
        self.asset_type.as_ref()
    }
    /// <p> Information about compute hardware assets. </p>
    pub fn compute_attributes(&self) -> std::option::Option<&crate::model::ComputeAttributes> {
        self.compute_attributes.as_ref()
    }
    /// <p> The position of an asset in a rack. </p>
    pub fn asset_location(&self) -> std::option::Option<&crate::model::AssetLocation> {
        self.asset_location.as_ref()
    }
}
impl AssetInfo {
    /// Creates a new builder-style object to manufacture [`AssetInfo`](crate::model::AssetInfo).
    pub fn builder() -> crate::model::asset_info::Builder {
        crate::model::asset_info::Builder::default()
    }
}

/// See [`AssetInfo`](crate::model::AssetInfo).
pub mod asset_info {

    /// A builder for [`AssetInfo`](crate::model::AssetInfo).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) asset_id: std::option::Option<std::string::String>,
        pub(crate) rack_id: std::option::Option<std::string::String>,
        pub(crate) asset_type: std::option::Option<crate::model::AssetType>,
        pub(crate) compute_attributes: std::option::Option<crate::model::ComputeAttributes>,
        pub(crate) asset_location: std::option::Option<crate::model::AssetLocation>,
    }
    impl Builder {
        /// <p> The ID of the asset. </p>
        pub fn asset_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.asset_id = Some(input.into());
            self
        }
        /// <p> The ID of the asset. </p>
        pub fn set_asset_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.asset_id = input;
            self
        }
        /// <p> The rack ID of the asset. </p>
        pub fn rack_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.rack_id = Some(input.into());
            self
        }
        /// <p> The rack ID of the asset. </p>
        pub fn set_rack_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.rack_id = input;
            self
        }
        /// <p> The type of the asset. </p>
        pub fn asset_type(mut self, input: crate::model::AssetType) -> Self {
            self.asset_type = Some(input);
            self
        }
        /// <p> The type of the asset. </p>
        pub fn set_asset_type(
            mut self,
            input: std::option::Option<crate::model::AssetType>,
        ) -> Self {
            self.asset_type = input;
            self
        }
        /// <p> Information about compute hardware assets. </p>
        pub fn compute_attributes(mut self, input: crate::model::ComputeAttributes) -> Self {
            self.compute_attributes = Some(input);
            self
        }
        /// <p> Information about compute hardware assets. </p>
        pub fn set_compute_attributes(
            mut self,
            input: std::option::Option<crate::model::ComputeAttributes>,
        ) -> Self {
            self.compute_attributes = input;
            self
        }
        /// <p> The position of an asset in a rack. </p>
        pub fn asset_location(mut self, input: crate::model::AssetLocation) -> Self {
            self.asset_location = Some(input);
            self
        }
        /// <p> The position of an asset in a rack. </p>
        pub fn set_asset_location(
            mut self,
            input: std::option::Option<crate::model::AssetLocation>,
        ) -> Self {
            self.asset_location = input;
            self
        }
        /// Consumes the builder and constructs a [`AssetInfo`](crate::model::AssetInfo).
        pub fn build(self) -> crate::model::AssetInfo {
            crate::model::AssetInfo {
                asset_id: self.asset_id,
                rack_id: self.rack_id,
                asset_type: self.asset_type,
                compute_attributes: self.compute_attributes,
                asset_location: self.asset_location,
            }
        }
    }
}

/// <p> Information about the position of the asset in a rack. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AssetLocation {
    /// <p> The position of an asset in a rack measured in rack units. </p>
    #[doc(hidden)]
    pub rack_elevation: std::option::Option<f32>,
}
impl AssetLocation {
    /// <p> The position of an asset in a rack measured in rack units. </p>
    pub fn rack_elevation(&self) -> std::option::Option<f32> {
        self.rack_elevation
    }
}
impl AssetLocation {
    /// Creates a new builder-style object to manufacture [`AssetLocation`](crate::model::AssetLocation).
    pub fn builder() -> crate::model::asset_location::Builder {
        crate::model::asset_location::Builder::default()
    }
}

/// See [`AssetLocation`](crate::model::AssetLocation).
pub mod asset_location {

    /// A builder for [`AssetLocation`](crate::model::AssetLocation).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) rack_elevation: std::option::Option<f32>,
    }
    impl Builder {
        /// <p> The position of an asset in a rack measured in rack units. </p>
        pub fn rack_elevation(mut self, input: f32) -> Self {
            self.rack_elevation = Some(input);
            self
        }
        /// <p> The position of an asset in a rack measured in rack units. </p>
        pub fn set_rack_elevation(mut self, input: std::option::Option<f32>) -> Self {
            self.rack_elevation = input;
            self
        }
        /// Consumes the builder and constructs a [`AssetLocation`](crate::model::AssetLocation).
        pub fn build(self) -> crate::model::AssetLocation {
            crate::model::AssetLocation {
                rack_elevation: self.rack_elevation,
            }
        }
    }
}

/// <p> Information about compute hardware assets. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ComputeAttributes {
    /// <p> The host ID of the Dedicated Host on the asset. </p>
    #[doc(hidden)]
    pub host_id: std::option::Option<std::string::String>,
    /// <p>The state.</p>
    /// <ul>
    /// <li> <p>ACTIVE - The asset is available and can provide capacity for new compute resources.</p> </li>
    /// <li> <p>ISOLATED - The asset is undergoing maintenance and can't provide capacity for new compute resources. Existing compute resources on the asset are not affected.</p> </li>
    /// <li> <p>RETIRING - The underlying hardware for the asset is degraded. Capacity for new compute resources is reduced. Amazon Web Services sends notifications for resources that must be stopped before the asset can be replaced.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub state: std::option::Option<crate::model::ComputeAssetState>,
}
impl ComputeAttributes {
    /// <p> The host ID of the Dedicated Host on the asset. </p>
    pub fn host_id(&self) -> std::option::Option<&str> {
        self.host_id.as_deref()
    }
    /// <p>The state.</p>
    /// <ul>
    /// <li> <p>ACTIVE - The asset is available and can provide capacity for new compute resources.</p> </li>
    /// <li> <p>ISOLATED - The asset is undergoing maintenance and can't provide capacity for new compute resources. Existing compute resources on the asset are not affected.</p> </li>
    /// <li> <p>RETIRING - The underlying hardware for the asset is degraded. Capacity for new compute resources is reduced. Amazon Web Services sends notifications for resources that must be stopped before the asset can be replaced.</p> </li>
    /// </ul>
    pub fn state(&self) -> std::option::Option<&crate::model::ComputeAssetState> {
        self.state.as_ref()
    }
}
impl ComputeAttributes {
    /// Creates a new builder-style object to manufacture [`ComputeAttributes`](crate::model::ComputeAttributes).
    pub fn builder() -> crate::model::compute_attributes::Builder {
        crate::model::compute_attributes::Builder::default()
    }
}

/// See [`ComputeAttributes`](crate::model::ComputeAttributes).
pub mod compute_attributes {

    /// A builder for [`ComputeAttributes`](crate::model::ComputeAttributes).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) host_id: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::ComputeAssetState>,
    }
    impl Builder {
        /// <p> The host ID of the Dedicated Host on the asset. </p>
        pub fn host_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.host_id = Some(input.into());
            self
        }
        /// <p> The host ID of the Dedicated Host on the asset. </p>
        pub fn set_host_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.host_id = input;
            self
        }
        /// <p>The state.</p>
        /// <ul>
        /// <li> <p>ACTIVE - The asset is available and can provide capacity for new compute resources.</p> </li>
        /// <li> <p>ISOLATED - The asset is undergoing maintenance and can't provide capacity for new compute resources. Existing compute resources on the asset are not affected.</p> </li>
        /// <li> <p>RETIRING - The underlying hardware for the asset is degraded. Capacity for new compute resources is reduced. Amazon Web Services sends notifications for resources that must be stopped before the asset can be replaced.</p> </li>
        /// </ul>
        pub fn state(mut self, input: crate::model::ComputeAssetState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The state.</p>
        /// <ul>
        /// <li> <p>ACTIVE - The asset is available and can provide capacity for new compute resources.</p> </li>
        /// <li> <p>ISOLATED - The asset is undergoing maintenance and can't provide capacity for new compute resources. Existing compute resources on the asset are not affected.</p> </li>
        /// <li> <p>RETIRING - The underlying hardware for the asset is degraded. Capacity for new compute resources is reduced. Amazon Web Services sends notifications for resources that must be stopped before the asset can be replaced.</p> </li>
        /// </ul>
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::ComputeAssetState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// Consumes the builder and constructs a [`ComputeAttributes`](crate::model::ComputeAttributes).
        pub fn build(self) -> crate::model::ComputeAttributes {
            crate::model::ComputeAttributes {
                host_id: self.host_id,
                state: self.state,
            }
        }
    }
}

/// When writing a match expression against `ComputeAssetState`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let computeassetstate = unimplemented!();
/// match computeassetstate {
///     ComputeAssetState::Active => { /* ... */ },
///     ComputeAssetState::Isolated => { /* ... */ },
///     ComputeAssetState::Retiring => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `computeassetstate` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ComputeAssetState::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ComputeAssetState::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ComputeAssetState::NewFeature` is defined.
/// Specifically, when `computeassetstate` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ComputeAssetState::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ComputeAssetState {
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    Isolated,
    #[allow(missing_docs)] // documentation missing in model
    Retiring,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ComputeAssetState {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE" => ComputeAssetState::Active,
            "ISOLATED" => ComputeAssetState::Isolated,
            "RETIRING" => ComputeAssetState::Retiring,
            other => {
                ComputeAssetState::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for ComputeAssetState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ComputeAssetState::from(s))
    }
}
impl ComputeAssetState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ComputeAssetState::Active => "ACTIVE",
            ComputeAssetState::Isolated => "ISOLATED",
            ComputeAssetState::Retiring => "RETIRING",
            ComputeAssetState::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ACTIVE", "ISOLATED", "RETIRING"]
    }
}
impl AsRef<str> for ComputeAssetState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `AssetType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let assettype = unimplemented!();
/// match assettype {
///     AssetType::Compute => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `assettype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `AssetType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `AssetType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `AssetType::NewFeature` is defined.
/// Specifically, when `assettype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `AssetType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AssetType {
    #[allow(missing_docs)] // documentation missing in model
    Compute,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for AssetType {
    fn from(s: &str) -> Self {
        match s {
            "COMPUTE" => AssetType::Compute,
            other => AssetType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for AssetType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AssetType::from(s))
    }
}
impl AssetType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AssetType::Compute => "COMPUTE",
            AssetType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["COMPUTE"]
    }
}
impl AsRef<str> for AssetType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `AssetState`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let assetstate = unimplemented!();
/// match assetstate {
///     AssetState::Active => { /* ... */ },
///     AssetState::Retiring => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `assetstate` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `AssetState::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `AssetState::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `AssetState::NewFeature` is defined.
/// Specifically, when `assetstate` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `AssetState::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AssetState {
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    Retiring,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for AssetState {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE" => AssetState::Active,
            "RETIRING" => AssetState::Retiring,
            other => AssetState::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for AssetState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AssetState::from(s))
    }
}
impl AssetState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AssetState::Active => "ACTIVE",
            AssetState::Retiring => "RETIRING",
            AssetState::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ACTIVE", "RETIRING"]
    }
}
impl AsRef<str> for AssetState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information about an instance type.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InstanceTypeItem {
    /// <p>The instance type.</p>
    #[doc(hidden)]
    pub instance_type: std::option::Option<std::string::String>,
}
impl InstanceTypeItem {
    /// <p>The instance type.</p>
    pub fn instance_type(&self) -> std::option::Option<&str> {
        self.instance_type.as_deref()
    }
}
impl InstanceTypeItem {
    /// Creates a new builder-style object to manufacture [`InstanceTypeItem`](crate::model::InstanceTypeItem).
    pub fn builder() -> crate::model::instance_type_item::Builder {
        crate::model::instance_type_item::Builder::default()
    }
}

/// See [`InstanceTypeItem`](crate::model::InstanceTypeItem).
pub mod instance_type_item {

    /// A builder for [`InstanceTypeItem`](crate::model::InstanceTypeItem).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_type: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The instance type.</p>
        pub fn instance_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_type = Some(input.into());
            self
        }
        /// <p>The instance type.</p>
        pub fn set_instance_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.instance_type = input;
            self
        }
        /// Consumes the builder and constructs a [`InstanceTypeItem`](crate::model::InstanceTypeItem).
        pub fn build(self) -> crate::model::InstanceTypeItem {
            crate::model::InstanceTypeItem {
                instance_type: self.instance_type,
            }
        }
    }
}

/// <p>Information about an order.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Order {
    /// <p> The ID of the Outpost in the order. </p>
    #[doc(hidden)]
    pub outpost_id: std::option::Option<std::string::String>,
    /// <p>The ID of the order.</p>
    #[doc(hidden)]
    pub order_id: std::option::Option<std::string::String>,
    /// <p>The status of the order.</p>
    /// <ul>
    /// <li> <p> <code>PREPARING</code> - Order is received and being prepared.</p> </li>
    /// <li> <p> <code>IN_PROGRESS</code> - Order is either being built, shipped, or installed. To get more details, see the line item status.</p> </li>
    /// <li> <p> <code>COMPLETED</code> - Order is complete.</p> </li>
    /// <li> <p> <code>CANCELLED</code> - Order is cancelled.</p> </li>
    /// <li> <p> <code>ERROR</code> - Customer should contact support.</p> </li>
    /// </ul> <note>
    /// <p>The following status are deprecated: <code>RECEIVED</code>, <code>PENDING</code>, <code>PROCESSING</code>, <code>INSTALLING</code>, and <code>FULFILLED</code>. </p>
    /// </note>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::OrderStatus>,
    /// <p>The line items for the order</p>
    #[doc(hidden)]
    pub line_items: std::option::Option<std::vec::Vec<crate::model::LineItem>>,
    /// <p>The payment option for the order.</p>
    #[doc(hidden)]
    pub payment_option: std::option::Option<crate::model::PaymentOption>,
    /// <p>The submission date for the order.</p>
    #[doc(hidden)]
    pub order_submission_date: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The fulfillment date of the order.</p>
    #[doc(hidden)]
    pub order_fulfilled_date: std::option::Option<aws_smithy_types::DateTime>,
}
impl Order {
    /// <p> The ID of the Outpost in the order. </p>
    pub fn outpost_id(&self) -> std::option::Option<&str> {
        self.outpost_id.as_deref()
    }
    /// <p>The ID of the order.</p>
    pub fn order_id(&self) -> std::option::Option<&str> {
        self.order_id.as_deref()
    }
    /// <p>The status of the order.</p>
    /// <ul>
    /// <li> <p> <code>PREPARING</code> - Order is received and being prepared.</p> </li>
    /// <li> <p> <code>IN_PROGRESS</code> - Order is either being built, shipped, or installed. To get more details, see the line item status.</p> </li>
    /// <li> <p> <code>COMPLETED</code> - Order is complete.</p> </li>
    /// <li> <p> <code>CANCELLED</code> - Order is cancelled.</p> </li>
    /// <li> <p> <code>ERROR</code> - Customer should contact support.</p> </li>
    /// </ul> <note>
    /// <p>The following status are deprecated: <code>RECEIVED</code>, <code>PENDING</code>, <code>PROCESSING</code>, <code>INSTALLING</code>, and <code>FULFILLED</code>. </p>
    /// </note>
    pub fn status(&self) -> std::option::Option<&crate::model::OrderStatus> {
        self.status.as_ref()
    }
    /// <p>The line items for the order</p>
    pub fn line_items(&self) -> std::option::Option<&[crate::model::LineItem]> {
        self.line_items.as_deref()
    }
    /// <p>The payment option for the order.</p>
    pub fn payment_option(&self) -> std::option::Option<&crate::model::PaymentOption> {
        self.payment_option.as_ref()
    }
    /// <p>The submission date for the order.</p>
    pub fn order_submission_date(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.order_submission_date.as_ref()
    }
    /// <p>The fulfillment date of the order.</p>
    pub fn order_fulfilled_date(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.order_fulfilled_date.as_ref()
    }
}
impl Order {
    /// Creates a new builder-style object to manufacture [`Order`](crate::model::Order).
    pub fn builder() -> crate::model::order::Builder {
        crate::model::order::Builder::default()
    }
}

/// See [`Order`](crate::model::Order).
pub mod order {

    /// A builder for [`Order`](crate::model::Order).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) outpost_id: std::option::Option<std::string::String>,
        pub(crate) order_id: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::OrderStatus>,
        pub(crate) line_items: std::option::Option<std::vec::Vec<crate::model::LineItem>>,
        pub(crate) payment_option: std::option::Option<crate::model::PaymentOption>,
        pub(crate) order_submission_date: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) order_fulfilled_date: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p> The ID of the Outpost in the order. </p>
        pub fn outpost_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.outpost_id = Some(input.into());
            self
        }
        /// <p> The ID of the Outpost in the order. </p>
        pub fn set_outpost_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.outpost_id = input;
            self
        }
        /// <p>The ID of the order.</p>
        pub fn order_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.order_id = Some(input.into());
            self
        }
        /// <p>The ID of the order.</p>
        pub fn set_order_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.order_id = input;
            self
        }
        /// <p>The status of the order.</p>
        /// <ul>
        /// <li> <p> <code>PREPARING</code> - Order is received and being prepared.</p> </li>
        /// <li> <p> <code>IN_PROGRESS</code> - Order is either being built, shipped, or installed. To get more details, see the line item status.</p> </li>
        /// <li> <p> <code>COMPLETED</code> - Order is complete.</p> </li>
        /// <li> <p> <code>CANCELLED</code> - Order is cancelled.</p> </li>
        /// <li> <p> <code>ERROR</code> - Customer should contact support.</p> </li>
        /// </ul> <note>
        /// <p>The following status are deprecated: <code>RECEIVED</code>, <code>PENDING</code>, <code>PROCESSING</code>, <code>INSTALLING</code>, and <code>FULFILLED</code>. </p>
        /// </note>
        pub fn status(mut self, input: crate::model::OrderStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the order.</p>
        /// <ul>
        /// <li> <p> <code>PREPARING</code> - Order is received and being prepared.</p> </li>
        /// <li> <p> <code>IN_PROGRESS</code> - Order is either being built, shipped, or installed. To get more details, see the line item status.</p> </li>
        /// <li> <p> <code>COMPLETED</code> - Order is complete.</p> </li>
        /// <li> <p> <code>CANCELLED</code> - Order is cancelled.</p> </li>
        /// <li> <p> <code>ERROR</code> - Customer should contact support.</p> </li>
        /// </ul> <note>
        /// <p>The following status are deprecated: <code>RECEIVED</code>, <code>PENDING</code>, <code>PROCESSING</code>, <code>INSTALLING</code>, and <code>FULFILLED</code>. </p>
        /// </note>
        pub fn set_status(mut self, input: std::option::Option<crate::model::OrderStatus>) -> Self {
            self.status = input;
            self
        }
        /// Appends an item to `line_items`.
        ///
        /// To override the contents of this collection use [`set_line_items`](Self::set_line_items).
        ///
        /// <p>The line items for the order</p>
        pub fn line_items(mut self, input: crate::model::LineItem) -> Self {
            let mut v = self.line_items.unwrap_or_default();
            v.push(input);
            self.line_items = Some(v);
            self
        }
        /// <p>The line items for the order</p>
        pub fn set_line_items(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::LineItem>>,
        ) -> Self {
            self.line_items = input;
            self
        }
        /// <p>The payment option for the order.</p>
        pub fn payment_option(mut self, input: crate::model::PaymentOption) -> Self {
            self.payment_option = Some(input);
            self
        }
        /// <p>The payment option for the order.</p>
        pub fn set_payment_option(
            mut self,
            input: std::option::Option<crate::model::PaymentOption>,
        ) -> Self {
            self.payment_option = input;
            self
        }
        /// <p>The submission date for the order.</p>
        pub fn order_submission_date(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.order_submission_date = Some(input);
            self
        }
        /// <p>The submission date for the order.</p>
        pub fn set_order_submission_date(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.order_submission_date = input;
            self
        }
        /// <p>The fulfillment date of the order.</p>
        pub fn order_fulfilled_date(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.order_fulfilled_date = Some(input);
            self
        }
        /// <p>The fulfillment date of the order.</p>
        pub fn set_order_fulfilled_date(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.order_fulfilled_date = input;
            self
        }
        /// Consumes the builder and constructs a [`Order`](crate::model::Order).
        pub fn build(self) -> crate::model::Order {
            crate::model::Order {
                outpost_id: self.outpost_id,
                order_id: self.order_id,
                status: self.status,
                line_items: self.line_items,
                payment_option: self.payment_option,
                order_submission_date: self.order_submission_date,
                order_fulfilled_date: self.order_fulfilled_date,
            }
        }
    }
}

/// When writing a match expression against `PaymentOption`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let paymentoption = unimplemented!();
/// match paymentoption {
///     PaymentOption::AllUpfront => { /* ... */ },
///     PaymentOption::NoUpfront => { /* ... */ },
///     PaymentOption::PartialUpfront => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `paymentoption` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `PaymentOption::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `PaymentOption::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `PaymentOption::NewFeature` is defined.
/// Specifically, when `paymentoption` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `PaymentOption::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PaymentOption {
    #[allow(missing_docs)] // documentation missing in model
    AllUpfront,
    #[allow(missing_docs)] // documentation missing in model
    NoUpfront,
    #[allow(missing_docs)] // documentation missing in model
    PartialUpfront,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for PaymentOption {
    fn from(s: &str) -> Self {
        match s {
            "ALL_UPFRONT" => PaymentOption::AllUpfront,
            "NO_UPFRONT" => PaymentOption::NoUpfront,
            "PARTIAL_UPFRONT" => PaymentOption::PartialUpfront,
            other => PaymentOption::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for PaymentOption {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PaymentOption::from(s))
    }
}
impl PaymentOption {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            PaymentOption::AllUpfront => "ALL_UPFRONT",
            PaymentOption::NoUpfront => "NO_UPFRONT",
            PaymentOption::PartialUpfront => "PARTIAL_UPFRONT",
            PaymentOption::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ALL_UPFRONT", "NO_UPFRONT", "PARTIAL_UPFRONT"]
    }
}
impl AsRef<str> for PaymentOption {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information about a line item.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LineItem {
    /// <p> The ID of the catalog item. </p>
    #[doc(hidden)]
    pub catalog_item_id: std::option::Option<std::string::String>,
    /// <p>The ID of the line item.</p>
    #[doc(hidden)]
    pub line_item_id: std::option::Option<std::string::String>,
    /// <p>The quantity of the line item.</p>
    #[doc(hidden)]
    pub quantity: i32,
    /// <p>The status of the line item.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::LineItemStatus>,
    /// <p> Information about a line item shipment. </p>
    #[doc(hidden)]
    pub shipment_information: std::option::Option<crate::model::ShipmentInformation>,
    /// <p> Information about assets. </p>
    #[doc(hidden)]
    pub asset_information_list:
        std::option::Option<std::vec::Vec<crate::model::LineItemAssetInformation>>,
}
impl LineItem {
    /// <p> The ID of the catalog item. </p>
    pub fn catalog_item_id(&self) -> std::option::Option<&str> {
        self.catalog_item_id.as_deref()
    }
    /// <p>The ID of the line item.</p>
    pub fn line_item_id(&self) -> std::option::Option<&str> {
        self.line_item_id.as_deref()
    }
    /// <p>The quantity of the line item.</p>
    pub fn quantity(&self) -> i32 {
        self.quantity
    }
    /// <p>The status of the line item.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::LineItemStatus> {
        self.status.as_ref()
    }
    /// <p> Information about a line item shipment. </p>
    pub fn shipment_information(&self) -> std::option::Option<&crate::model::ShipmentInformation> {
        self.shipment_information.as_ref()
    }
    /// <p> Information about assets. </p>
    pub fn asset_information_list(
        &self,
    ) -> std::option::Option<&[crate::model::LineItemAssetInformation]> {
        self.asset_information_list.as_deref()
    }
}
impl LineItem {
    /// Creates a new builder-style object to manufacture [`LineItem`](crate::model::LineItem).
    pub fn builder() -> crate::model::line_item::Builder {
        crate::model::line_item::Builder::default()
    }
}

/// See [`LineItem`](crate::model::LineItem).
pub mod line_item {

    /// A builder for [`LineItem`](crate::model::LineItem).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) catalog_item_id: std::option::Option<std::string::String>,
        pub(crate) line_item_id: std::option::Option<std::string::String>,
        pub(crate) quantity: std::option::Option<i32>,
        pub(crate) status: std::option::Option<crate::model::LineItemStatus>,
        pub(crate) shipment_information: std::option::Option<crate::model::ShipmentInformation>,
        pub(crate) asset_information_list:
            std::option::Option<std::vec::Vec<crate::model::LineItemAssetInformation>>,
    }
    impl Builder {
        /// <p> The ID of the catalog item. </p>
        pub fn catalog_item_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.catalog_item_id = Some(input.into());
            self
        }
        /// <p> The ID of the catalog item. </p>
        pub fn set_catalog_item_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.catalog_item_id = input;
            self
        }
        /// <p>The ID of the line item.</p>
        pub fn line_item_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.line_item_id = Some(input.into());
            self
        }
        /// <p>The ID of the line item.</p>
        pub fn set_line_item_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.line_item_id = input;
            self
        }
        /// <p>The quantity of the line item.</p>
        pub fn quantity(mut self, input: i32) -> Self {
            self.quantity = Some(input);
            self
        }
        /// <p>The quantity of the line item.</p>
        pub fn set_quantity(mut self, input: std::option::Option<i32>) -> Self {
            self.quantity = input;
            self
        }
        /// <p>The status of the line item.</p>
        pub fn status(mut self, input: crate::model::LineItemStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the line item.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::LineItemStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p> Information about a line item shipment. </p>
        pub fn shipment_information(mut self, input: crate::model::ShipmentInformation) -> Self {
            self.shipment_information = Some(input);
            self
        }
        /// <p> Information about a line item shipment. </p>
        pub fn set_shipment_information(
            mut self,
            input: std::option::Option<crate::model::ShipmentInformation>,
        ) -> Self {
            self.shipment_information = input;
            self
        }
        /// Appends an item to `asset_information_list`.
        ///
        /// To override the contents of this collection use [`set_asset_information_list`](Self::set_asset_information_list).
        ///
        /// <p> Information about assets. </p>
        pub fn asset_information_list(
            mut self,
            input: crate::model::LineItemAssetInformation,
        ) -> Self {
            let mut v = self.asset_information_list.unwrap_or_default();
            v.push(input);
            self.asset_information_list = Some(v);
            self
        }
        /// <p> Information about assets. </p>
        pub fn set_asset_information_list(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::LineItemAssetInformation>>,
        ) -> Self {
            self.asset_information_list = input;
            self
        }
        /// Consumes the builder and constructs a [`LineItem`](crate::model::LineItem).
        pub fn build(self) -> crate::model::LineItem {
            crate::model::LineItem {
                catalog_item_id: self.catalog_item_id,
                line_item_id: self.line_item_id,
                quantity: self.quantity.unwrap_or_default(),
                status: self.status,
                shipment_information: self.shipment_information,
                asset_information_list: self.asset_information_list,
            }
        }
    }
}

/// <p> Information about a line item asset. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LineItemAssetInformation {
    /// <p> The ID of the asset. </p>
    #[doc(hidden)]
    pub asset_id: std::option::Option<std::string::String>,
    /// <p> The MAC addresses of the asset. </p>
    #[doc(hidden)]
    pub mac_address_list: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl LineItemAssetInformation {
    /// <p> The ID of the asset. </p>
    pub fn asset_id(&self) -> std::option::Option<&str> {
        self.asset_id.as_deref()
    }
    /// <p> The MAC addresses of the asset. </p>
    pub fn mac_address_list(&self) -> std::option::Option<&[std::string::String]> {
        self.mac_address_list.as_deref()
    }
}
impl LineItemAssetInformation {
    /// Creates a new builder-style object to manufacture [`LineItemAssetInformation`](crate::model::LineItemAssetInformation).
    pub fn builder() -> crate::model::line_item_asset_information::Builder {
        crate::model::line_item_asset_information::Builder::default()
    }
}

/// See [`LineItemAssetInformation`](crate::model::LineItemAssetInformation).
pub mod line_item_asset_information {

    /// A builder for [`LineItemAssetInformation`](crate::model::LineItemAssetInformation).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) asset_id: std::option::Option<std::string::String>,
        pub(crate) mac_address_list: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p> The ID of the asset. </p>
        pub fn asset_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.asset_id = Some(input.into());
            self
        }
        /// <p> The ID of the asset. </p>
        pub fn set_asset_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.asset_id = input;
            self
        }
        /// Appends an item to `mac_address_list`.
        ///
        /// To override the contents of this collection use [`set_mac_address_list`](Self::set_mac_address_list).
        ///
        /// <p> The MAC addresses of the asset. </p>
        pub fn mac_address_list(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.mac_address_list.unwrap_or_default();
            v.push(input.into());
            self.mac_address_list = Some(v);
            self
        }
        /// <p> The MAC addresses of the asset. </p>
        pub fn set_mac_address_list(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.mac_address_list = input;
            self
        }
        /// Consumes the builder and constructs a [`LineItemAssetInformation`](crate::model::LineItemAssetInformation).
        pub fn build(self) -> crate::model::LineItemAssetInformation {
            crate::model::LineItemAssetInformation {
                asset_id: self.asset_id,
                mac_address_list: self.mac_address_list,
            }
        }
    }
}

/// <p> Information about a line item shipment. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ShipmentInformation {
    /// <p> The tracking number of the shipment. </p>
    #[doc(hidden)]
    pub shipment_tracking_number: std::option::Option<std::string::String>,
    /// <p> The carrier of the shipment. </p>
    #[doc(hidden)]
    pub shipment_carrier: std::option::Option<crate::model::ShipmentCarrier>,
}
impl ShipmentInformation {
    /// <p> The tracking number of the shipment. </p>
    pub fn shipment_tracking_number(&self) -> std::option::Option<&str> {
        self.shipment_tracking_number.as_deref()
    }
    /// <p> The carrier of the shipment. </p>
    pub fn shipment_carrier(&self) -> std::option::Option<&crate::model::ShipmentCarrier> {
        self.shipment_carrier.as_ref()
    }
}
impl ShipmentInformation {
    /// Creates a new builder-style object to manufacture [`ShipmentInformation`](crate::model::ShipmentInformation).
    pub fn builder() -> crate::model::shipment_information::Builder {
        crate::model::shipment_information::Builder::default()
    }
}

/// See [`ShipmentInformation`](crate::model::ShipmentInformation).
pub mod shipment_information {

    /// A builder for [`ShipmentInformation`](crate::model::ShipmentInformation).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) shipment_tracking_number: std::option::Option<std::string::String>,
        pub(crate) shipment_carrier: std::option::Option<crate::model::ShipmentCarrier>,
    }
    impl Builder {
        /// <p> The tracking number of the shipment. </p>
        pub fn shipment_tracking_number(mut self, input: impl Into<std::string::String>) -> Self {
            self.shipment_tracking_number = Some(input.into());
            self
        }
        /// <p> The tracking number of the shipment. </p>
        pub fn set_shipment_tracking_number(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.shipment_tracking_number = input;
            self
        }
        /// <p> The carrier of the shipment. </p>
        pub fn shipment_carrier(mut self, input: crate::model::ShipmentCarrier) -> Self {
            self.shipment_carrier = Some(input);
            self
        }
        /// <p> The carrier of the shipment. </p>
        pub fn set_shipment_carrier(
            mut self,
            input: std::option::Option<crate::model::ShipmentCarrier>,
        ) -> Self {
            self.shipment_carrier = input;
            self
        }
        /// Consumes the builder and constructs a [`ShipmentInformation`](crate::model::ShipmentInformation).
        pub fn build(self) -> crate::model::ShipmentInformation {
            crate::model::ShipmentInformation {
                shipment_tracking_number: self.shipment_tracking_number,
                shipment_carrier: self.shipment_carrier,
            }
        }
    }
}

/// When writing a match expression against `ShipmentCarrier`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let shipmentcarrier = unimplemented!();
/// match shipmentcarrier {
///     ShipmentCarrier::Dbs => { /* ... */ },
///     ShipmentCarrier::Dhl => { /* ... */ },
///     ShipmentCarrier::Fedex => { /* ... */ },
///     ShipmentCarrier::Ups => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `shipmentcarrier` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ShipmentCarrier::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ShipmentCarrier::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ShipmentCarrier::NewFeature` is defined.
/// Specifically, when `shipmentcarrier` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ShipmentCarrier::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ShipmentCarrier {
    #[allow(missing_docs)] // documentation missing in model
    Dbs,
    #[allow(missing_docs)] // documentation missing in model
    Dhl,
    #[allow(missing_docs)] // documentation missing in model
    Fedex,
    #[allow(missing_docs)] // documentation missing in model
    Ups,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ShipmentCarrier {
    fn from(s: &str) -> Self {
        match s {
            "DBS" => ShipmentCarrier::Dbs,
            "DHL" => ShipmentCarrier::Dhl,
            "FEDEX" => ShipmentCarrier::Fedex,
            "UPS" => ShipmentCarrier::Ups,
            other => ShipmentCarrier::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ShipmentCarrier {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ShipmentCarrier::from(s))
    }
}
impl ShipmentCarrier {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ShipmentCarrier::Dbs => "DBS",
            ShipmentCarrier::Dhl => "DHL",
            ShipmentCarrier::Fedex => "FEDEX",
            ShipmentCarrier::Ups => "UPS",
            ShipmentCarrier::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["DBS", "DHL", "FEDEX", "UPS"]
    }
}
impl AsRef<str> for ShipmentCarrier {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p> Information about a connection. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ConnectionDetails {
    /// <p> The public key of the client. </p>
    #[doc(hidden)]
    pub client_public_key: std::option::Option<std::string::String>,
    /// <p> The public key of the server. </p>
    #[doc(hidden)]
    pub server_public_key: std::option::Option<std::string::String>,
    /// <p> The endpoint for the server. </p>
    #[doc(hidden)]
    pub server_endpoint: std::option::Option<std::string::String>,
    /// <p> The client tunnel address. </p>
    #[doc(hidden)]
    pub client_tunnel_address: std::option::Option<std::string::String>,
    /// <p> The server tunnel address. </p>
    #[doc(hidden)]
    pub server_tunnel_address: std::option::Option<std::string::String>,
    /// <p> The allowed IP addresses. </p>
    #[doc(hidden)]
    pub allowed_ips: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl ConnectionDetails {
    /// <p> The public key of the client. </p>
    pub fn client_public_key(&self) -> std::option::Option<&str> {
        self.client_public_key.as_deref()
    }
    /// <p> The public key of the server. </p>
    pub fn server_public_key(&self) -> std::option::Option<&str> {
        self.server_public_key.as_deref()
    }
    /// <p> The endpoint for the server. </p>
    pub fn server_endpoint(&self) -> std::option::Option<&str> {
        self.server_endpoint.as_deref()
    }
    /// <p> The client tunnel address. </p>
    pub fn client_tunnel_address(&self) -> std::option::Option<&str> {
        self.client_tunnel_address.as_deref()
    }
    /// <p> The server tunnel address. </p>
    pub fn server_tunnel_address(&self) -> std::option::Option<&str> {
        self.server_tunnel_address.as_deref()
    }
    /// <p> The allowed IP addresses. </p>
    pub fn allowed_ips(&self) -> std::option::Option<&[std::string::String]> {
        self.allowed_ips.as_deref()
    }
}
impl ConnectionDetails {
    /// Creates a new builder-style object to manufacture [`ConnectionDetails`](crate::model::ConnectionDetails).
    pub fn builder() -> crate::model::connection_details::Builder {
        crate::model::connection_details::Builder::default()
    }
}

/// See [`ConnectionDetails`](crate::model::ConnectionDetails).
pub mod connection_details {

    /// A builder for [`ConnectionDetails`](crate::model::ConnectionDetails).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) client_public_key: std::option::Option<std::string::String>,
        pub(crate) server_public_key: std::option::Option<std::string::String>,
        pub(crate) server_endpoint: std::option::Option<std::string::String>,
        pub(crate) client_tunnel_address: std::option::Option<std::string::String>,
        pub(crate) server_tunnel_address: std::option::Option<std::string::String>,
        pub(crate) allowed_ips: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p> The public key of the client. </p>
        pub fn client_public_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_public_key = Some(input.into());
            self
        }
        /// <p> The public key of the client. </p>
        pub fn set_client_public_key(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.client_public_key = input;
            self
        }
        /// <p> The public key of the server. </p>
        pub fn server_public_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.server_public_key = Some(input.into());
            self
        }
        /// <p> The public key of the server. </p>
        pub fn set_server_public_key(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.server_public_key = input;
            self
        }
        /// <p> The endpoint for the server. </p>
        pub fn server_endpoint(mut self, input: impl Into<std::string::String>) -> Self {
            self.server_endpoint = Some(input.into());
            self
        }
        /// <p> The endpoint for the server. </p>
        pub fn set_server_endpoint(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.server_endpoint = input;
            self
        }
        /// <p> The client tunnel address. </p>
        pub fn client_tunnel_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_tunnel_address = Some(input.into());
            self
        }
        /// <p> The client tunnel address. </p>
        pub fn set_client_tunnel_address(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.client_tunnel_address = input;
            self
        }
        /// <p> The server tunnel address. </p>
        pub fn server_tunnel_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.server_tunnel_address = Some(input.into());
            self
        }
        /// <p> The server tunnel address. </p>
        pub fn set_server_tunnel_address(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.server_tunnel_address = input;
            self
        }
        /// Appends an item to `allowed_ips`.
        ///
        /// To override the contents of this collection use [`set_allowed_ips`](Self::set_allowed_ips).
        ///
        /// <p> The allowed IP addresses. </p>
        pub fn allowed_ips(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.allowed_ips.unwrap_or_default();
            v.push(input.into());
            self.allowed_ips = Some(v);
            self
        }
        /// <p> The allowed IP addresses. </p>
        pub fn set_allowed_ips(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.allowed_ips = input;
            self
        }
        /// Consumes the builder and constructs a [`ConnectionDetails`](crate::model::ConnectionDetails).
        pub fn build(self) -> crate::model::ConnectionDetails {
            crate::model::ConnectionDetails {
                client_public_key: self.client_public_key,
                server_public_key: self.server_public_key,
                server_endpoint: self.server_endpoint,
                client_tunnel_address: self.client_tunnel_address,
                server_tunnel_address: self.server_tunnel_address,
                allowed_ips: self.allowed_ips,
            }
        }
    }
}

/// When writing a match expression against `PaymentTerm`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let paymentterm = unimplemented!();
/// match paymentterm {
///     PaymentTerm::OneYear => { /* ... */ },
///     PaymentTerm::ThreeYears => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `paymentterm` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `PaymentTerm::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `PaymentTerm::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `PaymentTerm::NewFeature` is defined.
/// Specifically, when `paymentterm` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `PaymentTerm::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PaymentTerm {
    #[allow(missing_docs)] // documentation missing in model
    OneYear,
    #[allow(missing_docs)] // documentation missing in model
    ThreeYears,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for PaymentTerm {
    fn from(s: &str) -> Self {
        match s {
            "ONE_YEAR" => PaymentTerm::OneYear,
            "THREE_YEARS" => PaymentTerm::ThreeYears,
            other => PaymentTerm::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for PaymentTerm {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PaymentTerm::from(s))
    }
}
impl PaymentTerm {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            PaymentTerm::OneYear => "ONE_YEAR",
            PaymentTerm::ThreeYears => "THREE_YEARS",
            PaymentTerm::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ONE_YEAR", "THREE_YEARS"]
    }
}
impl AsRef<str> for PaymentTerm {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information about a line item request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LineItemRequest {
    /// <p>The ID of the catalog item.</p>
    #[doc(hidden)]
    pub catalog_item_id: std::option::Option<std::string::String>,
    /// <p>The quantity of a line item request.</p>
    #[doc(hidden)]
    pub quantity: i32,
}
impl LineItemRequest {
    /// <p>The ID of the catalog item.</p>
    pub fn catalog_item_id(&self) -> std::option::Option<&str> {
        self.catalog_item_id.as_deref()
    }
    /// <p>The quantity of a line item request.</p>
    pub fn quantity(&self) -> i32 {
        self.quantity
    }
}
impl LineItemRequest {
    /// Creates a new builder-style object to manufacture [`LineItemRequest`](crate::model::LineItemRequest).
    pub fn builder() -> crate::model::line_item_request::Builder {
        crate::model::line_item_request::Builder::default()
    }
}

/// See [`LineItemRequest`](crate::model::LineItemRequest).
pub mod line_item_request {

    /// A builder for [`LineItemRequest`](crate::model::LineItemRequest).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) catalog_item_id: std::option::Option<std::string::String>,
        pub(crate) quantity: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The ID of the catalog item.</p>
        pub fn catalog_item_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.catalog_item_id = Some(input.into());
            self
        }
        /// <p>The ID of the catalog item.</p>
        pub fn set_catalog_item_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.catalog_item_id = input;
            self
        }
        /// <p>The quantity of a line item request.</p>
        pub fn quantity(mut self, input: i32) -> Self {
            self.quantity = Some(input);
            self
        }
        /// <p>The quantity of a line item request.</p>
        pub fn set_quantity(mut self, input: std::option::Option<i32>) -> Self {
            self.quantity = input;
            self
        }
        /// Consumes the builder and constructs a [`LineItemRequest`](crate::model::LineItemRequest).
        pub fn build(self) -> crate::model::LineItemRequest {
            crate::model::LineItemRequest {
                catalog_item_id: self.catalog_item_id,
                quantity: self.quantity.unwrap_or_default(),
            }
        }
    }
}
