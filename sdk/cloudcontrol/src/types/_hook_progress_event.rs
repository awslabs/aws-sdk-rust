// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Represents the current status of applicable Hooks for a resource operation request. It contains list of Hook invocation information for the resource specified in the request since the same target can invoke multiple Hooks. For more information, see <a href="https://docs.aws.amazon.com/cloudcontrolapi/latest/userguide/resource-operations-manage-requests.html">Managing resource operation requests with Amazon Web Services Cloud Control API </a>.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct HookProgressEvent {
    /// <p>The type name of the Hook being invoked.</p>
    pub hook_type_name: ::std::option::Option<::std::string::String>,
    /// <p>The type version of the Hook being invoked.</p>
    pub hook_type_version_id: ::std::option::Option<::std::string::String>,
    /// <p>The ARN of the Hook being invoked.</p>
    pub hook_type_arn: ::std::option::Option<::std::string::String>,
    /// <p>States whether the Hook is invoked before or after resource provisioning.</p>
    pub invocation_point: ::std::option::Option<::std::string::String>,
    /// <p>The status of the Hook invocation. The following are potential statuses:</p>
    /// <ul>
    /// <li>
    /// <p><code>HOOK_PENDING</code>: The Hook was added to the invocation plan, but not yet invoked.</p></li>
    /// <li>
    /// <p><code>HOOK_IN_PROGRESS</code>: The Hook was invoked, but hasn't completed.</p></li>
    /// <li>
    /// <p><code>HOOK_COMPLETE_SUCCEEDED</code>: The Hook invocation is complete with a successful result.</p></li>
    /// <li>
    /// <p><code>HOOK_COMPLETE_FAILED</code>: The Hook invocation is complete with a failed result.</p></li>
    /// <li>
    /// <p><code>HOOK_FAILED</code>: The Hook invocation didn't complete successfully.</p></li>
    /// </ul>
    pub hook_status: ::std::option::Option<::std::string::String>,
    /// <p>The time that the Hook invocation request initiated.</p>
    pub hook_event_time: ::std::option::Option<::aws_smithy_types::DateTime>,
    /// <p>The message explaining the current Hook status.</p>
    pub hook_status_message: ::std::option::Option<::std::string::String>,
    /// <p>The failure mode of the invocation. The following are the potential statuses:</p>
    /// <ul>
    /// <li>
    /// <p><code>FAIL</code>: This will fail the Hook invocation and the request associated with it.</p></li>
    /// <li>
    /// <p><code>WARN</code>: This will fail the Hook invocation, but not the request associated with it.</p></li>
    /// </ul>
    pub failure_mode: ::std::option::Option<::std::string::String>,
}
impl HookProgressEvent {
    /// <p>The type name of the Hook being invoked.</p>
    pub fn hook_type_name(&self) -> ::std::option::Option<&str> {
        self.hook_type_name.as_deref()
    }
    /// <p>The type version of the Hook being invoked.</p>
    pub fn hook_type_version_id(&self) -> ::std::option::Option<&str> {
        self.hook_type_version_id.as_deref()
    }
    /// <p>The ARN of the Hook being invoked.</p>
    pub fn hook_type_arn(&self) -> ::std::option::Option<&str> {
        self.hook_type_arn.as_deref()
    }
    /// <p>States whether the Hook is invoked before or after resource provisioning.</p>
    pub fn invocation_point(&self) -> ::std::option::Option<&str> {
        self.invocation_point.as_deref()
    }
    /// <p>The status of the Hook invocation. The following are potential statuses:</p>
    /// <ul>
    /// <li>
    /// <p><code>HOOK_PENDING</code>: The Hook was added to the invocation plan, but not yet invoked.</p></li>
    /// <li>
    /// <p><code>HOOK_IN_PROGRESS</code>: The Hook was invoked, but hasn't completed.</p></li>
    /// <li>
    /// <p><code>HOOK_COMPLETE_SUCCEEDED</code>: The Hook invocation is complete with a successful result.</p></li>
    /// <li>
    /// <p><code>HOOK_COMPLETE_FAILED</code>: The Hook invocation is complete with a failed result.</p></li>
    /// <li>
    /// <p><code>HOOK_FAILED</code>: The Hook invocation didn't complete successfully.</p></li>
    /// </ul>
    pub fn hook_status(&self) -> ::std::option::Option<&str> {
        self.hook_status.as_deref()
    }
    /// <p>The time that the Hook invocation request initiated.</p>
    pub fn hook_event_time(&self) -> ::std::option::Option<&::aws_smithy_types::DateTime> {
        self.hook_event_time.as_ref()
    }
    /// <p>The message explaining the current Hook status.</p>
    pub fn hook_status_message(&self) -> ::std::option::Option<&str> {
        self.hook_status_message.as_deref()
    }
    /// <p>The failure mode of the invocation. The following are the potential statuses:</p>
    /// <ul>
    /// <li>
    /// <p><code>FAIL</code>: This will fail the Hook invocation and the request associated with it.</p></li>
    /// <li>
    /// <p><code>WARN</code>: This will fail the Hook invocation, but not the request associated with it.</p></li>
    /// </ul>
    pub fn failure_mode(&self) -> ::std::option::Option<&str> {
        self.failure_mode.as_deref()
    }
}
impl HookProgressEvent {
    /// Creates a new builder-style object to manufacture [`HookProgressEvent`](crate::types::HookProgressEvent).
    pub fn builder() -> crate::types::builders::HookProgressEventBuilder {
        crate::types::builders::HookProgressEventBuilder::default()
    }
}

/// A builder for [`HookProgressEvent`](crate::types::HookProgressEvent).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
#[non_exhaustive]
pub struct HookProgressEventBuilder {
    pub(crate) hook_type_name: ::std::option::Option<::std::string::String>,
    pub(crate) hook_type_version_id: ::std::option::Option<::std::string::String>,
    pub(crate) hook_type_arn: ::std::option::Option<::std::string::String>,
    pub(crate) invocation_point: ::std::option::Option<::std::string::String>,
    pub(crate) hook_status: ::std::option::Option<::std::string::String>,
    pub(crate) hook_event_time: ::std::option::Option<::aws_smithy_types::DateTime>,
    pub(crate) hook_status_message: ::std::option::Option<::std::string::String>,
    pub(crate) failure_mode: ::std::option::Option<::std::string::String>,
}
impl HookProgressEventBuilder {
    /// <p>The type name of the Hook being invoked.</p>
    pub fn hook_type_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.hook_type_name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The type name of the Hook being invoked.</p>
    pub fn set_hook_type_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.hook_type_name = input;
        self
    }
    /// <p>The type name of the Hook being invoked.</p>
    pub fn get_hook_type_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.hook_type_name
    }
    /// <p>The type version of the Hook being invoked.</p>
    pub fn hook_type_version_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.hook_type_version_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The type version of the Hook being invoked.</p>
    pub fn set_hook_type_version_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.hook_type_version_id = input;
        self
    }
    /// <p>The type version of the Hook being invoked.</p>
    pub fn get_hook_type_version_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.hook_type_version_id
    }
    /// <p>The ARN of the Hook being invoked.</p>
    pub fn hook_type_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.hook_type_arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The ARN of the Hook being invoked.</p>
    pub fn set_hook_type_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.hook_type_arn = input;
        self
    }
    /// <p>The ARN of the Hook being invoked.</p>
    pub fn get_hook_type_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.hook_type_arn
    }
    /// <p>States whether the Hook is invoked before or after resource provisioning.</p>
    pub fn invocation_point(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.invocation_point = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>States whether the Hook is invoked before or after resource provisioning.</p>
    pub fn set_invocation_point(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.invocation_point = input;
        self
    }
    /// <p>States whether the Hook is invoked before or after resource provisioning.</p>
    pub fn get_invocation_point(&self) -> &::std::option::Option<::std::string::String> {
        &self.invocation_point
    }
    /// <p>The status of the Hook invocation. The following are potential statuses:</p>
    /// <ul>
    /// <li>
    /// <p><code>HOOK_PENDING</code>: The Hook was added to the invocation plan, but not yet invoked.</p></li>
    /// <li>
    /// <p><code>HOOK_IN_PROGRESS</code>: The Hook was invoked, but hasn't completed.</p></li>
    /// <li>
    /// <p><code>HOOK_COMPLETE_SUCCEEDED</code>: The Hook invocation is complete with a successful result.</p></li>
    /// <li>
    /// <p><code>HOOK_COMPLETE_FAILED</code>: The Hook invocation is complete with a failed result.</p></li>
    /// <li>
    /// <p><code>HOOK_FAILED</code>: The Hook invocation didn't complete successfully.</p></li>
    /// </ul>
    pub fn hook_status(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.hook_status = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The status of the Hook invocation. The following are potential statuses:</p>
    /// <ul>
    /// <li>
    /// <p><code>HOOK_PENDING</code>: The Hook was added to the invocation plan, but not yet invoked.</p></li>
    /// <li>
    /// <p><code>HOOK_IN_PROGRESS</code>: The Hook was invoked, but hasn't completed.</p></li>
    /// <li>
    /// <p><code>HOOK_COMPLETE_SUCCEEDED</code>: The Hook invocation is complete with a successful result.</p></li>
    /// <li>
    /// <p><code>HOOK_COMPLETE_FAILED</code>: The Hook invocation is complete with a failed result.</p></li>
    /// <li>
    /// <p><code>HOOK_FAILED</code>: The Hook invocation didn't complete successfully.</p></li>
    /// </ul>
    pub fn set_hook_status(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.hook_status = input;
        self
    }
    /// <p>The status of the Hook invocation. The following are potential statuses:</p>
    /// <ul>
    /// <li>
    /// <p><code>HOOK_PENDING</code>: The Hook was added to the invocation plan, but not yet invoked.</p></li>
    /// <li>
    /// <p><code>HOOK_IN_PROGRESS</code>: The Hook was invoked, but hasn't completed.</p></li>
    /// <li>
    /// <p><code>HOOK_COMPLETE_SUCCEEDED</code>: The Hook invocation is complete with a successful result.</p></li>
    /// <li>
    /// <p><code>HOOK_COMPLETE_FAILED</code>: The Hook invocation is complete with a failed result.</p></li>
    /// <li>
    /// <p><code>HOOK_FAILED</code>: The Hook invocation didn't complete successfully.</p></li>
    /// </ul>
    pub fn get_hook_status(&self) -> &::std::option::Option<::std::string::String> {
        &self.hook_status
    }
    /// <p>The time that the Hook invocation request initiated.</p>
    pub fn hook_event_time(mut self, input: ::aws_smithy_types::DateTime) -> Self {
        self.hook_event_time = ::std::option::Option::Some(input);
        self
    }
    /// <p>The time that the Hook invocation request initiated.</p>
    pub fn set_hook_event_time(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
        self.hook_event_time = input;
        self
    }
    /// <p>The time that the Hook invocation request initiated.</p>
    pub fn get_hook_event_time(&self) -> &::std::option::Option<::aws_smithy_types::DateTime> {
        &self.hook_event_time
    }
    /// <p>The message explaining the current Hook status.</p>
    pub fn hook_status_message(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.hook_status_message = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The message explaining the current Hook status.</p>
    pub fn set_hook_status_message(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.hook_status_message = input;
        self
    }
    /// <p>The message explaining the current Hook status.</p>
    pub fn get_hook_status_message(&self) -> &::std::option::Option<::std::string::String> {
        &self.hook_status_message
    }
    /// <p>The failure mode of the invocation. The following are the potential statuses:</p>
    /// <ul>
    /// <li>
    /// <p><code>FAIL</code>: This will fail the Hook invocation and the request associated with it.</p></li>
    /// <li>
    /// <p><code>WARN</code>: This will fail the Hook invocation, but not the request associated with it.</p></li>
    /// </ul>
    pub fn failure_mode(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.failure_mode = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The failure mode of the invocation. The following are the potential statuses:</p>
    /// <ul>
    /// <li>
    /// <p><code>FAIL</code>: This will fail the Hook invocation and the request associated with it.</p></li>
    /// <li>
    /// <p><code>WARN</code>: This will fail the Hook invocation, but not the request associated with it.</p></li>
    /// </ul>
    pub fn set_failure_mode(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.failure_mode = input;
        self
    }
    /// <p>The failure mode of the invocation. The following are the potential statuses:</p>
    /// <ul>
    /// <li>
    /// <p><code>FAIL</code>: This will fail the Hook invocation and the request associated with it.</p></li>
    /// <li>
    /// <p><code>WARN</code>: This will fail the Hook invocation, but not the request associated with it.</p></li>
    /// </ul>
    pub fn get_failure_mode(&self) -> &::std::option::Option<::std::string::String> {
        &self.failure_mode
    }
    /// Consumes the builder and constructs a [`HookProgressEvent`](crate::types::HookProgressEvent).
    pub fn build(self) -> crate::types::HookProgressEvent {
        crate::types::HookProgressEvent {
            hook_type_name: self.hook_type_name,
            hook_type_version_id: self.hook_type_version_id,
            hook_type_arn: self.hook_type_arn,
            invocation_point: self.invocation_point,
            hook_status: self.hook_status,
            hook_event_time: self.hook_event_time,
            hook_status_message: self.hook_status_message,
            failure_mode: self.failure_mode,
        }
    }
}
