// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>A safety rule. A safety rule can be an assertion rule or a gating rule.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Rule {
    /// <p>An assertion rule enforces that, when a routing control state is changed, the criteria set by the rule configuration is met. Otherwise, the change to the routing control state is not accepted. For example, the criteria might be that at least one routing control state is On after the transaction so that traffic continues to flow to at least one cell for the application. This ensures that you avoid a fail-open scenario.</p>
    #[doc(hidden)]
    pub assertion: std::option::Option<crate::types::AssertionRule>,
    /// <p>A gating rule verifies that a gating routing control or set of gating routing controls, evaluates as true, based on a rule configuration that you specify, which allows a set of routing control state changes to complete.</p>
    /// <p>For example, if you specify one gating routing control and you set the Type in the rule configuration to OR, that indicates that you must set the gating routing control to On for the rule to evaluate as true; that is, for the gating control "switch" to be "On". When you do that, then you can update the routing control states for the target routing controls that you specify in the gating rule.</p>
    #[doc(hidden)]
    pub gating: std::option::Option<crate::types::GatingRule>,
}
impl Rule {
    /// <p>An assertion rule enforces that, when a routing control state is changed, the criteria set by the rule configuration is met. Otherwise, the change to the routing control state is not accepted. For example, the criteria might be that at least one routing control state is On after the transaction so that traffic continues to flow to at least one cell for the application. This ensures that you avoid a fail-open scenario.</p>
    pub fn assertion(&self) -> std::option::Option<&crate::types::AssertionRule> {
        self.assertion.as_ref()
    }
    /// <p>A gating rule verifies that a gating routing control or set of gating routing controls, evaluates as true, based on a rule configuration that you specify, which allows a set of routing control state changes to complete.</p>
    /// <p>For example, if you specify one gating routing control and you set the Type in the rule configuration to OR, that indicates that you must set the gating routing control to On for the rule to evaluate as true; that is, for the gating control "switch" to be "On". When you do that, then you can update the routing control states for the target routing controls that you specify in the gating rule.</p>
    pub fn gating(&self) -> std::option::Option<&crate::types::GatingRule> {
        self.gating.as_ref()
    }
}
impl Rule {
    /// Creates a new builder-style object to manufacture [`Rule`](crate::types::Rule).
    pub fn builder() -> crate::types::builders::RuleBuilder {
        crate::types::builders::RuleBuilder::default()
    }
}

/// A builder for [`Rule`](crate::types::Rule).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
pub struct RuleBuilder {
    pub(crate) assertion: std::option::Option<crate::types::AssertionRule>,
    pub(crate) gating: std::option::Option<crate::types::GatingRule>,
}
impl RuleBuilder {
    /// <p>An assertion rule enforces that, when a routing control state is changed, the criteria set by the rule configuration is met. Otherwise, the change to the routing control state is not accepted. For example, the criteria might be that at least one routing control state is On after the transaction so that traffic continues to flow to at least one cell for the application. This ensures that you avoid a fail-open scenario.</p>
    pub fn assertion(mut self, input: crate::types::AssertionRule) -> Self {
        self.assertion = Some(input);
        self
    }
    /// <p>An assertion rule enforces that, when a routing control state is changed, the criteria set by the rule configuration is met. Otherwise, the change to the routing control state is not accepted. For example, the criteria might be that at least one routing control state is On after the transaction so that traffic continues to flow to at least one cell for the application. This ensures that you avoid a fail-open scenario.</p>
    pub fn set_assertion(
        mut self,
        input: std::option::Option<crate::types::AssertionRule>,
    ) -> Self {
        self.assertion = input;
        self
    }
    /// <p>A gating rule verifies that a gating routing control or set of gating routing controls, evaluates as true, based on a rule configuration that you specify, which allows a set of routing control state changes to complete.</p>
    /// <p>For example, if you specify one gating routing control and you set the Type in the rule configuration to OR, that indicates that you must set the gating routing control to On for the rule to evaluate as true; that is, for the gating control "switch" to be "On". When you do that, then you can update the routing control states for the target routing controls that you specify in the gating rule.</p>
    pub fn gating(mut self, input: crate::types::GatingRule) -> Self {
        self.gating = Some(input);
        self
    }
    /// <p>A gating rule verifies that a gating routing control or set of gating routing controls, evaluates as true, based on a rule configuration that you specify, which allows a set of routing control state changes to complete.</p>
    /// <p>For example, if you specify one gating routing control and you set the Type in the rule configuration to OR, that indicates that you must set the gating routing control to On for the rule to evaluate as true; that is, for the gating control "switch" to be "On". When you do that, then you can update the routing control states for the target routing controls that you specify in the gating rule.</p>
    pub fn set_gating(mut self, input: std::option::Option<crate::types::GatingRule>) -> Self {
        self.gating = input;
        self
    }
    /// Consumes the builder and constructs a [`Rule`](crate::types::Rule).
    pub fn build(self) -> crate::types::Rule {
        crate::types::Rule {
            assertion: self.assertion,
            gating: self.gating,
        }
    }
}
