// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateBackupPlanError {
    pub kind: CreateBackupPlanErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateBackupPlanErrorKind {
    AlreadyExistsException(crate::error::AlreadyExistsException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    LimitExceededException(crate::error::LimitExceededException),
    MissingParameterValueException(crate::error::MissingParameterValueException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateBackupPlanError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateBackupPlanErrorKind::AlreadyExistsException(_inner) => _inner.fmt(f),
            CreateBackupPlanErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            CreateBackupPlanErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateBackupPlanErrorKind::MissingParameterValueException(_inner) => _inner.fmt(f),
            CreateBackupPlanErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            CreateBackupPlanErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateBackupPlanError {
    fn code(&self) -> Option<&str> {
        CreateBackupPlanError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateBackupPlanError {
    pub fn new(kind: CreateBackupPlanErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateBackupPlanErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateBackupPlanErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateBackupPlanErrorKind::AlreadyExistsException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateBackupPlanErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateBackupPlanErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_missing_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateBackupPlanErrorKind::MissingParameterValueException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateBackupPlanErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for CreateBackupPlanError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateBackupPlanErrorKind::AlreadyExistsException(_inner) => Some(_inner),
            CreateBackupPlanErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            CreateBackupPlanErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateBackupPlanErrorKind::MissingParameterValueException(_inner) => Some(_inner),
            CreateBackupPlanErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            CreateBackupPlanErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateBackupSelectionError {
    pub kind: CreateBackupSelectionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateBackupSelectionErrorKind {
    AlreadyExistsException(crate::error::AlreadyExistsException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    LimitExceededException(crate::error::LimitExceededException),
    MissingParameterValueException(crate::error::MissingParameterValueException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateBackupSelectionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateBackupSelectionErrorKind::AlreadyExistsException(_inner) => _inner.fmt(f),
            CreateBackupSelectionErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            CreateBackupSelectionErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateBackupSelectionErrorKind::MissingParameterValueException(_inner) => _inner.fmt(f),
            CreateBackupSelectionErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            CreateBackupSelectionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateBackupSelectionError {
    fn code(&self) -> Option<&str> {
        CreateBackupSelectionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateBackupSelectionError {
    pub fn new(kind: CreateBackupSelectionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateBackupSelectionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateBackupSelectionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateBackupSelectionErrorKind::AlreadyExistsException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateBackupSelectionErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateBackupSelectionErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_missing_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateBackupSelectionErrorKind::MissingParameterValueException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateBackupSelectionErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for CreateBackupSelectionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateBackupSelectionErrorKind::AlreadyExistsException(_inner) => Some(_inner),
            CreateBackupSelectionErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            CreateBackupSelectionErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateBackupSelectionErrorKind::MissingParameterValueException(_inner) => Some(_inner),
            CreateBackupSelectionErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            CreateBackupSelectionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateBackupVaultError {
    pub kind: CreateBackupVaultErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateBackupVaultErrorKind {
    AlreadyExistsException(crate::error::AlreadyExistsException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    LimitExceededException(crate::error::LimitExceededException),
    MissingParameterValueException(crate::error::MissingParameterValueException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateBackupVaultError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateBackupVaultErrorKind::AlreadyExistsException(_inner) => _inner.fmt(f),
            CreateBackupVaultErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            CreateBackupVaultErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateBackupVaultErrorKind::MissingParameterValueException(_inner) => _inner.fmt(f),
            CreateBackupVaultErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            CreateBackupVaultErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateBackupVaultError {
    fn code(&self) -> Option<&str> {
        CreateBackupVaultError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateBackupVaultError {
    pub fn new(kind: CreateBackupVaultErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateBackupVaultErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateBackupVaultErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateBackupVaultErrorKind::AlreadyExistsException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateBackupVaultErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateBackupVaultErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_missing_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateBackupVaultErrorKind::MissingParameterValueException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateBackupVaultErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for CreateBackupVaultError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateBackupVaultErrorKind::AlreadyExistsException(_inner) => Some(_inner),
            CreateBackupVaultErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            CreateBackupVaultErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateBackupVaultErrorKind::MissingParameterValueException(_inner) => Some(_inner),
            CreateBackupVaultErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            CreateBackupVaultErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateFrameworkError {
    pub kind: CreateFrameworkErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateFrameworkErrorKind {
    AlreadyExistsException(crate::error::AlreadyExistsException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    LimitExceededException(crate::error::LimitExceededException),
    MissingParameterValueException(crate::error::MissingParameterValueException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateFrameworkError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateFrameworkErrorKind::AlreadyExistsException(_inner) => _inner.fmt(f),
            CreateFrameworkErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            CreateFrameworkErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateFrameworkErrorKind::MissingParameterValueException(_inner) => _inner.fmt(f),
            CreateFrameworkErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            CreateFrameworkErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateFrameworkError {
    fn code(&self) -> Option<&str> {
        CreateFrameworkError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateFrameworkError {
    pub fn new(kind: CreateFrameworkErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateFrameworkErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateFrameworkErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateFrameworkErrorKind::AlreadyExistsException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateFrameworkErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateFrameworkErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_missing_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateFrameworkErrorKind::MissingParameterValueException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateFrameworkErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for CreateFrameworkError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateFrameworkErrorKind::AlreadyExistsException(_inner) => Some(_inner),
            CreateFrameworkErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            CreateFrameworkErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateFrameworkErrorKind::MissingParameterValueException(_inner) => Some(_inner),
            CreateFrameworkErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            CreateFrameworkErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateReportPlanError {
    pub kind: CreateReportPlanErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateReportPlanErrorKind {
    AlreadyExistsException(crate::error::AlreadyExistsException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    LimitExceededException(crate::error::LimitExceededException),
    MissingParameterValueException(crate::error::MissingParameterValueException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateReportPlanError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateReportPlanErrorKind::AlreadyExistsException(_inner) => _inner.fmt(f),
            CreateReportPlanErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            CreateReportPlanErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateReportPlanErrorKind::MissingParameterValueException(_inner) => _inner.fmt(f),
            CreateReportPlanErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            CreateReportPlanErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateReportPlanError {
    fn code(&self) -> Option<&str> {
        CreateReportPlanError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateReportPlanError {
    pub fn new(kind: CreateReportPlanErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateReportPlanErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateReportPlanErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateReportPlanErrorKind::AlreadyExistsException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateReportPlanErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateReportPlanErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_missing_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateReportPlanErrorKind::MissingParameterValueException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateReportPlanErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for CreateReportPlanError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateReportPlanErrorKind::AlreadyExistsException(_inner) => Some(_inner),
            CreateReportPlanErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            CreateReportPlanErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateReportPlanErrorKind::MissingParameterValueException(_inner) => Some(_inner),
            CreateReportPlanErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            CreateReportPlanErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteBackupPlanError {
    pub kind: DeleteBackupPlanErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteBackupPlanErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    InvalidRequestException(crate::error::InvalidRequestException),
    MissingParameterValueException(crate::error::MissingParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteBackupPlanError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteBackupPlanErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            DeleteBackupPlanErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DeleteBackupPlanErrorKind::MissingParameterValueException(_inner) => _inner.fmt(f),
            DeleteBackupPlanErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteBackupPlanErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DeleteBackupPlanErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteBackupPlanError {
    fn code(&self) -> Option<&str> {
        DeleteBackupPlanError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteBackupPlanError {
    pub fn new(kind: DeleteBackupPlanErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteBackupPlanErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteBackupPlanErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteBackupPlanErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteBackupPlanErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_missing_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteBackupPlanErrorKind::MissingParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteBackupPlanErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteBackupPlanErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for DeleteBackupPlanError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteBackupPlanErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            DeleteBackupPlanErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DeleteBackupPlanErrorKind::MissingParameterValueException(_inner) => Some(_inner),
            DeleteBackupPlanErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteBackupPlanErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DeleteBackupPlanErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteBackupSelectionError {
    pub kind: DeleteBackupSelectionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteBackupSelectionErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    MissingParameterValueException(crate::error::MissingParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteBackupSelectionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteBackupSelectionErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            DeleteBackupSelectionErrorKind::MissingParameterValueException(_inner) => _inner.fmt(f),
            DeleteBackupSelectionErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteBackupSelectionErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DeleteBackupSelectionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteBackupSelectionError {
    fn code(&self) -> Option<&str> {
        DeleteBackupSelectionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteBackupSelectionError {
    pub fn new(kind: DeleteBackupSelectionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteBackupSelectionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteBackupSelectionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteBackupSelectionErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_missing_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteBackupSelectionErrorKind::MissingParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteBackupSelectionErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteBackupSelectionErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for DeleteBackupSelectionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteBackupSelectionErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            DeleteBackupSelectionErrorKind::MissingParameterValueException(_inner) => Some(_inner),
            DeleteBackupSelectionErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteBackupSelectionErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DeleteBackupSelectionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteBackupVaultError {
    pub kind: DeleteBackupVaultErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteBackupVaultErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    InvalidRequestException(crate::error::InvalidRequestException),
    MissingParameterValueException(crate::error::MissingParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteBackupVaultError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteBackupVaultErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            DeleteBackupVaultErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DeleteBackupVaultErrorKind::MissingParameterValueException(_inner) => _inner.fmt(f),
            DeleteBackupVaultErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteBackupVaultErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DeleteBackupVaultErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteBackupVaultError {
    fn code(&self) -> Option<&str> {
        DeleteBackupVaultError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteBackupVaultError {
    pub fn new(kind: DeleteBackupVaultErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteBackupVaultErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteBackupVaultErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteBackupVaultErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteBackupVaultErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_missing_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteBackupVaultErrorKind::MissingParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteBackupVaultErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteBackupVaultErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for DeleteBackupVaultError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteBackupVaultErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            DeleteBackupVaultErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DeleteBackupVaultErrorKind::MissingParameterValueException(_inner) => Some(_inner),
            DeleteBackupVaultErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteBackupVaultErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DeleteBackupVaultErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteBackupVaultAccessPolicyError {
    pub kind: DeleteBackupVaultAccessPolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteBackupVaultAccessPolicyErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    MissingParameterValueException(crate::error::MissingParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteBackupVaultAccessPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteBackupVaultAccessPolicyErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            DeleteBackupVaultAccessPolicyErrorKind::MissingParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            DeleteBackupVaultAccessPolicyErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            DeleteBackupVaultAccessPolicyErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            DeleteBackupVaultAccessPolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteBackupVaultAccessPolicyError {
    fn code(&self) -> Option<&str> {
        DeleteBackupVaultAccessPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteBackupVaultAccessPolicyError {
    pub fn new(kind: DeleteBackupVaultAccessPolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteBackupVaultAccessPolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteBackupVaultAccessPolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteBackupVaultAccessPolicyErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_missing_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteBackupVaultAccessPolicyErrorKind::MissingParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteBackupVaultAccessPolicyErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteBackupVaultAccessPolicyErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for DeleteBackupVaultAccessPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteBackupVaultAccessPolicyErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            DeleteBackupVaultAccessPolicyErrorKind::MissingParameterValueException(_inner) => {
                Some(_inner)
            }
            DeleteBackupVaultAccessPolicyErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            DeleteBackupVaultAccessPolicyErrorKind::ServiceUnavailableException(_inner) => {
                Some(_inner)
            }
            DeleteBackupVaultAccessPolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteBackupVaultNotificationsError {
    pub kind: DeleteBackupVaultNotificationsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteBackupVaultNotificationsErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    MissingParameterValueException(crate::error::MissingParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteBackupVaultNotificationsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteBackupVaultNotificationsErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            DeleteBackupVaultNotificationsErrorKind::MissingParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            DeleteBackupVaultNotificationsErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            DeleteBackupVaultNotificationsErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            DeleteBackupVaultNotificationsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteBackupVaultNotificationsError {
    fn code(&self) -> Option<&str> {
        DeleteBackupVaultNotificationsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteBackupVaultNotificationsError {
    pub fn new(kind: DeleteBackupVaultNotificationsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteBackupVaultNotificationsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteBackupVaultNotificationsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteBackupVaultNotificationsErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_missing_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteBackupVaultNotificationsErrorKind::MissingParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteBackupVaultNotificationsErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteBackupVaultNotificationsErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for DeleteBackupVaultNotificationsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteBackupVaultNotificationsErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            DeleteBackupVaultNotificationsErrorKind::MissingParameterValueException(_inner) => {
                Some(_inner)
            }
            DeleteBackupVaultNotificationsErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            DeleteBackupVaultNotificationsErrorKind::ServiceUnavailableException(_inner) => {
                Some(_inner)
            }
            DeleteBackupVaultNotificationsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteFrameworkError {
    pub kind: DeleteFrameworkErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteFrameworkErrorKind {
    ConflictException(crate::error::ConflictException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    MissingParameterValueException(crate::error::MissingParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteFrameworkError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteFrameworkErrorKind::ConflictException(_inner) => _inner.fmt(f),
            DeleteFrameworkErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            DeleteFrameworkErrorKind::MissingParameterValueException(_inner) => _inner.fmt(f),
            DeleteFrameworkErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteFrameworkErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DeleteFrameworkErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteFrameworkError {
    fn code(&self) -> Option<&str> {
        DeleteFrameworkError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteFrameworkError {
    pub fn new(kind: DeleteFrameworkErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteFrameworkErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteFrameworkErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, DeleteFrameworkErrorKind::ConflictException(_))
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFrameworkErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_missing_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFrameworkErrorKind::MissingParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFrameworkErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFrameworkErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for DeleteFrameworkError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteFrameworkErrorKind::ConflictException(_inner) => Some(_inner),
            DeleteFrameworkErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            DeleteFrameworkErrorKind::MissingParameterValueException(_inner) => Some(_inner),
            DeleteFrameworkErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteFrameworkErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DeleteFrameworkErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteRecoveryPointError {
    pub kind: DeleteRecoveryPointErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteRecoveryPointErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    InvalidRequestException(crate::error::InvalidRequestException),
    InvalidResourceStateException(crate::error::InvalidResourceStateException),
    MissingParameterValueException(crate::error::MissingParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteRecoveryPointError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteRecoveryPointErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            DeleteRecoveryPointErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DeleteRecoveryPointErrorKind::InvalidResourceStateException(_inner) => _inner.fmt(f),
            DeleteRecoveryPointErrorKind::MissingParameterValueException(_inner) => _inner.fmt(f),
            DeleteRecoveryPointErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteRecoveryPointErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DeleteRecoveryPointErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteRecoveryPointError {
    fn code(&self) -> Option<&str> {
        DeleteRecoveryPointError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteRecoveryPointError {
    pub fn new(kind: DeleteRecoveryPointErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteRecoveryPointErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteRecoveryPointErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRecoveryPointErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRecoveryPointErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_invalid_resource_state_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRecoveryPointErrorKind::InvalidResourceStateException(_)
        )
    }
    pub fn is_missing_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRecoveryPointErrorKind::MissingParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRecoveryPointErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRecoveryPointErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for DeleteRecoveryPointError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteRecoveryPointErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            DeleteRecoveryPointErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DeleteRecoveryPointErrorKind::InvalidResourceStateException(_inner) => Some(_inner),
            DeleteRecoveryPointErrorKind::MissingParameterValueException(_inner) => Some(_inner),
            DeleteRecoveryPointErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteRecoveryPointErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DeleteRecoveryPointErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteReportPlanError {
    pub kind: DeleteReportPlanErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteReportPlanErrorKind {
    ConflictException(crate::error::ConflictException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    MissingParameterValueException(crate::error::MissingParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteReportPlanError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteReportPlanErrorKind::ConflictException(_inner) => _inner.fmt(f),
            DeleteReportPlanErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            DeleteReportPlanErrorKind::MissingParameterValueException(_inner) => _inner.fmt(f),
            DeleteReportPlanErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteReportPlanErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DeleteReportPlanErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteReportPlanError {
    fn code(&self) -> Option<&str> {
        DeleteReportPlanError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteReportPlanError {
    pub fn new(kind: DeleteReportPlanErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteReportPlanErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteReportPlanErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, DeleteReportPlanErrorKind::ConflictException(_))
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteReportPlanErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_missing_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteReportPlanErrorKind::MissingParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteReportPlanErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteReportPlanErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for DeleteReportPlanError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteReportPlanErrorKind::ConflictException(_inner) => Some(_inner),
            DeleteReportPlanErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            DeleteReportPlanErrorKind::MissingParameterValueException(_inner) => Some(_inner),
            DeleteReportPlanErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteReportPlanErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DeleteReportPlanErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeBackupJobError {
    pub kind: DescribeBackupJobErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeBackupJobErrorKind {
    DependencyFailureException(crate::error::DependencyFailureException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    MissingParameterValueException(crate::error::MissingParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeBackupJobError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeBackupJobErrorKind::DependencyFailureException(_inner) => _inner.fmt(f),
            DescribeBackupJobErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            DescribeBackupJobErrorKind::MissingParameterValueException(_inner) => _inner.fmt(f),
            DescribeBackupJobErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeBackupJobErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DescribeBackupJobErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeBackupJobError {
    fn code(&self) -> Option<&str> {
        DescribeBackupJobError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeBackupJobError {
    pub fn new(kind: DescribeBackupJobErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeBackupJobErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeBackupJobErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_dependency_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeBackupJobErrorKind::DependencyFailureException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeBackupJobErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_missing_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeBackupJobErrorKind::MissingParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeBackupJobErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeBackupJobErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for DescribeBackupJobError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeBackupJobErrorKind::DependencyFailureException(_inner) => Some(_inner),
            DescribeBackupJobErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            DescribeBackupJobErrorKind::MissingParameterValueException(_inner) => Some(_inner),
            DescribeBackupJobErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeBackupJobErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DescribeBackupJobErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeBackupVaultError {
    pub kind: DescribeBackupVaultErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeBackupVaultErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    MissingParameterValueException(crate::error::MissingParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeBackupVaultError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeBackupVaultErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            DescribeBackupVaultErrorKind::MissingParameterValueException(_inner) => _inner.fmt(f),
            DescribeBackupVaultErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeBackupVaultErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DescribeBackupVaultErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeBackupVaultError {
    fn code(&self) -> Option<&str> {
        DescribeBackupVaultError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeBackupVaultError {
    pub fn new(kind: DescribeBackupVaultErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeBackupVaultErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeBackupVaultErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeBackupVaultErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_missing_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeBackupVaultErrorKind::MissingParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeBackupVaultErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeBackupVaultErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for DescribeBackupVaultError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeBackupVaultErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            DescribeBackupVaultErrorKind::MissingParameterValueException(_inner) => Some(_inner),
            DescribeBackupVaultErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeBackupVaultErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DescribeBackupVaultErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeCopyJobError {
    pub kind: DescribeCopyJobErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeCopyJobErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    MissingParameterValueException(crate::error::MissingParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeCopyJobError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeCopyJobErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            DescribeCopyJobErrorKind::MissingParameterValueException(_inner) => _inner.fmt(f),
            DescribeCopyJobErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeCopyJobErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DescribeCopyJobErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeCopyJobError {
    fn code(&self) -> Option<&str> {
        DescribeCopyJobError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeCopyJobError {
    pub fn new(kind: DescribeCopyJobErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeCopyJobErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeCopyJobErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeCopyJobErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_missing_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeCopyJobErrorKind::MissingParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeCopyJobErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeCopyJobErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for DescribeCopyJobError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeCopyJobErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            DescribeCopyJobErrorKind::MissingParameterValueException(_inner) => Some(_inner),
            DescribeCopyJobErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeCopyJobErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DescribeCopyJobErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeFrameworkError {
    pub kind: DescribeFrameworkErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeFrameworkErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    MissingParameterValueException(crate::error::MissingParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeFrameworkError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeFrameworkErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            DescribeFrameworkErrorKind::MissingParameterValueException(_inner) => _inner.fmt(f),
            DescribeFrameworkErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeFrameworkErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DescribeFrameworkErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeFrameworkError {
    fn code(&self) -> Option<&str> {
        DescribeFrameworkError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeFrameworkError {
    pub fn new(kind: DescribeFrameworkErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeFrameworkErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeFrameworkErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeFrameworkErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_missing_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeFrameworkErrorKind::MissingParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeFrameworkErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeFrameworkErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for DescribeFrameworkError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeFrameworkErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            DescribeFrameworkErrorKind::MissingParameterValueException(_inner) => Some(_inner),
            DescribeFrameworkErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeFrameworkErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DescribeFrameworkErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeGlobalSettingsError {
    pub kind: DescribeGlobalSettingsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeGlobalSettingsErrorKind {
    InvalidRequestException(crate::error::InvalidRequestException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeGlobalSettingsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeGlobalSettingsErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DescribeGlobalSettingsErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DescribeGlobalSettingsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeGlobalSettingsError {
    fn code(&self) -> Option<&str> {
        DescribeGlobalSettingsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeGlobalSettingsError {
    pub fn new(kind: DescribeGlobalSettingsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeGlobalSettingsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeGlobalSettingsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeGlobalSettingsErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeGlobalSettingsErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for DescribeGlobalSettingsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeGlobalSettingsErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DescribeGlobalSettingsErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DescribeGlobalSettingsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeProtectedResourceError {
    pub kind: DescribeProtectedResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeProtectedResourceErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    MissingParameterValueException(crate::error::MissingParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeProtectedResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeProtectedResourceErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            DescribeProtectedResourceErrorKind::MissingParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            DescribeProtectedResourceErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeProtectedResourceErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            DescribeProtectedResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeProtectedResourceError {
    fn code(&self) -> Option<&str> {
        DescribeProtectedResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeProtectedResourceError {
    pub fn new(kind: DescribeProtectedResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeProtectedResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeProtectedResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeProtectedResourceErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_missing_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeProtectedResourceErrorKind::MissingParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeProtectedResourceErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeProtectedResourceErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for DescribeProtectedResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeProtectedResourceErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            DescribeProtectedResourceErrorKind::MissingParameterValueException(_inner) => {
                Some(_inner)
            }
            DescribeProtectedResourceErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeProtectedResourceErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DescribeProtectedResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeRecoveryPointError {
    pub kind: DescribeRecoveryPointErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeRecoveryPointErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    MissingParameterValueException(crate::error::MissingParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeRecoveryPointError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeRecoveryPointErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            DescribeRecoveryPointErrorKind::MissingParameterValueException(_inner) => _inner.fmt(f),
            DescribeRecoveryPointErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeRecoveryPointErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DescribeRecoveryPointErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeRecoveryPointError {
    fn code(&self) -> Option<&str> {
        DescribeRecoveryPointError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeRecoveryPointError {
    pub fn new(kind: DescribeRecoveryPointErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeRecoveryPointErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeRecoveryPointErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeRecoveryPointErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_missing_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeRecoveryPointErrorKind::MissingParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeRecoveryPointErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeRecoveryPointErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for DescribeRecoveryPointError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeRecoveryPointErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            DescribeRecoveryPointErrorKind::MissingParameterValueException(_inner) => Some(_inner),
            DescribeRecoveryPointErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeRecoveryPointErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DescribeRecoveryPointErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeRegionSettingsError {
    pub kind: DescribeRegionSettingsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeRegionSettingsErrorKind {
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeRegionSettingsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeRegionSettingsErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DescribeRegionSettingsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeRegionSettingsError {
    fn code(&self) -> Option<&str> {
        DescribeRegionSettingsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeRegionSettingsError {
    pub fn new(kind: DescribeRegionSettingsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeRegionSettingsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeRegionSettingsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeRegionSettingsErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for DescribeRegionSettingsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeRegionSettingsErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DescribeRegionSettingsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeReportJobError {
    pub kind: DescribeReportJobErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeReportJobErrorKind {
    MissingParameterValueException(crate::error::MissingParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeReportJobError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeReportJobErrorKind::MissingParameterValueException(_inner) => _inner.fmt(f),
            DescribeReportJobErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeReportJobErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DescribeReportJobErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeReportJobError {
    fn code(&self) -> Option<&str> {
        DescribeReportJobError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeReportJobError {
    pub fn new(kind: DescribeReportJobErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeReportJobErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeReportJobErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_missing_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeReportJobErrorKind::MissingParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeReportJobErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeReportJobErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for DescribeReportJobError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeReportJobErrorKind::MissingParameterValueException(_inner) => Some(_inner),
            DescribeReportJobErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeReportJobErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DescribeReportJobErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeReportPlanError {
    pub kind: DescribeReportPlanErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeReportPlanErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    MissingParameterValueException(crate::error::MissingParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeReportPlanError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeReportPlanErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            DescribeReportPlanErrorKind::MissingParameterValueException(_inner) => _inner.fmt(f),
            DescribeReportPlanErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeReportPlanErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DescribeReportPlanErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeReportPlanError {
    fn code(&self) -> Option<&str> {
        DescribeReportPlanError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeReportPlanError {
    pub fn new(kind: DescribeReportPlanErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeReportPlanErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeReportPlanErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeReportPlanErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_missing_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeReportPlanErrorKind::MissingParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeReportPlanErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeReportPlanErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for DescribeReportPlanError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeReportPlanErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            DescribeReportPlanErrorKind::MissingParameterValueException(_inner) => Some(_inner),
            DescribeReportPlanErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeReportPlanErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DescribeReportPlanErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeRestoreJobError {
    pub kind: DescribeRestoreJobErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeRestoreJobErrorKind {
    DependencyFailureException(crate::error::DependencyFailureException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    MissingParameterValueException(crate::error::MissingParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeRestoreJobError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeRestoreJobErrorKind::DependencyFailureException(_inner) => _inner.fmt(f),
            DescribeRestoreJobErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            DescribeRestoreJobErrorKind::MissingParameterValueException(_inner) => _inner.fmt(f),
            DescribeRestoreJobErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeRestoreJobErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DescribeRestoreJobErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeRestoreJobError {
    fn code(&self) -> Option<&str> {
        DescribeRestoreJobError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeRestoreJobError {
    pub fn new(kind: DescribeRestoreJobErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeRestoreJobErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeRestoreJobErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_dependency_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeRestoreJobErrorKind::DependencyFailureException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeRestoreJobErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_missing_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeRestoreJobErrorKind::MissingParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeRestoreJobErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeRestoreJobErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for DescribeRestoreJobError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeRestoreJobErrorKind::DependencyFailureException(_inner) => Some(_inner),
            DescribeRestoreJobErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            DescribeRestoreJobErrorKind::MissingParameterValueException(_inner) => Some(_inner),
            DescribeRestoreJobErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeRestoreJobErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DescribeRestoreJobErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DisassociateRecoveryPointError {
    pub kind: DisassociateRecoveryPointErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DisassociateRecoveryPointErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    InvalidRequestException(crate::error::InvalidRequestException),
    InvalidResourceStateException(crate::error::InvalidResourceStateException),
    MissingParameterValueException(crate::error::MissingParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DisassociateRecoveryPointError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DisassociateRecoveryPointErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            DisassociateRecoveryPointErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DisassociateRecoveryPointErrorKind::InvalidResourceStateException(_inner) => {
                _inner.fmt(f)
            }
            DisassociateRecoveryPointErrorKind::MissingParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            DisassociateRecoveryPointErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DisassociateRecoveryPointErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            DisassociateRecoveryPointErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DisassociateRecoveryPointError {
    fn code(&self) -> Option<&str> {
        DisassociateRecoveryPointError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DisassociateRecoveryPointError {
    pub fn new(kind: DisassociateRecoveryPointErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DisassociateRecoveryPointErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DisassociateRecoveryPointErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateRecoveryPointErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateRecoveryPointErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_invalid_resource_state_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateRecoveryPointErrorKind::InvalidResourceStateException(_)
        )
    }
    pub fn is_missing_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateRecoveryPointErrorKind::MissingParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateRecoveryPointErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateRecoveryPointErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for DisassociateRecoveryPointError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DisassociateRecoveryPointErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            DisassociateRecoveryPointErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DisassociateRecoveryPointErrorKind::InvalidResourceStateException(_inner) => {
                Some(_inner)
            }
            DisassociateRecoveryPointErrorKind::MissingParameterValueException(_inner) => {
                Some(_inner)
            }
            DisassociateRecoveryPointErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DisassociateRecoveryPointErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DisassociateRecoveryPointErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ExportBackupPlanTemplateError {
    pub kind: ExportBackupPlanTemplateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ExportBackupPlanTemplateErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    MissingParameterValueException(crate::error::MissingParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ExportBackupPlanTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ExportBackupPlanTemplateErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            ExportBackupPlanTemplateErrorKind::MissingParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            ExportBackupPlanTemplateErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ExportBackupPlanTemplateErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ExportBackupPlanTemplateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ExportBackupPlanTemplateError {
    fn code(&self) -> Option<&str> {
        ExportBackupPlanTemplateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ExportBackupPlanTemplateError {
    pub fn new(kind: ExportBackupPlanTemplateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ExportBackupPlanTemplateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ExportBackupPlanTemplateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            ExportBackupPlanTemplateErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_missing_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            ExportBackupPlanTemplateErrorKind::MissingParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ExportBackupPlanTemplateErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ExportBackupPlanTemplateErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for ExportBackupPlanTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ExportBackupPlanTemplateErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            ExportBackupPlanTemplateErrorKind::MissingParameterValueException(_inner) => {
                Some(_inner)
            }
            ExportBackupPlanTemplateErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ExportBackupPlanTemplateErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ExportBackupPlanTemplateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetBackupPlanError {
    pub kind: GetBackupPlanErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetBackupPlanErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    MissingParameterValueException(crate::error::MissingParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetBackupPlanError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetBackupPlanErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            GetBackupPlanErrorKind::MissingParameterValueException(_inner) => _inner.fmt(f),
            GetBackupPlanErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetBackupPlanErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            GetBackupPlanErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetBackupPlanError {
    fn code(&self) -> Option<&str> {
        GetBackupPlanError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetBackupPlanError {
    pub fn new(kind: GetBackupPlanErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetBackupPlanErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetBackupPlanErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBackupPlanErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_missing_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBackupPlanErrorKind::MissingParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBackupPlanErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBackupPlanErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for GetBackupPlanError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetBackupPlanErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            GetBackupPlanErrorKind::MissingParameterValueException(_inner) => Some(_inner),
            GetBackupPlanErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetBackupPlanErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            GetBackupPlanErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetBackupPlanFromJSONError {
    pub kind: GetBackupPlanFromJSONErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetBackupPlanFromJSONErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    InvalidRequestException(crate::error::InvalidRequestException),
    LimitExceededException(crate::error::LimitExceededException),
    MissingParameterValueException(crate::error::MissingParameterValueException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetBackupPlanFromJSONError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetBackupPlanFromJSONErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            GetBackupPlanFromJSONErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            GetBackupPlanFromJSONErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            GetBackupPlanFromJSONErrorKind::MissingParameterValueException(_inner) => _inner.fmt(f),
            GetBackupPlanFromJSONErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            GetBackupPlanFromJSONErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetBackupPlanFromJSONError {
    fn code(&self) -> Option<&str> {
        GetBackupPlanFromJSONError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetBackupPlanFromJSONError {
    pub fn new(kind: GetBackupPlanFromJSONErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetBackupPlanFromJSONErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetBackupPlanFromJSONErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBackupPlanFromJSONErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBackupPlanFromJSONErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBackupPlanFromJSONErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_missing_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBackupPlanFromJSONErrorKind::MissingParameterValueException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBackupPlanFromJSONErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for GetBackupPlanFromJSONError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetBackupPlanFromJSONErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            GetBackupPlanFromJSONErrorKind::InvalidRequestException(_inner) => Some(_inner),
            GetBackupPlanFromJSONErrorKind::LimitExceededException(_inner) => Some(_inner),
            GetBackupPlanFromJSONErrorKind::MissingParameterValueException(_inner) => Some(_inner),
            GetBackupPlanFromJSONErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            GetBackupPlanFromJSONErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetBackupPlanFromTemplateError {
    pub kind: GetBackupPlanFromTemplateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetBackupPlanFromTemplateErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    MissingParameterValueException(crate::error::MissingParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetBackupPlanFromTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetBackupPlanFromTemplateErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            GetBackupPlanFromTemplateErrorKind::MissingParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            GetBackupPlanFromTemplateErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetBackupPlanFromTemplateErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            GetBackupPlanFromTemplateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetBackupPlanFromTemplateError {
    fn code(&self) -> Option<&str> {
        GetBackupPlanFromTemplateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetBackupPlanFromTemplateError {
    pub fn new(kind: GetBackupPlanFromTemplateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetBackupPlanFromTemplateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetBackupPlanFromTemplateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBackupPlanFromTemplateErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_missing_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBackupPlanFromTemplateErrorKind::MissingParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBackupPlanFromTemplateErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBackupPlanFromTemplateErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for GetBackupPlanFromTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetBackupPlanFromTemplateErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            GetBackupPlanFromTemplateErrorKind::MissingParameterValueException(_inner) => {
                Some(_inner)
            }
            GetBackupPlanFromTemplateErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetBackupPlanFromTemplateErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            GetBackupPlanFromTemplateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetBackupSelectionError {
    pub kind: GetBackupSelectionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetBackupSelectionErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    MissingParameterValueException(crate::error::MissingParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetBackupSelectionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetBackupSelectionErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            GetBackupSelectionErrorKind::MissingParameterValueException(_inner) => _inner.fmt(f),
            GetBackupSelectionErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetBackupSelectionErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            GetBackupSelectionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetBackupSelectionError {
    fn code(&self) -> Option<&str> {
        GetBackupSelectionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetBackupSelectionError {
    pub fn new(kind: GetBackupSelectionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetBackupSelectionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetBackupSelectionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBackupSelectionErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_missing_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBackupSelectionErrorKind::MissingParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBackupSelectionErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBackupSelectionErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for GetBackupSelectionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetBackupSelectionErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            GetBackupSelectionErrorKind::MissingParameterValueException(_inner) => Some(_inner),
            GetBackupSelectionErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetBackupSelectionErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            GetBackupSelectionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetBackupVaultAccessPolicyError {
    pub kind: GetBackupVaultAccessPolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetBackupVaultAccessPolicyErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    MissingParameterValueException(crate::error::MissingParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetBackupVaultAccessPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetBackupVaultAccessPolicyErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            GetBackupVaultAccessPolicyErrorKind::MissingParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            GetBackupVaultAccessPolicyErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetBackupVaultAccessPolicyErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            GetBackupVaultAccessPolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetBackupVaultAccessPolicyError {
    fn code(&self) -> Option<&str> {
        GetBackupVaultAccessPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetBackupVaultAccessPolicyError {
    pub fn new(kind: GetBackupVaultAccessPolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetBackupVaultAccessPolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetBackupVaultAccessPolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBackupVaultAccessPolicyErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_missing_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBackupVaultAccessPolicyErrorKind::MissingParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBackupVaultAccessPolicyErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBackupVaultAccessPolicyErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for GetBackupVaultAccessPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetBackupVaultAccessPolicyErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            GetBackupVaultAccessPolicyErrorKind::MissingParameterValueException(_inner) => {
                Some(_inner)
            }
            GetBackupVaultAccessPolicyErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetBackupVaultAccessPolicyErrorKind::ServiceUnavailableException(_inner) => {
                Some(_inner)
            }
            GetBackupVaultAccessPolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetBackupVaultNotificationsError {
    pub kind: GetBackupVaultNotificationsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetBackupVaultNotificationsErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    MissingParameterValueException(crate::error::MissingParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetBackupVaultNotificationsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetBackupVaultNotificationsErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            GetBackupVaultNotificationsErrorKind::MissingParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            GetBackupVaultNotificationsErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            GetBackupVaultNotificationsErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            GetBackupVaultNotificationsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetBackupVaultNotificationsError {
    fn code(&self) -> Option<&str> {
        GetBackupVaultNotificationsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetBackupVaultNotificationsError {
    pub fn new(kind: GetBackupVaultNotificationsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetBackupVaultNotificationsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetBackupVaultNotificationsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBackupVaultNotificationsErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_missing_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBackupVaultNotificationsErrorKind::MissingParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBackupVaultNotificationsErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBackupVaultNotificationsErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for GetBackupVaultNotificationsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetBackupVaultNotificationsErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            GetBackupVaultNotificationsErrorKind::MissingParameterValueException(_inner) => {
                Some(_inner)
            }
            GetBackupVaultNotificationsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetBackupVaultNotificationsErrorKind::ServiceUnavailableException(_inner) => {
                Some(_inner)
            }
            GetBackupVaultNotificationsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetRecoveryPointRestoreMetadataError {
    pub kind: GetRecoveryPointRestoreMetadataErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetRecoveryPointRestoreMetadataErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    MissingParameterValueException(crate::error::MissingParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetRecoveryPointRestoreMetadataError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetRecoveryPointRestoreMetadataErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            GetRecoveryPointRestoreMetadataErrorKind::MissingParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            GetRecoveryPointRestoreMetadataErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            GetRecoveryPointRestoreMetadataErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            GetRecoveryPointRestoreMetadataErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetRecoveryPointRestoreMetadataError {
    fn code(&self) -> Option<&str> {
        GetRecoveryPointRestoreMetadataError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetRecoveryPointRestoreMetadataError {
    pub fn new(kind: GetRecoveryPointRestoreMetadataErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetRecoveryPointRestoreMetadataErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetRecoveryPointRestoreMetadataErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRecoveryPointRestoreMetadataErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_missing_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRecoveryPointRestoreMetadataErrorKind::MissingParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRecoveryPointRestoreMetadataErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRecoveryPointRestoreMetadataErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for GetRecoveryPointRestoreMetadataError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetRecoveryPointRestoreMetadataErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            GetRecoveryPointRestoreMetadataErrorKind::MissingParameterValueException(_inner) => {
                Some(_inner)
            }
            GetRecoveryPointRestoreMetadataErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            GetRecoveryPointRestoreMetadataErrorKind::ServiceUnavailableException(_inner) => {
                Some(_inner)
            }
            GetRecoveryPointRestoreMetadataErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetSupportedResourceTypesError {
    pub kind: GetSupportedResourceTypesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetSupportedResourceTypesErrorKind {
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetSupportedResourceTypesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetSupportedResourceTypesErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            GetSupportedResourceTypesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetSupportedResourceTypesError {
    fn code(&self) -> Option<&str> {
        GetSupportedResourceTypesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetSupportedResourceTypesError {
    pub fn new(kind: GetSupportedResourceTypesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetSupportedResourceTypesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetSupportedResourceTypesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSupportedResourceTypesErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for GetSupportedResourceTypesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetSupportedResourceTypesErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            GetSupportedResourceTypesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListBackupJobsError {
    pub kind: ListBackupJobsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListBackupJobsErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListBackupJobsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListBackupJobsErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            ListBackupJobsErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListBackupJobsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListBackupJobsError {
    fn code(&self) -> Option<&str> {
        ListBackupJobsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListBackupJobsError {
    pub fn new(kind: ListBackupJobsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListBackupJobsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListBackupJobsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListBackupJobsErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListBackupJobsErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for ListBackupJobsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListBackupJobsErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            ListBackupJobsErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListBackupJobsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListBackupPlansError {
    pub kind: ListBackupPlansErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListBackupPlansErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    MissingParameterValueException(crate::error::MissingParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListBackupPlansError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListBackupPlansErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            ListBackupPlansErrorKind::MissingParameterValueException(_inner) => _inner.fmt(f),
            ListBackupPlansErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListBackupPlansErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListBackupPlansErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListBackupPlansError {
    fn code(&self) -> Option<&str> {
        ListBackupPlansError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListBackupPlansError {
    pub fn new(kind: ListBackupPlansErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListBackupPlansErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListBackupPlansErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListBackupPlansErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_missing_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListBackupPlansErrorKind::MissingParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListBackupPlansErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListBackupPlansErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for ListBackupPlansError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListBackupPlansErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            ListBackupPlansErrorKind::MissingParameterValueException(_inner) => Some(_inner),
            ListBackupPlansErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListBackupPlansErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListBackupPlansErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListBackupPlanTemplatesError {
    pub kind: ListBackupPlanTemplatesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListBackupPlanTemplatesErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    MissingParameterValueException(crate::error::MissingParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListBackupPlanTemplatesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListBackupPlanTemplatesErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            ListBackupPlanTemplatesErrorKind::MissingParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            ListBackupPlanTemplatesErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListBackupPlanTemplatesErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListBackupPlanTemplatesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListBackupPlanTemplatesError {
    fn code(&self) -> Option<&str> {
        ListBackupPlanTemplatesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListBackupPlanTemplatesError {
    pub fn new(kind: ListBackupPlanTemplatesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListBackupPlanTemplatesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListBackupPlanTemplatesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListBackupPlanTemplatesErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_missing_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListBackupPlanTemplatesErrorKind::MissingParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListBackupPlanTemplatesErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListBackupPlanTemplatesErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for ListBackupPlanTemplatesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListBackupPlanTemplatesErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            ListBackupPlanTemplatesErrorKind::MissingParameterValueException(_inner) => {
                Some(_inner)
            }
            ListBackupPlanTemplatesErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListBackupPlanTemplatesErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListBackupPlanTemplatesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListBackupPlanVersionsError {
    pub kind: ListBackupPlanVersionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListBackupPlanVersionsErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    MissingParameterValueException(crate::error::MissingParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListBackupPlanVersionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListBackupPlanVersionsErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            ListBackupPlanVersionsErrorKind::MissingParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            ListBackupPlanVersionsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListBackupPlanVersionsErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListBackupPlanVersionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListBackupPlanVersionsError {
    fn code(&self) -> Option<&str> {
        ListBackupPlanVersionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListBackupPlanVersionsError {
    pub fn new(kind: ListBackupPlanVersionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListBackupPlanVersionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListBackupPlanVersionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListBackupPlanVersionsErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_missing_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListBackupPlanVersionsErrorKind::MissingParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListBackupPlanVersionsErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListBackupPlanVersionsErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for ListBackupPlanVersionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListBackupPlanVersionsErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            ListBackupPlanVersionsErrorKind::MissingParameterValueException(_inner) => Some(_inner),
            ListBackupPlanVersionsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListBackupPlanVersionsErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListBackupPlanVersionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListBackupSelectionsError {
    pub kind: ListBackupSelectionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListBackupSelectionsErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    MissingParameterValueException(crate::error::MissingParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListBackupSelectionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListBackupSelectionsErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            ListBackupSelectionsErrorKind::MissingParameterValueException(_inner) => _inner.fmt(f),
            ListBackupSelectionsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListBackupSelectionsErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListBackupSelectionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListBackupSelectionsError {
    fn code(&self) -> Option<&str> {
        ListBackupSelectionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListBackupSelectionsError {
    pub fn new(kind: ListBackupSelectionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListBackupSelectionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListBackupSelectionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListBackupSelectionsErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_missing_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListBackupSelectionsErrorKind::MissingParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListBackupSelectionsErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListBackupSelectionsErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for ListBackupSelectionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListBackupSelectionsErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            ListBackupSelectionsErrorKind::MissingParameterValueException(_inner) => Some(_inner),
            ListBackupSelectionsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListBackupSelectionsErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListBackupSelectionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListBackupVaultsError {
    pub kind: ListBackupVaultsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListBackupVaultsErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    MissingParameterValueException(crate::error::MissingParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListBackupVaultsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListBackupVaultsErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            ListBackupVaultsErrorKind::MissingParameterValueException(_inner) => _inner.fmt(f),
            ListBackupVaultsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListBackupVaultsErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListBackupVaultsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListBackupVaultsError {
    fn code(&self) -> Option<&str> {
        ListBackupVaultsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListBackupVaultsError {
    pub fn new(kind: ListBackupVaultsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListBackupVaultsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListBackupVaultsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListBackupVaultsErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_missing_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListBackupVaultsErrorKind::MissingParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListBackupVaultsErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListBackupVaultsErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for ListBackupVaultsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListBackupVaultsErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            ListBackupVaultsErrorKind::MissingParameterValueException(_inner) => Some(_inner),
            ListBackupVaultsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListBackupVaultsErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListBackupVaultsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListCopyJobsError {
    pub kind: ListCopyJobsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListCopyJobsErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListCopyJobsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListCopyJobsErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            ListCopyJobsErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListCopyJobsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListCopyJobsError {
    fn code(&self) -> Option<&str> {
        ListCopyJobsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListCopyJobsError {
    pub fn new(kind: ListCopyJobsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListCopyJobsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListCopyJobsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListCopyJobsErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListCopyJobsErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for ListCopyJobsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListCopyJobsErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            ListCopyJobsErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListCopyJobsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListFrameworksError {
    pub kind: ListFrameworksErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListFrameworksErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListFrameworksError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListFrameworksErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            ListFrameworksErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListFrameworksErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListFrameworksError {
    fn code(&self) -> Option<&str> {
        ListFrameworksError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListFrameworksError {
    pub fn new(kind: ListFrameworksErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListFrameworksErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListFrameworksErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListFrameworksErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListFrameworksErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for ListFrameworksError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListFrameworksErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            ListFrameworksErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListFrameworksErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListProtectedResourcesError {
    pub kind: ListProtectedResourcesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListProtectedResourcesErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListProtectedResourcesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListProtectedResourcesErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            ListProtectedResourcesErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListProtectedResourcesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListProtectedResourcesError {
    fn code(&self) -> Option<&str> {
        ListProtectedResourcesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListProtectedResourcesError {
    pub fn new(kind: ListProtectedResourcesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListProtectedResourcesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListProtectedResourcesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListProtectedResourcesErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListProtectedResourcesErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for ListProtectedResourcesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListProtectedResourcesErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            ListProtectedResourcesErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListProtectedResourcesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListRecoveryPointsByBackupVaultError {
    pub kind: ListRecoveryPointsByBackupVaultErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListRecoveryPointsByBackupVaultErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    MissingParameterValueException(crate::error::MissingParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListRecoveryPointsByBackupVaultError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListRecoveryPointsByBackupVaultErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            ListRecoveryPointsByBackupVaultErrorKind::MissingParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            ListRecoveryPointsByBackupVaultErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            ListRecoveryPointsByBackupVaultErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            ListRecoveryPointsByBackupVaultErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListRecoveryPointsByBackupVaultError {
    fn code(&self) -> Option<&str> {
        ListRecoveryPointsByBackupVaultError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListRecoveryPointsByBackupVaultError {
    pub fn new(kind: ListRecoveryPointsByBackupVaultErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListRecoveryPointsByBackupVaultErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListRecoveryPointsByBackupVaultErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListRecoveryPointsByBackupVaultErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_missing_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListRecoveryPointsByBackupVaultErrorKind::MissingParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListRecoveryPointsByBackupVaultErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListRecoveryPointsByBackupVaultErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for ListRecoveryPointsByBackupVaultError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListRecoveryPointsByBackupVaultErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            ListRecoveryPointsByBackupVaultErrorKind::MissingParameterValueException(_inner) => {
                Some(_inner)
            }
            ListRecoveryPointsByBackupVaultErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            ListRecoveryPointsByBackupVaultErrorKind::ServiceUnavailableException(_inner) => {
                Some(_inner)
            }
            ListRecoveryPointsByBackupVaultErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListRecoveryPointsByResourceError {
    pub kind: ListRecoveryPointsByResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListRecoveryPointsByResourceErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    MissingParameterValueException(crate::error::MissingParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListRecoveryPointsByResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListRecoveryPointsByResourceErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            ListRecoveryPointsByResourceErrorKind::MissingParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            ListRecoveryPointsByResourceErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            ListRecoveryPointsByResourceErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            ListRecoveryPointsByResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListRecoveryPointsByResourceError {
    fn code(&self) -> Option<&str> {
        ListRecoveryPointsByResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListRecoveryPointsByResourceError {
    pub fn new(kind: ListRecoveryPointsByResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListRecoveryPointsByResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListRecoveryPointsByResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListRecoveryPointsByResourceErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_missing_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListRecoveryPointsByResourceErrorKind::MissingParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListRecoveryPointsByResourceErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListRecoveryPointsByResourceErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for ListRecoveryPointsByResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListRecoveryPointsByResourceErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            ListRecoveryPointsByResourceErrorKind::MissingParameterValueException(_inner) => {
                Some(_inner)
            }
            ListRecoveryPointsByResourceErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            ListRecoveryPointsByResourceErrorKind::ServiceUnavailableException(_inner) => {
                Some(_inner)
            }
            ListRecoveryPointsByResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListReportJobsError {
    pub kind: ListReportJobsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListReportJobsErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListReportJobsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListReportJobsErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            ListReportJobsErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListReportJobsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListReportJobsError {
    fn code(&self) -> Option<&str> {
        ListReportJobsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListReportJobsError {
    pub fn new(kind: ListReportJobsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListReportJobsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListReportJobsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListReportJobsErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListReportJobsErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for ListReportJobsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListReportJobsErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            ListReportJobsErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListReportJobsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListReportPlansError {
    pub kind: ListReportPlansErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListReportPlansErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListReportPlansError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListReportPlansErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            ListReportPlansErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListReportPlansErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListReportPlansError {
    fn code(&self) -> Option<&str> {
        ListReportPlansError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListReportPlansError {
    pub fn new(kind: ListReportPlansErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListReportPlansErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListReportPlansErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListReportPlansErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListReportPlansErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for ListReportPlansError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListReportPlansErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            ListReportPlansErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListReportPlansErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListRestoreJobsError {
    pub kind: ListRestoreJobsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListRestoreJobsErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    MissingParameterValueException(crate::error::MissingParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListRestoreJobsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListRestoreJobsErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            ListRestoreJobsErrorKind::MissingParameterValueException(_inner) => _inner.fmt(f),
            ListRestoreJobsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListRestoreJobsErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListRestoreJobsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListRestoreJobsError {
    fn code(&self) -> Option<&str> {
        ListRestoreJobsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListRestoreJobsError {
    pub fn new(kind: ListRestoreJobsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListRestoreJobsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListRestoreJobsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListRestoreJobsErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_missing_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListRestoreJobsErrorKind::MissingParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListRestoreJobsErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListRestoreJobsErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for ListRestoreJobsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListRestoreJobsErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            ListRestoreJobsErrorKind::MissingParameterValueException(_inner) => Some(_inner),
            ListRestoreJobsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListRestoreJobsErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListRestoreJobsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTagsError {
    pub kind: ListTagsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTagsErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    MissingParameterValueException(crate::error::MissingParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListTagsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTagsErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            ListTagsErrorKind::MissingParameterValueException(_inner) => _inner.fmt(f),
            ListTagsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListTagsErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListTagsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListTagsError {
    fn code(&self) -> Option<&str> {
        ListTagsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTagsError {
    pub fn new(kind: ListTagsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListTagsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListTagsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_missing_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsErrorKind::MissingParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, ListTagsErrorKind::ResourceNotFoundException(_))
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for ListTagsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTagsErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            ListTagsErrorKind::MissingParameterValueException(_inner) => Some(_inner),
            ListTagsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListTagsErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListTagsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutBackupVaultAccessPolicyError {
    pub kind: PutBackupVaultAccessPolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutBackupVaultAccessPolicyErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    MissingParameterValueException(crate::error::MissingParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutBackupVaultAccessPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutBackupVaultAccessPolicyErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            PutBackupVaultAccessPolicyErrorKind::MissingParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            PutBackupVaultAccessPolicyErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            PutBackupVaultAccessPolicyErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            PutBackupVaultAccessPolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutBackupVaultAccessPolicyError {
    fn code(&self) -> Option<&str> {
        PutBackupVaultAccessPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutBackupVaultAccessPolicyError {
    pub fn new(kind: PutBackupVaultAccessPolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutBackupVaultAccessPolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutBackupVaultAccessPolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutBackupVaultAccessPolicyErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_missing_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutBackupVaultAccessPolicyErrorKind::MissingParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutBackupVaultAccessPolicyErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutBackupVaultAccessPolicyErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for PutBackupVaultAccessPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutBackupVaultAccessPolicyErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            PutBackupVaultAccessPolicyErrorKind::MissingParameterValueException(_inner) => {
                Some(_inner)
            }
            PutBackupVaultAccessPolicyErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            PutBackupVaultAccessPolicyErrorKind::ServiceUnavailableException(_inner) => {
                Some(_inner)
            }
            PutBackupVaultAccessPolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutBackupVaultNotificationsError {
    pub kind: PutBackupVaultNotificationsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutBackupVaultNotificationsErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    MissingParameterValueException(crate::error::MissingParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutBackupVaultNotificationsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutBackupVaultNotificationsErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            PutBackupVaultNotificationsErrorKind::MissingParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            PutBackupVaultNotificationsErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            PutBackupVaultNotificationsErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            PutBackupVaultNotificationsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutBackupVaultNotificationsError {
    fn code(&self) -> Option<&str> {
        PutBackupVaultNotificationsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutBackupVaultNotificationsError {
    pub fn new(kind: PutBackupVaultNotificationsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutBackupVaultNotificationsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutBackupVaultNotificationsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutBackupVaultNotificationsErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_missing_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutBackupVaultNotificationsErrorKind::MissingParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutBackupVaultNotificationsErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutBackupVaultNotificationsErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for PutBackupVaultNotificationsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutBackupVaultNotificationsErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            PutBackupVaultNotificationsErrorKind::MissingParameterValueException(_inner) => {
                Some(_inner)
            }
            PutBackupVaultNotificationsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            PutBackupVaultNotificationsErrorKind::ServiceUnavailableException(_inner) => {
                Some(_inner)
            }
            PutBackupVaultNotificationsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartBackupJobError {
    pub kind: StartBackupJobErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartBackupJobErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    InvalidRequestException(crate::error::InvalidRequestException),
    LimitExceededException(crate::error::LimitExceededException),
    MissingParameterValueException(crate::error::MissingParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StartBackupJobError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartBackupJobErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            StartBackupJobErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            StartBackupJobErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            StartBackupJobErrorKind::MissingParameterValueException(_inner) => _inner.fmt(f),
            StartBackupJobErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            StartBackupJobErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            StartBackupJobErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StartBackupJobError {
    fn code(&self) -> Option<&str> {
        StartBackupJobError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartBackupJobError {
    pub fn new(kind: StartBackupJobErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StartBackupJobErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StartBackupJobErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartBackupJobErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartBackupJobErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartBackupJobErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_missing_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartBackupJobErrorKind::MissingParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartBackupJobErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartBackupJobErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for StartBackupJobError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartBackupJobErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            StartBackupJobErrorKind::InvalidRequestException(_inner) => Some(_inner),
            StartBackupJobErrorKind::LimitExceededException(_inner) => Some(_inner),
            StartBackupJobErrorKind::MissingParameterValueException(_inner) => Some(_inner),
            StartBackupJobErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            StartBackupJobErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            StartBackupJobErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartCopyJobError {
    pub kind: StartCopyJobErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartCopyJobErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    InvalidRequestException(crate::error::InvalidRequestException),
    LimitExceededException(crate::error::LimitExceededException),
    MissingParameterValueException(crate::error::MissingParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StartCopyJobError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartCopyJobErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            StartCopyJobErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            StartCopyJobErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            StartCopyJobErrorKind::MissingParameterValueException(_inner) => _inner.fmt(f),
            StartCopyJobErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            StartCopyJobErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            StartCopyJobErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StartCopyJobError {
    fn code(&self) -> Option<&str> {
        StartCopyJobError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartCopyJobError {
    pub fn new(kind: StartCopyJobErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StartCopyJobErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StartCopyJobErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartCopyJobErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartCopyJobErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, StartCopyJobErrorKind::LimitExceededException(_))
    }
    pub fn is_missing_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartCopyJobErrorKind::MissingParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartCopyJobErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartCopyJobErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for StartCopyJobError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartCopyJobErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            StartCopyJobErrorKind::InvalidRequestException(_inner) => Some(_inner),
            StartCopyJobErrorKind::LimitExceededException(_inner) => Some(_inner),
            StartCopyJobErrorKind::MissingParameterValueException(_inner) => Some(_inner),
            StartCopyJobErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            StartCopyJobErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            StartCopyJobErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartReportJobError {
    pub kind: StartReportJobErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartReportJobErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    MissingParameterValueException(crate::error::MissingParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StartReportJobError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartReportJobErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            StartReportJobErrorKind::MissingParameterValueException(_inner) => _inner.fmt(f),
            StartReportJobErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            StartReportJobErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            StartReportJobErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StartReportJobError {
    fn code(&self) -> Option<&str> {
        StartReportJobError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartReportJobError {
    pub fn new(kind: StartReportJobErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StartReportJobErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StartReportJobErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartReportJobErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_missing_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartReportJobErrorKind::MissingParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartReportJobErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartReportJobErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for StartReportJobError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartReportJobErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            StartReportJobErrorKind::MissingParameterValueException(_inner) => Some(_inner),
            StartReportJobErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            StartReportJobErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            StartReportJobErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartRestoreJobError {
    pub kind: StartRestoreJobErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartRestoreJobErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    MissingParameterValueException(crate::error::MissingParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StartRestoreJobError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartRestoreJobErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            StartRestoreJobErrorKind::MissingParameterValueException(_inner) => _inner.fmt(f),
            StartRestoreJobErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            StartRestoreJobErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            StartRestoreJobErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StartRestoreJobError {
    fn code(&self) -> Option<&str> {
        StartRestoreJobError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartRestoreJobError {
    pub fn new(kind: StartRestoreJobErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StartRestoreJobErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StartRestoreJobErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartRestoreJobErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_missing_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartRestoreJobErrorKind::MissingParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartRestoreJobErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartRestoreJobErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for StartRestoreJobError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartRestoreJobErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            StartRestoreJobErrorKind::MissingParameterValueException(_inner) => Some(_inner),
            StartRestoreJobErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            StartRestoreJobErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            StartRestoreJobErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StopBackupJobError {
    pub kind: StopBackupJobErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StopBackupJobErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    InvalidRequestException(crate::error::InvalidRequestException),
    MissingParameterValueException(crate::error::MissingParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StopBackupJobError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StopBackupJobErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            StopBackupJobErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            StopBackupJobErrorKind::MissingParameterValueException(_inner) => _inner.fmt(f),
            StopBackupJobErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            StopBackupJobErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            StopBackupJobErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StopBackupJobError {
    fn code(&self) -> Option<&str> {
        StopBackupJobError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StopBackupJobError {
    pub fn new(kind: StopBackupJobErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StopBackupJobErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StopBackupJobErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopBackupJobErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopBackupJobErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_missing_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopBackupJobErrorKind::MissingParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopBackupJobErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopBackupJobErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for StopBackupJobError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StopBackupJobErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            StopBackupJobErrorKind::InvalidRequestException(_inner) => Some(_inner),
            StopBackupJobErrorKind::MissingParameterValueException(_inner) => Some(_inner),
            StopBackupJobErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            StopBackupJobErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            StopBackupJobErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TagResourceError {
    pub kind: TagResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TagResourceErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    LimitExceededException(crate::error::LimitExceededException),
    MissingParameterValueException(crate::error::MissingParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TagResourceErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::MissingParameterValueException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for TagResourceError {
    fn code(&self) -> Option<&str> {
        TagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl TagResourceError {
    pub fn new(kind: TagResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagResourceErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::LimitExceededException(_))
    }
    pub fn is_missing_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagResourceErrorKind::MissingParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagResourceErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagResourceErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for TagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TagResourceErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            TagResourceErrorKind::LimitExceededException(_inner) => Some(_inner),
            TagResourceErrorKind::MissingParameterValueException(_inner) => Some(_inner),
            TagResourceErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            TagResourceErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            TagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UntagResourceError {
    pub kind: UntagResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UntagResourceErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    MissingParameterValueException(crate::error::MissingParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UntagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UntagResourceErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::MissingParameterValueException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UntagResourceError {
    fn code(&self) -> Option<&str> {
        UntagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UntagResourceError {
    pub fn new(kind: UntagResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UntagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UntagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_missing_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::MissingParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for UntagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UntagResourceErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            UntagResourceErrorKind::MissingParameterValueException(_inner) => Some(_inner),
            UntagResourceErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UntagResourceErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            UntagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateBackupPlanError {
    pub kind: UpdateBackupPlanErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateBackupPlanErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    MissingParameterValueException(crate::error::MissingParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateBackupPlanError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateBackupPlanErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            UpdateBackupPlanErrorKind::MissingParameterValueException(_inner) => _inner.fmt(f),
            UpdateBackupPlanErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateBackupPlanErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            UpdateBackupPlanErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateBackupPlanError {
    fn code(&self) -> Option<&str> {
        UpdateBackupPlanError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateBackupPlanError {
    pub fn new(kind: UpdateBackupPlanErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateBackupPlanErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateBackupPlanErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateBackupPlanErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_missing_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateBackupPlanErrorKind::MissingParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateBackupPlanErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateBackupPlanErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for UpdateBackupPlanError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateBackupPlanErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            UpdateBackupPlanErrorKind::MissingParameterValueException(_inner) => Some(_inner),
            UpdateBackupPlanErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateBackupPlanErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            UpdateBackupPlanErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateFrameworkError {
    pub kind: UpdateFrameworkErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateFrameworkErrorKind {
    ConflictException(crate::error::ConflictException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    LimitExceededException(crate::error::LimitExceededException),
    MissingParameterValueException(crate::error::MissingParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateFrameworkError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateFrameworkErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateFrameworkErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            UpdateFrameworkErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            UpdateFrameworkErrorKind::MissingParameterValueException(_inner) => _inner.fmt(f),
            UpdateFrameworkErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateFrameworkErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            UpdateFrameworkErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateFrameworkError {
    fn code(&self) -> Option<&str> {
        UpdateFrameworkError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateFrameworkError {
    pub fn new(kind: UpdateFrameworkErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateFrameworkErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateFrameworkErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, UpdateFrameworkErrorKind::ConflictException(_))
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFrameworkErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFrameworkErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_missing_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFrameworkErrorKind::MissingParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFrameworkErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFrameworkErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for UpdateFrameworkError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateFrameworkErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateFrameworkErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            UpdateFrameworkErrorKind::LimitExceededException(_inner) => Some(_inner),
            UpdateFrameworkErrorKind::MissingParameterValueException(_inner) => Some(_inner),
            UpdateFrameworkErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateFrameworkErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            UpdateFrameworkErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateGlobalSettingsError {
    pub kind: UpdateGlobalSettingsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateGlobalSettingsErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    InvalidRequestException(crate::error::InvalidRequestException),
    MissingParameterValueException(crate::error::MissingParameterValueException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateGlobalSettingsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateGlobalSettingsErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            UpdateGlobalSettingsErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            UpdateGlobalSettingsErrorKind::MissingParameterValueException(_inner) => _inner.fmt(f),
            UpdateGlobalSettingsErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            UpdateGlobalSettingsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateGlobalSettingsError {
    fn code(&self) -> Option<&str> {
        UpdateGlobalSettingsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateGlobalSettingsError {
    pub fn new(kind: UpdateGlobalSettingsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateGlobalSettingsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateGlobalSettingsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateGlobalSettingsErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateGlobalSettingsErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_missing_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateGlobalSettingsErrorKind::MissingParameterValueException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateGlobalSettingsErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for UpdateGlobalSettingsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateGlobalSettingsErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            UpdateGlobalSettingsErrorKind::InvalidRequestException(_inner) => Some(_inner),
            UpdateGlobalSettingsErrorKind::MissingParameterValueException(_inner) => Some(_inner),
            UpdateGlobalSettingsErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            UpdateGlobalSettingsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateRecoveryPointLifecycleError {
    pub kind: UpdateRecoveryPointLifecycleErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateRecoveryPointLifecycleErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    MissingParameterValueException(crate::error::MissingParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateRecoveryPointLifecycleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateRecoveryPointLifecycleErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            UpdateRecoveryPointLifecycleErrorKind::MissingParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            UpdateRecoveryPointLifecycleErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            UpdateRecoveryPointLifecycleErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            UpdateRecoveryPointLifecycleErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateRecoveryPointLifecycleError {
    fn code(&self) -> Option<&str> {
        UpdateRecoveryPointLifecycleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateRecoveryPointLifecycleError {
    pub fn new(kind: UpdateRecoveryPointLifecycleErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateRecoveryPointLifecycleErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateRecoveryPointLifecycleErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRecoveryPointLifecycleErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_missing_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRecoveryPointLifecycleErrorKind::MissingParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRecoveryPointLifecycleErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRecoveryPointLifecycleErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for UpdateRecoveryPointLifecycleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateRecoveryPointLifecycleErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            UpdateRecoveryPointLifecycleErrorKind::MissingParameterValueException(_inner) => {
                Some(_inner)
            }
            UpdateRecoveryPointLifecycleErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            UpdateRecoveryPointLifecycleErrorKind::ServiceUnavailableException(_inner) => {
                Some(_inner)
            }
            UpdateRecoveryPointLifecycleErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateRegionSettingsError {
    pub kind: UpdateRegionSettingsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateRegionSettingsErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    MissingParameterValueException(crate::error::MissingParameterValueException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateRegionSettingsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateRegionSettingsErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            UpdateRegionSettingsErrorKind::MissingParameterValueException(_inner) => _inner.fmt(f),
            UpdateRegionSettingsErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            UpdateRegionSettingsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateRegionSettingsError {
    fn code(&self) -> Option<&str> {
        UpdateRegionSettingsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateRegionSettingsError {
    pub fn new(kind: UpdateRegionSettingsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateRegionSettingsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateRegionSettingsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRegionSettingsErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_missing_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRegionSettingsErrorKind::MissingParameterValueException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRegionSettingsErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for UpdateRegionSettingsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateRegionSettingsErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            UpdateRegionSettingsErrorKind::MissingParameterValueException(_inner) => Some(_inner),
            UpdateRegionSettingsErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            UpdateRegionSettingsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateReportPlanError {
    pub kind: UpdateReportPlanErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateReportPlanErrorKind {
    ConflictException(crate::error::ConflictException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    MissingParameterValueException(crate::error::MissingParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateReportPlanError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateReportPlanErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateReportPlanErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            UpdateReportPlanErrorKind::MissingParameterValueException(_inner) => _inner.fmt(f),
            UpdateReportPlanErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateReportPlanErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            UpdateReportPlanErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateReportPlanError {
    fn code(&self) -> Option<&str> {
        UpdateReportPlanError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateReportPlanError {
    pub fn new(kind: UpdateReportPlanErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateReportPlanErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateReportPlanErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, UpdateReportPlanErrorKind::ConflictException(_))
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateReportPlanErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_missing_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateReportPlanErrorKind::MissingParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateReportPlanErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateReportPlanErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for UpdateReportPlanError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateReportPlanErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateReportPlanErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            UpdateReportPlanErrorKind::MissingParameterValueException(_inner) => Some(_inner),
            UpdateReportPlanErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateReportPlanErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            UpdateReportPlanErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// <p>The request failed due to a temporary failure of the server.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ServiceUnavailableException {
    pub code: std::option::Option<std::string::String>,
    pub message: std::option::Option<std::string::String>,
    /// <p></p>
    pub r#type: std::option::Option<std::string::String>,
    /// <p></p>
    pub context: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ServiceUnavailableException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ServiceUnavailableException");
        formatter.field("code", &self.code);
        formatter.field("message", &self.message);
        formatter.field("r#type", &self.r#type);
        formatter.field("context", &self.context);
        formatter.finish()
    }
}
impl ServiceUnavailableException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ServiceUnavailableException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ServiceUnavailableException")?;
        if let Some(inner_1) = &self.message {
            write!(f, ": {}", inner_1)?;
        }
        Ok(())
    }
}
impl std::error::Error for ServiceUnavailableException {}
/// See [`ServiceUnavailableException`](crate::error::ServiceUnavailableException)
pub mod service_unavailable_exception {
    /// A builder for [`ServiceUnavailableException`](crate::error::ServiceUnavailableException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) context: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p></p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// <p></p>
        pub fn context(mut self, input: impl Into<std::string::String>) -> Self {
            self.context = Some(input.into());
            self
        }
        pub fn set_context(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.context = input;
            self
        }
        /// Consumes the builder and constructs a [`ServiceUnavailableException`](crate::error::ServiceUnavailableException)
        pub fn build(self) -> crate::error::ServiceUnavailableException {
            crate::error::ServiceUnavailableException {
                code: self.code,
                message: self.message,
                r#type: self.r#type,
                context: self.context,
            }
        }
    }
}
impl ServiceUnavailableException {
    /// Creates a new builder-style object to manufacture [`ServiceUnavailableException`](crate::error::ServiceUnavailableException)
    pub fn builder() -> crate::error::service_unavailable_exception::Builder {
        crate::error::service_unavailable_exception::Builder::default()
    }
}

/// <p>A resource that is required for the action doesn't exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceNotFoundException {
    pub code: std::option::Option<std::string::String>,
    pub message: std::option::Option<std::string::String>,
    /// <p></p>
    pub r#type: std::option::Option<std::string::String>,
    /// <p></p>
    pub context: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceNotFoundException");
        formatter.field("code", &self.code);
        formatter.field("message", &self.message);
        formatter.field("r#type", &self.r#type);
        formatter.field("context", &self.context);
        formatter.finish()
    }
}
impl ResourceNotFoundException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceNotFoundException")?;
        if let Some(inner_2) = &self.message {
            write!(f, ": {}", inner_2)?;
        }
        Ok(())
    }
}
impl std::error::Error for ResourceNotFoundException {}
/// See [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
pub mod resource_not_found_exception {
    /// A builder for [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) context: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p></p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// <p></p>
        pub fn context(mut self, input: impl Into<std::string::String>) -> Self {
            self.context = Some(input.into());
            self
        }
        pub fn set_context(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.context = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
        pub fn build(self) -> crate::error::ResourceNotFoundException {
            crate::error::ResourceNotFoundException {
                code: self.code,
                message: self.message,
                r#type: self.r#type,
                context: self.context,
            }
        }
    }
}
impl ResourceNotFoundException {
    /// Creates a new builder-style object to manufacture [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
    pub fn builder() -> crate::error::resource_not_found_exception::Builder {
        crate::error::resource_not_found_exception::Builder::default()
    }
}

/// <p>Indicates that a required parameter is missing.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MissingParameterValueException {
    pub code: std::option::Option<std::string::String>,
    pub message: std::option::Option<std::string::String>,
    /// <p></p>
    pub r#type: std::option::Option<std::string::String>,
    /// <p></p>
    pub context: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MissingParameterValueException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MissingParameterValueException");
        formatter.field("code", &self.code);
        formatter.field("message", &self.message);
        formatter.field("r#type", &self.r#type);
        formatter.field("context", &self.context);
        formatter.finish()
    }
}
impl MissingParameterValueException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for MissingParameterValueException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "MissingParameterValueException")?;
        if let Some(inner_3) = &self.message {
            write!(f, ": {}", inner_3)?;
        }
        Ok(())
    }
}
impl std::error::Error for MissingParameterValueException {}
/// See [`MissingParameterValueException`](crate::error::MissingParameterValueException)
pub mod missing_parameter_value_exception {
    /// A builder for [`MissingParameterValueException`](crate::error::MissingParameterValueException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) context: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p></p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// <p></p>
        pub fn context(mut self, input: impl Into<std::string::String>) -> Self {
            self.context = Some(input.into());
            self
        }
        pub fn set_context(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.context = input;
            self
        }
        /// Consumes the builder and constructs a [`MissingParameterValueException`](crate::error::MissingParameterValueException)
        pub fn build(self) -> crate::error::MissingParameterValueException {
            crate::error::MissingParameterValueException {
                code: self.code,
                message: self.message,
                r#type: self.r#type,
                context: self.context,
            }
        }
    }
}
impl MissingParameterValueException {
    /// Creates a new builder-style object to manufacture [`MissingParameterValueException`](crate::error::MissingParameterValueException)
    pub fn builder() -> crate::error::missing_parameter_value_exception::Builder {
        crate::error::missing_parameter_value_exception::Builder::default()
    }
}

/// <p>Indicates that something is wrong with a parameter's value. For example, the value is
/// out of range.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidParameterValueException {
    pub code: std::option::Option<std::string::String>,
    pub message: std::option::Option<std::string::String>,
    /// <p></p>
    pub r#type: std::option::Option<std::string::String>,
    /// <p></p>
    pub context: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidParameterValueException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidParameterValueException");
        formatter.field("code", &self.code);
        formatter.field("message", &self.message);
        formatter.field("r#type", &self.r#type);
        formatter.field("context", &self.context);
        formatter.finish()
    }
}
impl InvalidParameterValueException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidParameterValueException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidParameterValueException")?;
        if let Some(inner_4) = &self.message {
            write!(f, ": {}", inner_4)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidParameterValueException {}
/// See [`InvalidParameterValueException`](crate::error::InvalidParameterValueException)
pub mod invalid_parameter_value_exception {
    /// A builder for [`InvalidParameterValueException`](crate::error::InvalidParameterValueException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) context: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p></p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// <p></p>
        pub fn context(mut self, input: impl Into<std::string::String>) -> Self {
            self.context = Some(input.into());
            self
        }
        pub fn set_context(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.context = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidParameterValueException`](crate::error::InvalidParameterValueException)
        pub fn build(self) -> crate::error::InvalidParameterValueException {
            crate::error::InvalidParameterValueException {
                code: self.code,
                message: self.message,
                r#type: self.r#type,
                context: self.context,
            }
        }
    }
}
impl InvalidParameterValueException {
    /// Creates a new builder-style object to manufacture [`InvalidParameterValueException`](crate::error::InvalidParameterValueException)
    pub fn builder() -> crate::error::invalid_parameter_value_exception::Builder {
        crate::error::invalid_parameter_value_exception::Builder::default()
    }
}

/// <p>Backup can't perform the action that you requested until it finishes
/// performing a previous action. Try again later.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ConflictException {
    pub code: std::option::Option<std::string::String>,
    pub message: std::option::Option<std::string::String>,
    pub r#type: std::option::Option<std::string::String>,
    pub context: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ConflictException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ConflictException");
        formatter.field("code", &self.code);
        formatter.field("message", &self.message);
        formatter.field("r#type", &self.r#type);
        formatter.field("context", &self.context);
        formatter.finish()
    }
}
impl ConflictException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ConflictException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ConflictException")?;
        if let Some(inner_5) = &self.message {
            write!(f, ": {}", inner_5)?;
        }
        Ok(())
    }
}
impl std::error::Error for ConflictException {}
/// See [`ConflictException`](crate::error::ConflictException)
pub mod conflict_exception {
    /// A builder for [`ConflictException`](crate::error::ConflictException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) context: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        pub fn context(mut self, input: impl Into<std::string::String>) -> Self {
            self.context = Some(input.into());
            self
        }
        pub fn set_context(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.context = input;
            self
        }
        /// Consumes the builder and constructs a [`ConflictException`](crate::error::ConflictException)
        pub fn build(self) -> crate::error::ConflictException {
            crate::error::ConflictException {
                code: self.code,
                message: self.message,
                r#type: self.r#type,
                context: self.context,
            }
        }
    }
}
impl ConflictException {
    /// Creates a new builder-style object to manufacture [`ConflictException`](crate::error::ConflictException)
    pub fn builder() -> crate::error::conflict_exception::Builder {
        crate::error::conflict_exception::Builder::default()
    }
}

/// <p>Indicates that something is wrong with the input to the request. For example, a
/// parameter is of the wrong type.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidRequestException {
    pub code: std::option::Option<std::string::String>,
    pub message: std::option::Option<std::string::String>,
    /// <p></p>
    pub r#type: std::option::Option<std::string::String>,
    /// <p></p>
    pub context: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidRequestException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidRequestException");
        formatter.field("code", &self.code);
        formatter.field("message", &self.message);
        formatter.field("r#type", &self.r#type);
        formatter.field("context", &self.context);
        formatter.finish()
    }
}
impl InvalidRequestException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidRequestException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidRequestException")?;
        if let Some(inner_6) = &self.message {
            write!(f, ": {}", inner_6)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidRequestException {}
/// See [`InvalidRequestException`](crate::error::InvalidRequestException)
pub mod invalid_request_exception {
    /// A builder for [`InvalidRequestException`](crate::error::InvalidRequestException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) context: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p></p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// <p></p>
        pub fn context(mut self, input: impl Into<std::string::String>) -> Self {
            self.context = Some(input.into());
            self
        }
        pub fn set_context(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.context = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidRequestException`](crate::error::InvalidRequestException)
        pub fn build(self) -> crate::error::InvalidRequestException {
            crate::error::InvalidRequestException {
                code: self.code,
                message: self.message,
                r#type: self.r#type,
                context: self.context,
            }
        }
    }
}
impl InvalidRequestException {
    /// Creates a new builder-style object to manufacture [`InvalidRequestException`](crate::error::InvalidRequestException)
    pub fn builder() -> crate::error::invalid_request_exception::Builder {
        crate::error::invalid_request_exception::Builder::default()
    }
}

/// <p>A limit in the request has been exceeded; for example, a maximum number of items allowed
/// in a request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LimitExceededException {
    pub code: std::option::Option<std::string::String>,
    pub message: std::option::Option<std::string::String>,
    /// <p></p>
    pub r#type: std::option::Option<std::string::String>,
    /// <p></p>
    pub context: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for LimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LimitExceededException");
        formatter.field("code", &self.code);
        formatter.field("message", &self.message);
        formatter.field("r#type", &self.r#type);
        formatter.field("context", &self.context);
        formatter.finish()
    }
}
impl LimitExceededException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for LimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "LimitExceededException")?;
        if let Some(inner_7) = &self.message {
            write!(f, ": {}", inner_7)?;
        }
        Ok(())
    }
}
impl std::error::Error for LimitExceededException {}
/// See [`LimitExceededException`](crate::error::LimitExceededException)
pub mod limit_exceeded_exception {
    /// A builder for [`LimitExceededException`](crate::error::LimitExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) context: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p></p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// <p></p>
        pub fn context(mut self, input: impl Into<std::string::String>) -> Self {
            self.context = Some(input.into());
            self
        }
        pub fn set_context(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.context = input;
            self
        }
        /// Consumes the builder and constructs a [`LimitExceededException`](crate::error::LimitExceededException)
        pub fn build(self) -> crate::error::LimitExceededException {
            crate::error::LimitExceededException {
                code: self.code,
                message: self.message,
                r#type: self.r#type,
                context: self.context,
            }
        }
    }
}
impl LimitExceededException {
    /// Creates a new builder-style object to manufacture [`LimitExceededException`](crate::error::LimitExceededException)
    pub fn builder() -> crate::error::limit_exceeded_exception::Builder {
        crate::error::limit_exceeded_exception::Builder::default()
    }
}

/// <p>Backup is already performing an action on this recovery point. It can't
/// perform the action you requested until the first action finishes. Try again later.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidResourceStateException {
    pub code: std::option::Option<std::string::String>,
    pub message: std::option::Option<std::string::String>,
    /// <p></p>
    pub r#type: std::option::Option<std::string::String>,
    /// <p></p>
    pub context: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidResourceStateException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidResourceStateException");
        formatter.field("code", &self.code);
        formatter.field("message", &self.message);
        formatter.field("r#type", &self.r#type);
        formatter.field("context", &self.context);
        formatter.finish()
    }
}
impl InvalidResourceStateException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidResourceStateException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidResourceStateException")?;
        if let Some(inner_8) = &self.message {
            write!(f, ": {}", inner_8)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidResourceStateException {}
/// See [`InvalidResourceStateException`](crate::error::InvalidResourceStateException)
pub mod invalid_resource_state_exception {
    /// A builder for [`InvalidResourceStateException`](crate::error::InvalidResourceStateException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) context: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p></p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// <p></p>
        pub fn context(mut self, input: impl Into<std::string::String>) -> Self {
            self.context = Some(input.into());
            self
        }
        pub fn set_context(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.context = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidResourceStateException`](crate::error::InvalidResourceStateException)
        pub fn build(self) -> crate::error::InvalidResourceStateException {
            crate::error::InvalidResourceStateException {
                code: self.code,
                message: self.message,
                r#type: self.r#type,
                context: self.context,
            }
        }
    }
}
impl InvalidResourceStateException {
    /// Creates a new builder-style object to manufacture [`InvalidResourceStateException`](crate::error::InvalidResourceStateException)
    pub fn builder() -> crate::error::invalid_resource_state_exception::Builder {
        crate::error::invalid_resource_state_exception::Builder::default()
    }
}

/// <p>A dependent Amazon Web Services service or resource returned an error to the Backup service, and the action cannot be completed.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DependencyFailureException {
    pub code: std::option::Option<std::string::String>,
    pub message: std::option::Option<std::string::String>,
    /// <p></p>
    pub r#type: std::option::Option<std::string::String>,
    /// <p></p>
    pub context: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DependencyFailureException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DependencyFailureException");
        formatter.field("code", &self.code);
        formatter.field("message", &self.message);
        formatter.field("r#type", &self.r#type);
        formatter.field("context", &self.context);
        formatter.finish()
    }
}
impl DependencyFailureException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DependencyFailureException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DependencyFailureException")?;
        if let Some(inner_9) = &self.message {
            write!(f, ": {}", inner_9)?;
        }
        Ok(())
    }
}
impl std::error::Error for DependencyFailureException {}
/// See [`DependencyFailureException`](crate::error::DependencyFailureException)
pub mod dependency_failure_exception {
    /// A builder for [`DependencyFailureException`](crate::error::DependencyFailureException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) context: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p></p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// <p></p>
        pub fn context(mut self, input: impl Into<std::string::String>) -> Self {
            self.context = Some(input.into());
            self
        }
        pub fn set_context(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.context = input;
            self
        }
        /// Consumes the builder and constructs a [`DependencyFailureException`](crate::error::DependencyFailureException)
        pub fn build(self) -> crate::error::DependencyFailureException {
            crate::error::DependencyFailureException {
                code: self.code,
                message: self.message,
                r#type: self.r#type,
                context: self.context,
            }
        }
    }
}
impl DependencyFailureException {
    /// Creates a new builder-style object to manufacture [`DependencyFailureException`](crate::error::DependencyFailureException)
    pub fn builder() -> crate::error::dependency_failure_exception::Builder {
        crate::error::dependency_failure_exception::Builder::default()
    }
}

/// <p>The required resource already exists.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AlreadyExistsException {
    pub code: std::option::Option<std::string::String>,
    pub message: std::option::Option<std::string::String>,
    /// <p></p>
    pub creator_request_id: std::option::Option<std::string::String>,
    /// <p></p>
    pub arn: std::option::Option<std::string::String>,
    /// <p></p>
    pub r#type: std::option::Option<std::string::String>,
    /// <p></p>
    pub context: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AlreadyExistsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AlreadyExistsException");
        formatter.field("code", &self.code);
        formatter.field("message", &self.message);
        formatter.field("creator_request_id", &self.creator_request_id);
        formatter.field("arn", &self.arn);
        formatter.field("r#type", &self.r#type);
        formatter.field("context", &self.context);
        formatter.finish()
    }
}
impl AlreadyExistsException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for AlreadyExistsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "AlreadyExistsException")?;
        if let Some(inner_10) = &self.message {
            write!(f, ": {}", inner_10)?;
        }
        Ok(())
    }
}
impl std::error::Error for AlreadyExistsException {}
/// See [`AlreadyExistsException`](crate::error::AlreadyExistsException)
pub mod already_exists_exception {
    /// A builder for [`AlreadyExistsException`](crate::error::AlreadyExistsException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) creator_request_id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) context: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p></p>
        pub fn creator_request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.creator_request_id = Some(input.into());
            self
        }
        pub fn set_creator_request_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.creator_request_id = input;
            self
        }
        /// <p></p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p></p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// <p></p>
        pub fn context(mut self, input: impl Into<std::string::String>) -> Self {
            self.context = Some(input.into());
            self
        }
        pub fn set_context(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.context = input;
            self
        }
        /// Consumes the builder and constructs a [`AlreadyExistsException`](crate::error::AlreadyExistsException)
        pub fn build(self) -> crate::error::AlreadyExistsException {
            crate::error::AlreadyExistsException {
                code: self.code,
                message: self.message,
                creator_request_id: self.creator_request_id,
                arn: self.arn,
                r#type: self.r#type,
                context: self.context,
            }
        }
    }
}
impl AlreadyExistsException {
    /// Creates a new builder-style object to manufacture [`AlreadyExistsException`](crate::error::AlreadyExistsException)
    pub fn builder() -> crate::error::already_exists_exception::Builder {
        crate::error::already_exists_exception::Builder::default()
    }
}
