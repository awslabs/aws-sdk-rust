// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// <p>Creates a backup plan using a backup plan name and backup rules. A backup plan is a
/// document that contains information that Backup uses to schedule tasks that
/// create recovery points for resources.</p>
/// <p>If you call <code>CreateBackupPlan</code> with a plan that already exists, you receive
/// an <code>AlreadyExistsException</code> exception.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateBackupPlan {
    _private: (),
}
impl CreateBackupPlan {
    /// Creates a new builder-style object to manufacture [`CreateBackupPlanInput`](crate::input::CreateBackupPlanInput)
    pub fn builder() -> crate::input::create_backup_plan_input::Builder {
        crate::input::create_backup_plan_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateBackupPlan {
    type Output = std::result::Result<
        crate::output::CreateBackupPlanOutput,
        crate::error::CreateBackupPlanError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_backup_plan_error(response)
        } else {
            crate::operation_deser::parse_create_backup_plan_response(response)
        }
    }
}

/// <p>Creates a JSON document that specifies a set of resources to assign to a backup plan.
/// Resources can be included by specifying patterns for a <code>ListOfTags</code> and selected
/// <code>Resources</code>. </p>
/// <p>For example, consider the following patterns:</p>
/// <ul>
/// <li>
/// <p>
/// <code>Resources: "arn:aws:ec2:region:account-id:volume/volume-id"</code>
/// </p>
/// </li>
/// <li>
/// <p>
/// <code>ConditionKey:"department"</code>
/// </p>
/// <p>
/// <code>ConditionValue:"finance"</code>
/// </p>
/// <p>
/// <code>ConditionType:"StringEquals"</code>
/// </p>
/// </li>
/// <li>
/// <p>
/// <code>ConditionKey:"importance"</code>
/// </p>
/// <p>
/// <code>ConditionValue:"critical"</code>
/// </p>
/// <p>
/// <code>ConditionType:"StringEquals"</code>
/// </p>
/// </li>
/// </ul>
/// <p>Using these patterns would back up all Amazon Elastic Block Store (Amazon EBS)
/// volumes that are tagged as <code>"department=finance"</code>,
/// <code>"importance=critical"</code>, in addition to an EBS volume with the specified
/// volume ID.</p>
/// <p>Resources and conditions are additive in that all resources that match the pattern are
/// selected. This shouldn't be confused with a logical AND, where all conditions must match.
/// The matching patterns are logically put together using the OR operator.
/// In other words, all patterns that match are selected for backup.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateBackupSelection {
    _private: (),
}
impl CreateBackupSelection {
    /// Creates a new builder-style object to manufacture [`CreateBackupSelectionInput`](crate::input::CreateBackupSelectionInput)
    pub fn builder() -> crate::input::create_backup_selection_input::Builder {
        crate::input::create_backup_selection_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateBackupSelection {
    type Output = std::result::Result<
        crate::output::CreateBackupSelectionOutput,
        crate::error::CreateBackupSelectionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_backup_selection_error(response)
        } else {
            crate::operation_deser::parse_create_backup_selection_response(response)
        }
    }
}

/// <p>Creates a logical container where backups are stored. A <code>CreateBackupVault</code>
/// request includes a name, optionally one or more resource tags, an encryption key, and a
/// request ID.</p>
/// <note>
/// <p>Do not include sensitive data, such as passport numbers, in the name of a backup
/// vault.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateBackupVault {
    _private: (),
}
impl CreateBackupVault {
    /// Creates a new builder-style object to manufacture [`CreateBackupVaultInput`](crate::input::CreateBackupVaultInput)
    pub fn builder() -> crate::input::create_backup_vault_input::Builder {
        crate::input::create_backup_vault_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateBackupVault {
    type Output = std::result::Result<
        crate::output::CreateBackupVaultOutput,
        crate::error::CreateBackupVaultError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_backup_vault_error(response)
        } else {
            crate::operation_deser::parse_create_backup_vault_response(response)
        }
    }
}

/// <p>Creates a framework with one or more controls. A framework is a collection of controls
/// that you can use to evaluate your backup practices. By using pre-built customizable
/// controls to define your policies, you can evaluate whether your backup practices comply
/// with your policies and which resources are not yet in compliance.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateFramework {
    _private: (),
}
impl CreateFramework {
    /// Creates a new builder-style object to manufacture [`CreateFrameworkInput`](crate::input::CreateFrameworkInput)
    pub fn builder() -> crate::input::create_framework_input::Builder {
        crate::input::create_framework_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateFramework {
    type Output = std::result::Result<
        crate::output::CreateFrameworkOutput,
        crate::error::CreateFrameworkError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_framework_error(response)
        } else {
            crate::operation_deser::parse_create_framework_response(response)
        }
    }
}

/// <p>Creates a report plan. A report plan is a document that contains information about the
/// contents of the report and where Backup will deliver it.</p>
/// <p>If you call <code>CreateReportPlan</code> with a plan that already exists, you receive
/// an <code>AlreadyExistsException</code> exception.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateReportPlan {
    _private: (),
}
impl CreateReportPlan {
    /// Creates a new builder-style object to manufacture [`CreateReportPlanInput`](crate::input::CreateReportPlanInput)
    pub fn builder() -> crate::input::create_report_plan_input::Builder {
        crate::input::create_report_plan_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateReportPlan {
    type Output = std::result::Result<
        crate::output::CreateReportPlanOutput,
        crate::error::CreateReportPlanError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_report_plan_error(response)
        } else {
            crate::operation_deser::parse_create_report_plan_response(response)
        }
    }
}

/// <p>Deletes a backup plan. A backup plan can only be deleted after all associated selections
/// of resources have been deleted. Deleting a backup plan deletes the current version of a
/// backup plan. Previous versions, if any, will still exist.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteBackupPlan {
    _private: (),
}
impl DeleteBackupPlan {
    /// Creates a new builder-style object to manufacture [`DeleteBackupPlanInput`](crate::input::DeleteBackupPlanInput)
    pub fn builder() -> crate::input::delete_backup_plan_input::Builder {
        crate::input::delete_backup_plan_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteBackupPlan {
    type Output = std::result::Result<
        crate::output::DeleteBackupPlanOutput,
        crate::error::DeleteBackupPlanError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_backup_plan_error(response)
        } else {
            crate::operation_deser::parse_delete_backup_plan_response(response)
        }
    }
}

/// <p>Deletes the resource selection associated with a backup plan that is specified by the
/// <code>SelectionId</code>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteBackupSelection {
    _private: (),
}
impl DeleteBackupSelection {
    /// Creates a new builder-style object to manufacture [`DeleteBackupSelectionInput`](crate::input::DeleteBackupSelectionInput)
    pub fn builder() -> crate::input::delete_backup_selection_input::Builder {
        crate::input::delete_backup_selection_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteBackupSelection {
    type Output = std::result::Result<
        crate::output::DeleteBackupSelectionOutput,
        crate::error::DeleteBackupSelectionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_backup_selection_error(response)
        } else {
            crate::operation_deser::parse_delete_backup_selection_response(response)
        }
    }
}

/// <p>Deletes the backup vault identified by its name. A vault can be deleted only if it is
/// empty.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteBackupVault {
    _private: (),
}
impl DeleteBackupVault {
    /// Creates a new builder-style object to manufacture [`DeleteBackupVaultInput`](crate::input::DeleteBackupVaultInput)
    pub fn builder() -> crate::input::delete_backup_vault_input::Builder {
        crate::input::delete_backup_vault_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteBackupVault {
    type Output = std::result::Result<
        crate::output::DeleteBackupVaultOutput,
        crate::error::DeleteBackupVaultError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_backup_vault_error(response)
        } else {
            crate::operation_deser::parse_delete_backup_vault_response(response)
        }
    }
}

/// <p>Deletes the policy document that manages permissions on a backup vault.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteBackupVaultAccessPolicy {
    _private: (),
}
impl DeleteBackupVaultAccessPolicy {
    /// Creates a new builder-style object to manufacture [`DeleteBackupVaultAccessPolicyInput`](crate::input::DeleteBackupVaultAccessPolicyInput)
    pub fn builder() -> crate::input::delete_backup_vault_access_policy_input::Builder {
        crate::input::delete_backup_vault_access_policy_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteBackupVaultAccessPolicy {
    type Output = std::result::Result<
        crate::output::DeleteBackupVaultAccessPolicyOutput,
        crate::error::DeleteBackupVaultAccessPolicyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_backup_vault_access_policy_error(response)
        } else {
            crate::operation_deser::parse_delete_backup_vault_access_policy_response(response)
        }
    }
}

/// <p>Deletes Backup Vault Lock from a backup vault specified by a backup vault
/// name.</p>
/// <p>If the Vault Lock configuration is immutable, then you cannot delete Vault Lock using
/// API operations, and you will receive an <code>InvalidRequestException</code> if you attempt
/// to do so. For more information, see <a href="https://docs.aws.amazon.com/aws-backup/latest/devguide/vault-lock.html">Vault Lock</a> in the
/// <i>Backup Developer Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteBackupVaultLockConfiguration {
    _private: (),
}
impl DeleteBackupVaultLockConfiguration {
    /// Creates a new builder-style object to manufacture [`DeleteBackupVaultLockConfigurationInput`](crate::input::DeleteBackupVaultLockConfigurationInput)
    pub fn builder() -> crate::input::delete_backup_vault_lock_configuration_input::Builder {
        crate::input::delete_backup_vault_lock_configuration_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteBackupVaultLockConfiguration {
    type Output = std::result::Result<
        crate::output::DeleteBackupVaultLockConfigurationOutput,
        crate::error::DeleteBackupVaultLockConfigurationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_backup_vault_lock_configuration_error(response)
        } else {
            crate::operation_deser::parse_delete_backup_vault_lock_configuration_response(response)
        }
    }
}

/// <p>Deletes event notifications for the specified backup vault.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteBackupVaultNotifications {
    _private: (),
}
impl DeleteBackupVaultNotifications {
    /// Creates a new builder-style object to manufacture [`DeleteBackupVaultNotificationsInput`](crate::input::DeleteBackupVaultNotificationsInput)
    pub fn builder() -> crate::input::delete_backup_vault_notifications_input::Builder {
        crate::input::delete_backup_vault_notifications_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteBackupVaultNotifications {
    type Output = std::result::Result<
        crate::output::DeleteBackupVaultNotificationsOutput,
        crate::error::DeleteBackupVaultNotificationsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_backup_vault_notifications_error(response)
        } else {
            crate::operation_deser::parse_delete_backup_vault_notifications_response(response)
        }
    }
}

/// <p>Deletes the framework specified by a framework name.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteFramework {
    _private: (),
}
impl DeleteFramework {
    /// Creates a new builder-style object to manufacture [`DeleteFrameworkInput`](crate::input::DeleteFrameworkInput)
    pub fn builder() -> crate::input::delete_framework_input::Builder {
        crate::input::delete_framework_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteFramework {
    type Output = std::result::Result<
        crate::output::DeleteFrameworkOutput,
        crate::error::DeleteFrameworkError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_framework_error(response)
        } else {
            crate::operation_deser::parse_delete_framework_response(response)
        }
    }
}

/// <p>Deletes the recovery point specified by a recovery point ID.</p>
/// <p>If the recovery point ID belongs to a continuous backup, calling this endpoint deletes
/// the existing continuous backup and stops future continuous backup.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteRecoveryPoint {
    _private: (),
}
impl DeleteRecoveryPoint {
    /// Creates a new builder-style object to manufacture [`DeleteRecoveryPointInput`](crate::input::DeleteRecoveryPointInput)
    pub fn builder() -> crate::input::delete_recovery_point_input::Builder {
        crate::input::delete_recovery_point_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteRecoveryPoint {
    type Output = std::result::Result<
        crate::output::DeleteRecoveryPointOutput,
        crate::error::DeleteRecoveryPointError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_recovery_point_error(response)
        } else {
            crate::operation_deser::parse_delete_recovery_point_response(response)
        }
    }
}

/// <p>Deletes the report plan specified by a report plan name.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteReportPlan {
    _private: (),
}
impl DeleteReportPlan {
    /// Creates a new builder-style object to manufacture [`DeleteReportPlanInput`](crate::input::DeleteReportPlanInput)
    pub fn builder() -> crate::input::delete_report_plan_input::Builder {
        crate::input::delete_report_plan_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteReportPlan {
    type Output = std::result::Result<
        crate::output::DeleteReportPlanOutput,
        crate::error::DeleteReportPlanError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_report_plan_error(response)
        } else {
            crate::operation_deser::parse_delete_report_plan_response(response)
        }
    }
}

/// <p>Returns backup job details for the specified <code>BackupJobId</code>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeBackupJob {
    _private: (),
}
impl DescribeBackupJob {
    /// Creates a new builder-style object to manufacture [`DescribeBackupJobInput`](crate::input::DescribeBackupJobInput)
    pub fn builder() -> crate::input::describe_backup_job_input::Builder {
        crate::input::describe_backup_job_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeBackupJob {
    type Output = std::result::Result<
        crate::output::DescribeBackupJobOutput,
        crate::error::DescribeBackupJobError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_backup_job_error(response)
        } else {
            crate::operation_deser::parse_describe_backup_job_response(response)
        }
    }
}

/// <p>Returns metadata about a backup vault specified by its name.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeBackupVault {
    _private: (),
}
impl DescribeBackupVault {
    /// Creates a new builder-style object to manufacture [`DescribeBackupVaultInput`](crate::input::DescribeBackupVaultInput)
    pub fn builder() -> crate::input::describe_backup_vault_input::Builder {
        crate::input::describe_backup_vault_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeBackupVault {
    type Output = std::result::Result<
        crate::output::DescribeBackupVaultOutput,
        crate::error::DescribeBackupVaultError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_backup_vault_error(response)
        } else {
            crate::operation_deser::parse_describe_backup_vault_response(response)
        }
    }
}

/// <p>Returns metadata associated with creating a copy of a resource.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeCopyJob {
    _private: (),
}
impl DescribeCopyJob {
    /// Creates a new builder-style object to manufacture [`DescribeCopyJobInput`](crate::input::DescribeCopyJobInput)
    pub fn builder() -> crate::input::describe_copy_job_input::Builder {
        crate::input::describe_copy_job_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeCopyJob {
    type Output = std::result::Result<
        crate::output::DescribeCopyJobOutput,
        crate::error::DescribeCopyJobError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_copy_job_error(response)
        } else {
            crate::operation_deser::parse_describe_copy_job_response(response)
        }
    }
}

/// <p>Returns the framework details for the specified <code>FrameworkName</code>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeFramework {
    _private: (),
}
impl DescribeFramework {
    /// Creates a new builder-style object to manufacture [`DescribeFrameworkInput`](crate::input::DescribeFrameworkInput)
    pub fn builder() -> crate::input::describe_framework_input::Builder {
        crate::input::describe_framework_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeFramework {
    type Output = std::result::Result<
        crate::output::DescribeFrameworkOutput,
        crate::error::DescribeFrameworkError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_framework_error(response)
        } else {
            crate::operation_deser::parse_describe_framework_response(response)
        }
    }
}

/// <p>Describes whether the Amazon Web Services account is opted in to cross-account backup.
/// Returns an error if the account is not a member of an Organizations organization.
/// Example: <code>describe-global-settings --region us-west-2</code>
/// </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeGlobalSettings {
    _private: (),
}
impl DescribeGlobalSettings {
    /// Creates a new builder-style object to manufacture [`DescribeGlobalSettingsInput`](crate::input::DescribeGlobalSettingsInput)
    pub fn builder() -> crate::input::describe_global_settings_input::Builder {
        crate::input::describe_global_settings_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeGlobalSettings {
    type Output = std::result::Result<
        crate::output::DescribeGlobalSettingsOutput,
        crate::error::DescribeGlobalSettingsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_global_settings_error(response)
        } else {
            crate::operation_deser::parse_describe_global_settings_response(response)
        }
    }
}

/// <p>Returns information about a saved resource, including the last time it was backed up,
/// its Amazon Resource Name (ARN), and the Amazon Web Services service type of the saved
/// resource.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeProtectedResource {
    _private: (),
}
impl DescribeProtectedResource {
    /// Creates a new builder-style object to manufacture [`DescribeProtectedResourceInput`](crate::input::DescribeProtectedResourceInput)
    pub fn builder() -> crate::input::describe_protected_resource_input::Builder {
        crate::input::describe_protected_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeProtectedResource {
    type Output = std::result::Result<
        crate::output::DescribeProtectedResourceOutput,
        crate::error::DescribeProtectedResourceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_protected_resource_error(response)
        } else {
            crate::operation_deser::parse_describe_protected_resource_response(response)
        }
    }
}

/// <p>Returns metadata associated with a recovery point, including ID, status, encryption, and
/// lifecycle.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeRecoveryPoint {
    _private: (),
}
impl DescribeRecoveryPoint {
    /// Creates a new builder-style object to manufacture [`DescribeRecoveryPointInput`](crate::input::DescribeRecoveryPointInput)
    pub fn builder() -> crate::input::describe_recovery_point_input::Builder {
        crate::input::describe_recovery_point_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeRecoveryPoint {
    type Output = std::result::Result<
        crate::output::DescribeRecoveryPointOutput,
        crate::error::DescribeRecoveryPointError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_recovery_point_error(response)
        } else {
            crate::operation_deser::parse_describe_recovery_point_response(response)
        }
    }
}

/// <p>Returns the current service opt-in settings for the Region. If service opt-in is enabled
/// for a service, Backup tries to protect that service's resources in this Region,
/// when the resource is included in an on-demand backup or scheduled backup plan. Otherwise,
/// Backup does not try to protect that service's resources in this
/// Region.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeRegionSettings {
    _private: (),
}
impl DescribeRegionSettings {
    /// Creates a new builder-style object to manufacture [`DescribeRegionSettingsInput`](crate::input::DescribeRegionSettingsInput)
    pub fn builder() -> crate::input::describe_region_settings_input::Builder {
        crate::input::describe_region_settings_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeRegionSettings {
    type Output = std::result::Result<
        crate::output::DescribeRegionSettingsOutput,
        crate::error::DescribeRegionSettingsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_region_settings_error(response)
        } else {
            crate::operation_deser::parse_describe_region_settings_response(response)
        }
    }
}

/// <p>Returns the details associated with creating a report as specified by its
/// <code>ReportJobId</code>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeReportJob {
    _private: (),
}
impl DescribeReportJob {
    /// Creates a new builder-style object to manufacture [`DescribeReportJobInput`](crate::input::DescribeReportJobInput)
    pub fn builder() -> crate::input::describe_report_job_input::Builder {
        crate::input::describe_report_job_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeReportJob {
    type Output = std::result::Result<
        crate::output::DescribeReportJobOutput,
        crate::error::DescribeReportJobError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_report_job_error(response)
        } else {
            crate::operation_deser::parse_describe_report_job_response(response)
        }
    }
}

/// <p>Returns a list of all report plans for an Amazon Web Services account and Amazon Web Services Region.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeReportPlan {
    _private: (),
}
impl DescribeReportPlan {
    /// Creates a new builder-style object to manufacture [`DescribeReportPlanInput`](crate::input::DescribeReportPlanInput)
    pub fn builder() -> crate::input::describe_report_plan_input::Builder {
        crate::input::describe_report_plan_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeReportPlan {
    type Output = std::result::Result<
        crate::output::DescribeReportPlanOutput,
        crate::error::DescribeReportPlanError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_report_plan_error(response)
        } else {
            crate::operation_deser::parse_describe_report_plan_response(response)
        }
    }
}

/// <p>Returns metadata associated with a restore job that is specified by a job ID.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeRestoreJob {
    _private: (),
}
impl DescribeRestoreJob {
    /// Creates a new builder-style object to manufacture [`DescribeRestoreJobInput`](crate::input::DescribeRestoreJobInput)
    pub fn builder() -> crate::input::describe_restore_job_input::Builder {
        crate::input::describe_restore_job_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeRestoreJob {
    type Output = std::result::Result<
        crate::output::DescribeRestoreJobOutput,
        crate::error::DescribeRestoreJobError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_restore_job_error(response)
        } else {
            crate::operation_deser::parse_describe_restore_job_response(response)
        }
    }
}

/// <p>Deletes the specified continuous backup recovery point from Backup and
/// releases control of that continuous backup to the source service, such as Amazon RDS. The source service will continue to create and retain continuous backups using the
/// lifecycle that you specified in your original backup plan.</p>
/// <p>Does not support snapshot backup recovery points.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DisassociateRecoveryPoint {
    _private: (),
}
impl DisassociateRecoveryPoint {
    /// Creates a new builder-style object to manufacture [`DisassociateRecoveryPointInput`](crate::input::DisassociateRecoveryPointInput)
    pub fn builder() -> crate::input::disassociate_recovery_point_input::Builder {
        crate::input::disassociate_recovery_point_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DisassociateRecoveryPoint {
    type Output = std::result::Result<
        crate::output::DisassociateRecoveryPointOutput,
        crate::error::DisassociateRecoveryPointError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_disassociate_recovery_point_error(response)
        } else {
            crate::operation_deser::parse_disassociate_recovery_point_response(response)
        }
    }
}

/// <p>Returns the backup plan that is specified by the plan ID as a backup template.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ExportBackupPlanTemplate {
    _private: (),
}
impl ExportBackupPlanTemplate {
    /// Creates a new builder-style object to manufacture [`ExportBackupPlanTemplateInput`](crate::input::ExportBackupPlanTemplateInput)
    pub fn builder() -> crate::input::export_backup_plan_template_input::Builder {
        crate::input::export_backup_plan_template_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ExportBackupPlanTemplate {
    type Output = std::result::Result<
        crate::output::ExportBackupPlanTemplateOutput,
        crate::error::ExportBackupPlanTemplateError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_export_backup_plan_template_error(response)
        } else {
            crate::operation_deser::parse_export_backup_plan_template_response(response)
        }
    }
}

/// <p>Returns <code>BackupPlan</code> details for the specified <code>BackupPlanId</code>. The
/// details are the body of a backup plan in JSON format, in addition to plan metadata.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetBackupPlan {
    _private: (),
}
impl GetBackupPlan {
    /// Creates a new builder-style object to manufacture [`GetBackupPlanInput`](crate::input::GetBackupPlanInput)
    pub fn builder() -> crate::input::get_backup_plan_input::Builder {
        crate::input::get_backup_plan_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetBackupPlan {
    type Output =
        std::result::Result<crate::output::GetBackupPlanOutput, crate::error::GetBackupPlanError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_backup_plan_error(response)
        } else {
            crate::operation_deser::parse_get_backup_plan_response(response)
        }
    }
}

/// <p>Returns a valid JSON document specifying a backup plan or an error.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetBackupPlanFromJSON {
    _private: (),
}
impl GetBackupPlanFromJSON {
    /// Creates a new builder-style object to manufacture [`GetBackupPlanFromJsonInput`](crate::input::GetBackupPlanFromJsonInput)
    pub fn builder() -> crate::input::get_backup_plan_from_json_input::Builder {
        crate::input::get_backup_plan_from_json_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetBackupPlanFromJSON {
    type Output = std::result::Result<
        crate::output::GetBackupPlanFromJsonOutput,
        crate::error::GetBackupPlanFromJSONError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_backup_plan_from_json_error(response)
        } else {
            crate::operation_deser::parse_get_backup_plan_from_json_response(response)
        }
    }
}

/// <p>Returns the template specified by its <code>templateId</code> as a backup plan.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetBackupPlanFromTemplate {
    _private: (),
}
impl GetBackupPlanFromTemplate {
    /// Creates a new builder-style object to manufacture [`GetBackupPlanFromTemplateInput`](crate::input::GetBackupPlanFromTemplateInput)
    pub fn builder() -> crate::input::get_backup_plan_from_template_input::Builder {
        crate::input::get_backup_plan_from_template_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetBackupPlanFromTemplate {
    type Output = std::result::Result<
        crate::output::GetBackupPlanFromTemplateOutput,
        crate::error::GetBackupPlanFromTemplateError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_backup_plan_from_template_error(response)
        } else {
            crate::operation_deser::parse_get_backup_plan_from_template_response(response)
        }
    }
}

/// <p>Returns selection metadata and a document in JSON format that specifies a list of
/// resources that are associated with a backup plan.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetBackupSelection {
    _private: (),
}
impl GetBackupSelection {
    /// Creates a new builder-style object to manufacture [`GetBackupSelectionInput`](crate::input::GetBackupSelectionInput)
    pub fn builder() -> crate::input::get_backup_selection_input::Builder {
        crate::input::get_backup_selection_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetBackupSelection {
    type Output = std::result::Result<
        crate::output::GetBackupSelectionOutput,
        crate::error::GetBackupSelectionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_backup_selection_error(response)
        } else {
            crate::operation_deser::parse_get_backup_selection_response(response)
        }
    }
}

/// <p>Returns the access policy document that is associated with the named backup
/// vault.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetBackupVaultAccessPolicy {
    _private: (),
}
impl GetBackupVaultAccessPolicy {
    /// Creates a new builder-style object to manufacture [`GetBackupVaultAccessPolicyInput`](crate::input::GetBackupVaultAccessPolicyInput)
    pub fn builder() -> crate::input::get_backup_vault_access_policy_input::Builder {
        crate::input::get_backup_vault_access_policy_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetBackupVaultAccessPolicy {
    type Output = std::result::Result<
        crate::output::GetBackupVaultAccessPolicyOutput,
        crate::error::GetBackupVaultAccessPolicyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_backup_vault_access_policy_error(response)
        } else {
            crate::operation_deser::parse_get_backup_vault_access_policy_response(response)
        }
    }
}

/// <p>Returns event notifications for the specified backup vault.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetBackupVaultNotifications {
    _private: (),
}
impl GetBackupVaultNotifications {
    /// Creates a new builder-style object to manufacture [`GetBackupVaultNotificationsInput`](crate::input::GetBackupVaultNotificationsInput)
    pub fn builder() -> crate::input::get_backup_vault_notifications_input::Builder {
        crate::input::get_backup_vault_notifications_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetBackupVaultNotifications {
    type Output = std::result::Result<
        crate::output::GetBackupVaultNotificationsOutput,
        crate::error::GetBackupVaultNotificationsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_backup_vault_notifications_error(response)
        } else {
            crate::operation_deser::parse_get_backup_vault_notifications_response(response)
        }
    }
}

/// <p>Returns a set of metadata key-value pairs that were used to create the backup.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetRecoveryPointRestoreMetadata {
    _private: (),
}
impl GetRecoveryPointRestoreMetadata {
    /// Creates a new builder-style object to manufacture [`GetRecoveryPointRestoreMetadataInput`](crate::input::GetRecoveryPointRestoreMetadataInput)
    pub fn builder() -> crate::input::get_recovery_point_restore_metadata_input::Builder {
        crate::input::get_recovery_point_restore_metadata_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetRecoveryPointRestoreMetadata {
    type Output = std::result::Result<
        crate::output::GetRecoveryPointRestoreMetadataOutput,
        crate::error::GetRecoveryPointRestoreMetadataError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_recovery_point_restore_metadata_error(response)
        } else {
            crate::operation_deser::parse_get_recovery_point_restore_metadata_response(response)
        }
    }
}

/// <p>Returns the Amazon Web Services resource types supported by Backup.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetSupportedResourceTypes {
    _private: (),
}
impl GetSupportedResourceTypes {
    /// Creates a new builder-style object to manufacture [`GetSupportedResourceTypesInput`](crate::input::GetSupportedResourceTypesInput)
    pub fn builder() -> crate::input::get_supported_resource_types_input::Builder {
        crate::input::get_supported_resource_types_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetSupportedResourceTypes {
    type Output = std::result::Result<
        crate::output::GetSupportedResourceTypesOutput,
        crate::error::GetSupportedResourceTypesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_supported_resource_types_error(response)
        } else {
            crate::operation_deser::parse_get_supported_resource_types_response(response)
        }
    }
}

/// <p>Returns a list of existing backup jobs for an authenticated account for the last 30
/// days. For a longer period of time, consider using these <a href="https://docs.aws.amazon.com/aws-backup/latest/devguide/monitoring.html">monitoring tools</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListBackupJobs {
    _private: (),
}
impl ListBackupJobs {
    /// Creates a new builder-style object to manufacture [`ListBackupJobsInput`](crate::input::ListBackupJobsInput)
    pub fn builder() -> crate::input::list_backup_jobs_input::Builder {
        crate::input::list_backup_jobs_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListBackupJobs {
    type Output =
        std::result::Result<crate::output::ListBackupJobsOutput, crate::error::ListBackupJobsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_backup_jobs_error(response)
        } else {
            crate::operation_deser::parse_list_backup_jobs_response(response)
        }
    }
}

/// <p>Returns a list of all active backup plans for an authenticated account. The list
/// contains information such as Amazon Resource Names (ARNs), plan IDs, creation and deletion
/// dates, version IDs, plan names, and creator request IDs.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListBackupPlans {
    _private: (),
}
impl ListBackupPlans {
    /// Creates a new builder-style object to manufacture [`ListBackupPlansInput`](crate::input::ListBackupPlansInput)
    pub fn builder() -> crate::input::list_backup_plans_input::Builder {
        crate::input::list_backup_plans_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListBackupPlans {
    type Output = std::result::Result<
        crate::output::ListBackupPlansOutput,
        crate::error::ListBackupPlansError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_backup_plans_error(response)
        } else {
            crate::operation_deser::parse_list_backup_plans_response(response)
        }
    }
}

/// <p>Returns metadata of your saved backup plan templates, including the template ID, name,
/// and the creation and deletion dates.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListBackupPlanTemplates {
    _private: (),
}
impl ListBackupPlanTemplates {
    /// Creates a new builder-style object to manufacture [`ListBackupPlanTemplatesInput`](crate::input::ListBackupPlanTemplatesInput)
    pub fn builder() -> crate::input::list_backup_plan_templates_input::Builder {
        crate::input::list_backup_plan_templates_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListBackupPlanTemplates {
    type Output = std::result::Result<
        crate::output::ListBackupPlanTemplatesOutput,
        crate::error::ListBackupPlanTemplatesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_backup_plan_templates_error(response)
        } else {
            crate::operation_deser::parse_list_backup_plan_templates_response(response)
        }
    }
}

/// <p>Returns version metadata of your backup plans, including Amazon Resource Names (ARNs),
/// backup plan IDs, creation and deletion dates, plan names, and version IDs.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListBackupPlanVersions {
    _private: (),
}
impl ListBackupPlanVersions {
    /// Creates a new builder-style object to manufacture [`ListBackupPlanVersionsInput`](crate::input::ListBackupPlanVersionsInput)
    pub fn builder() -> crate::input::list_backup_plan_versions_input::Builder {
        crate::input::list_backup_plan_versions_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListBackupPlanVersions {
    type Output = std::result::Result<
        crate::output::ListBackupPlanVersionsOutput,
        crate::error::ListBackupPlanVersionsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_backup_plan_versions_error(response)
        } else {
            crate::operation_deser::parse_list_backup_plan_versions_response(response)
        }
    }
}

/// <p>Returns an array containing metadata of the resources associated with the target backup
/// plan.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListBackupSelections {
    _private: (),
}
impl ListBackupSelections {
    /// Creates a new builder-style object to manufacture [`ListBackupSelectionsInput`](crate::input::ListBackupSelectionsInput)
    pub fn builder() -> crate::input::list_backup_selections_input::Builder {
        crate::input::list_backup_selections_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListBackupSelections {
    type Output = std::result::Result<
        crate::output::ListBackupSelectionsOutput,
        crate::error::ListBackupSelectionsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_backup_selections_error(response)
        } else {
            crate::operation_deser::parse_list_backup_selections_response(response)
        }
    }
}

/// <p>Returns a list of recovery point storage containers along with information about
/// them.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListBackupVaults {
    _private: (),
}
impl ListBackupVaults {
    /// Creates a new builder-style object to manufacture [`ListBackupVaultsInput`](crate::input::ListBackupVaultsInput)
    pub fn builder() -> crate::input::list_backup_vaults_input::Builder {
        crate::input::list_backup_vaults_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListBackupVaults {
    type Output = std::result::Result<
        crate::output::ListBackupVaultsOutput,
        crate::error::ListBackupVaultsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_backup_vaults_error(response)
        } else {
            crate::operation_deser::parse_list_backup_vaults_response(response)
        }
    }
}

/// <p>Returns metadata about your copy jobs.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListCopyJobs {
    _private: (),
}
impl ListCopyJobs {
    /// Creates a new builder-style object to manufacture [`ListCopyJobsInput`](crate::input::ListCopyJobsInput)
    pub fn builder() -> crate::input::list_copy_jobs_input::Builder {
        crate::input::list_copy_jobs_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListCopyJobs {
    type Output =
        std::result::Result<crate::output::ListCopyJobsOutput, crate::error::ListCopyJobsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_copy_jobs_error(response)
        } else {
            crate::operation_deser::parse_list_copy_jobs_response(response)
        }
    }
}

/// <p>Returns a list of all frameworks for an Amazon Web Services account and Amazon Web Services Region.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListFrameworks {
    _private: (),
}
impl ListFrameworks {
    /// Creates a new builder-style object to manufacture [`ListFrameworksInput`](crate::input::ListFrameworksInput)
    pub fn builder() -> crate::input::list_frameworks_input::Builder {
        crate::input::list_frameworks_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListFrameworks {
    type Output =
        std::result::Result<crate::output::ListFrameworksOutput, crate::error::ListFrameworksError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_frameworks_error(response)
        } else {
            crate::operation_deser::parse_list_frameworks_response(response)
        }
    }
}

/// <p>Returns an array of resources successfully backed up by Backup, including
/// the time the resource was saved, an Amazon Resource Name (ARN) of the resource, and a
/// resource type.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListProtectedResources {
    _private: (),
}
impl ListProtectedResources {
    /// Creates a new builder-style object to manufacture [`ListProtectedResourcesInput`](crate::input::ListProtectedResourcesInput)
    pub fn builder() -> crate::input::list_protected_resources_input::Builder {
        crate::input::list_protected_resources_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListProtectedResources {
    type Output = std::result::Result<
        crate::output::ListProtectedResourcesOutput,
        crate::error::ListProtectedResourcesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_protected_resources_error(response)
        } else {
            crate::operation_deser::parse_list_protected_resources_response(response)
        }
    }
}

/// <p>Returns detailed information about the recovery points stored in a backup vault.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListRecoveryPointsByBackupVault {
    _private: (),
}
impl ListRecoveryPointsByBackupVault {
    /// Creates a new builder-style object to manufacture [`ListRecoveryPointsByBackupVaultInput`](crate::input::ListRecoveryPointsByBackupVaultInput)
    pub fn builder() -> crate::input::list_recovery_points_by_backup_vault_input::Builder {
        crate::input::list_recovery_points_by_backup_vault_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListRecoveryPointsByBackupVault {
    type Output = std::result::Result<
        crate::output::ListRecoveryPointsByBackupVaultOutput,
        crate::error::ListRecoveryPointsByBackupVaultError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_recovery_points_by_backup_vault_error(response)
        } else {
            crate::operation_deser::parse_list_recovery_points_by_backup_vault_response(response)
        }
    }
}

/// <p>Returns detailed information about all the recovery points of the type specified by a
/// resource Amazon Resource Name (ARN).</p>
/// <note>
/// <p>For Amazon EFS and Amazon EC2, this action only lists recovery points
/// created by Backup.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListRecoveryPointsByResource {
    _private: (),
}
impl ListRecoveryPointsByResource {
    /// Creates a new builder-style object to manufacture [`ListRecoveryPointsByResourceInput`](crate::input::ListRecoveryPointsByResourceInput)
    pub fn builder() -> crate::input::list_recovery_points_by_resource_input::Builder {
        crate::input::list_recovery_points_by_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListRecoveryPointsByResource {
    type Output = std::result::Result<
        crate::output::ListRecoveryPointsByResourceOutput,
        crate::error::ListRecoveryPointsByResourceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_recovery_points_by_resource_error(response)
        } else {
            crate::operation_deser::parse_list_recovery_points_by_resource_response(response)
        }
    }
}

/// <p>Returns details about your report jobs.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListReportJobs {
    _private: (),
}
impl ListReportJobs {
    /// Creates a new builder-style object to manufacture [`ListReportJobsInput`](crate::input::ListReportJobsInput)
    pub fn builder() -> crate::input::list_report_jobs_input::Builder {
        crate::input::list_report_jobs_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListReportJobs {
    type Output =
        std::result::Result<crate::output::ListReportJobsOutput, crate::error::ListReportJobsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_report_jobs_error(response)
        } else {
            crate::operation_deser::parse_list_report_jobs_response(response)
        }
    }
}

/// <p>Returns a list of your report plans. For detailed information about a single report
/// plan, use <code>DescribeReportPlan</code>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListReportPlans {
    _private: (),
}
impl ListReportPlans {
    /// Creates a new builder-style object to manufacture [`ListReportPlansInput`](crate::input::ListReportPlansInput)
    pub fn builder() -> crate::input::list_report_plans_input::Builder {
        crate::input::list_report_plans_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListReportPlans {
    type Output = std::result::Result<
        crate::output::ListReportPlansOutput,
        crate::error::ListReportPlansError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_report_plans_error(response)
        } else {
            crate::operation_deser::parse_list_report_plans_response(response)
        }
    }
}

/// <p>Returns a list of jobs that Backup initiated to restore a saved resource,
/// including details about the recovery process.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListRestoreJobs {
    _private: (),
}
impl ListRestoreJobs {
    /// Creates a new builder-style object to manufacture [`ListRestoreJobsInput`](crate::input::ListRestoreJobsInput)
    pub fn builder() -> crate::input::list_restore_jobs_input::Builder {
        crate::input::list_restore_jobs_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListRestoreJobs {
    type Output = std::result::Result<
        crate::output::ListRestoreJobsOutput,
        crate::error::ListRestoreJobsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_restore_jobs_error(response)
        } else {
            crate::operation_deser::parse_list_restore_jobs_response(response)
        }
    }
}

/// <p>Returns a list of key-value pairs assigned to a target recovery point, backup plan, or
/// backup vault.</p>
/// <note>
/// <p>
/// <code>ListTags</code> are currently only supported with Amazon EFS
/// backups.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListTags {
    _private: (),
}
impl ListTags {
    /// Creates a new builder-style object to manufacture [`ListTagsInput`](crate::input::ListTagsInput)
    pub fn builder() -> crate::input::list_tags_input::Builder {
        crate::input::list_tags_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListTags {
    type Output = std::result::Result<crate::output::ListTagsOutput, crate::error::ListTagsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_tags_error(response)
        } else {
            crate::operation_deser::parse_list_tags_response(response)
        }
    }
}

/// <p>Sets a resource-based policy that is used to manage access permissions on the target
/// backup vault. Requires a backup vault name and an access policy document in JSON
/// format.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutBackupVaultAccessPolicy {
    _private: (),
}
impl PutBackupVaultAccessPolicy {
    /// Creates a new builder-style object to manufacture [`PutBackupVaultAccessPolicyInput`](crate::input::PutBackupVaultAccessPolicyInput)
    pub fn builder() -> crate::input::put_backup_vault_access_policy_input::Builder {
        crate::input::put_backup_vault_access_policy_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutBackupVaultAccessPolicy {
    type Output = std::result::Result<
        crate::output::PutBackupVaultAccessPolicyOutput,
        crate::error::PutBackupVaultAccessPolicyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_put_backup_vault_access_policy_error(response)
        } else {
            crate::operation_deser::parse_put_backup_vault_access_policy_response(response)
        }
    }
}

/// <p>Applies Backup Vault Lock to a backup vault, preventing attempts to delete
/// any recovery point stored in or created in a backup vault. Vault Lock also prevents
/// attempts to update the lifecycle policy that controls the retention period of any recovery
/// point currently stored in a backup vault. If specified, Vault Lock enforces a minimum and
/// maximum retention period for future backup and copy jobs that target a backup vault.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutBackupVaultLockConfiguration {
    _private: (),
}
impl PutBackupVaultLockConfiguration {
    /// Creates a new builder-style object to manufacture [`PutBackupVaultLockConfigurationInput`](crate::input::PutBackupVaultLockConfigurationInput)
    pub fn builder() -> crate::input::put_backup_vault_lock_configuration_input::Builder {
        crate::input::put_backup_vault_lock_configuration_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutBackupVaultLockConfiguration {
    type Output = std::result::Result<
        crate::output::PutBackupVaultLockConfigurationOutput,
        crate::error::PutBackupVaultLockConfigurationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_put_backup_vault_lock_configuration_error(response)
        } else {
            crate::operation_deser::parse_put_backup_vault_lock_configuration_response(response)
        }
    }
}

/// <p>Turns on notifications on a backup vault for the specified topic and events.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutBackupVaultNotifications {
    _private: (),
}
impl PutBackupVaultNotifications {
    /// Creates a new builder-style object to manufacture [`PutBackupVaultNotificationsInput`](crate::input::PutBackupVaultNotificationsInput)
    pub fn builder() -> crate::input::put_backup_vault_notifications_input::Builder {
        crate::input::put_backup_vault_notifications_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutBackupVaultNotifications {
    type Output = std::result::Result<
        crate::output::PutBackupVaultNotificationsOutput,
        crate::error::PutBackupVaultNotificationsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_put_backup_vault_notifications_error(response)
        } else {
            crate::operation_deser::parse_put_backup_vault_notifications_response(response)
        }
    }
}

/// <p>Starts an on-demand backup job for the specified resource.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct StartBackupJob {
    _private: (),
}
impl StartBackupJob {
    /// Creates a new builder-style object to manufacture [`StartBackupJobInput`](crate::input::StartBackupJobInput)
    pub fn builder() -> crate::input::start_backup_job_input::Builder {
        crate::input::start_backup_job_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for StartBackupJob {
    type Output =
        std::result::Result<crate::output::StartBackupJobOutput, crate::error::StartBackupJobError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_start_backup_job_error(response)
        } else {
            crate::operation_deser::parse_start_backup_job_response(response)
        }
    }
}

/// <p>Starts a job to create a one-time copy of the specified resource.</p>
/// <p>Does not support continuous backups.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct StartCopyJob {
    _private: (),
}
impl StartCopyJob {
    /// Creates a new builder-style object to manufacture [`StartCopyJobInput`](crate::input::StartCopyJobInput)
    pub fn builder() -> crate::input::start_copy_job_input::Builder {
        crate::input::start_copy_job_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for StartCopyJob {
    type Output =
        std::result::Result<crate::output::StartCopyJobOutput, crate::error::StartCopyJobError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_start_copy_job_error(response)
        } else {
            crate::operation_deser::parse_start_copy_job_response(response)
        }
    }
}

/// <p>Starts an on-demand report job for the specified report plan.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct StartReportJob {
    _private: (),
}
impl StartReportJob {
    /// Creates a new builder-style object to manufacture [`StartReportJobInput`](crate::input::StartReportJobInput)
    pub fn builder() -> crate::input::start_report_job_input::Builder {
        crate::input::start_report_job_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for StartReportJob {
    type Output =
        std::result::Result<crate::output::StartReportJobOutput, crate::error::StartReportJobError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_start_report_job_error(response)
        } else {
            crate::operation_deser::parse_start_report_job_response(response)
        }
    }
}

/// <p>Recovers the saved resource identified by an Amazon Resource Name (ARN).</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct StartRestoreJob {
    _private: (),
}
impl StartRestoreJob {
    /// Creates a new builder-style object to manufacture [`StartRestoreJobInput`](crate::input::StartRestoreJobInput)
    pub fn builder() -> crate::input::start_restore_job_input::Builder {
        crate::input::start_restore_job_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for StartRestoreJob {
    type Output = std::result::Result<
        crate::output::StartRestoreJobOutput,
        crate::error::StartRestoreJobError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_start_restore_job_error(response)
        } else {
            crate::operation_deser::parse_start_restore_job_response(response)
        }
    }
}

/// <p>Attempts to cancel a job to create a one-time backup of a resource.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct StopBackupJob {
    _private: (),
}
impl StopBackupJob {
    /// Creates a new builder-style object to manufacture [`StopBackupJobInput`](crate::input::StopBackupJobInput)
    pub fn builder() -> crate::input::stop_backup_job_input::Builder {
        crate::input::stop_backup_job_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for StopBackupJob {
    type Output =
        std::result::Result<crate::output::StopBackupJobOutput, crate::error::StopBackupJobError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_stop_backup_job_error(response)
        } else {
            crate::operation_deser::parse_stop_backup_job_response(response)
        }
    }
}

/// <p>Assigns a set of key-value pairs to a recovery point, backup plan, or backup vault
/// identified by an Amazon Resource Name (ARN).</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct TagResource {
    _private: (),
}
impl TagResource {
    /// Creates a new builder-style object to manufacture [`TagResourceInput`](crate::input::TagResourceInput)
    pub fn builder() -> crate::input::tag_resource_input::Builder {
        crate::input::tag_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for TagResource {
    type Output =
        std::result::Result<crate::output::TagResourceOutput, crate::error::TagResourceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_tag_resource_error(response)
        } else {
            crate::operation_deser::parse_tag_resource_response(response)
        }
    }
}

/// <p>Removes a set of key-value pairs from a recovery point, backup plan, or backup vault
/// identified by an Amazon Resource Name (ARN)</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UntagResource {
    _private: (),
}
impl UntagResource {
    /// Creates a new builder-style object to manufacture [`UntagResourceInput`](crate::input::UntagResourceInput)
    pub fn builder() -> crate::input::untag_resource_input::Builder {
        crate::input::untag_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UntagResource {
    type Output =
        std::result::Result<crate::output::UntagResourceOutput, crate::error::UntagResourceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_untag_resource_error(response)
        } else {
            crate::operation_deser::parse_untag_resource_response(response)
        }
    }
}

/// <p>Updates an existing backup plan identified by its <code>backupPlanId</code> with the
/// input document in JSON format. The new version is uniquely identified by a
/// <code>VersionId</code>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateBackupPlan {
    _private: (),
}
impl UpdateBackupPlan {
    /// Creates a new builder-style object to manufacture [`UpdateBackupPlanInput`](crate::input::UpdateBackupPlanInput)
    pub fn builder() -> crate::input::update_backup_plan_input::Builder {
        crate::input::update_backup_plan_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateBackupPlan {
    type Output = std::result::Result<
        crate::output::UpdateBackupPlanOutput,
        crate::error::UpdateBackupPlanError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_backup_plan_error(response)
        } else {
            crate::operation_deser::parse_update_backup_plan_response(response)
        }
    }
}

/// <p>Updates an existing framework identified by its <code>FrameworkName</code> with the
/// input document in JSON format.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateFramework {
    _private: (),
}
impl UpdateFramework {
    /// Creates a new builder-style object to manufacture [`UpdateFrameworkInput`](crate::input::UpdateFrameworkInput)
    pub fn builder() -> crate::input::update_framework_input::Builder {
        crate::input::update_framework_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateFramework {
    type Output = std::result::Result<
        crate::output::UpdateFrameworkOutput,
        crate::error::UpdateFrameworkError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_framework_error(response)
        } else {
            crate::operation_deser::parse_update_framework_response(response)
        }
    }
}

/// <p>Updates whether the Amazon Web Services account is opted in to cross-account backup.
/// Returns an error if the account is not an Organizations management account. Use the
/// <code>DescribeGlobalSettings</code> API to determine the current settings.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateGlobalSettings {
    _private: (),
}
impl UpdateGlobalSettings {
    /// Creates a new builder-style object to manufacture [`UpdateGlobalSettingsInput`](crate::input::UpdateGlobalSettingsInput)
    pub fn builder() -> crate::input::update_global_settings_input::Builder {
        crate::input::update_global_settings_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateGlobalSettings {
    type Output = std::result::Result<
        crate::output::UpdateGlobalSettingsOutput,
        crate::error::UpdateGlobalSettingsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_global_settings_error(response)
        } else {
            crate::operation_deser::parse_update_global_settings_response(response)
        }
    }
}

/// <p>Sets the transition lifecycle of a recovery point.</p>
/// <p>The lifecycle defines when a protected resource is transitioned to cold storage and when
/// it expires. Backup transitions and expires backups automatically according to
/// the lifecycle that you define.</p>
/// <p>Backups transitioned to cold storage must be stored in cold storage for a minimum of 90
/// days. Therefore, the expire after days setting must be 90 days greater than the
/// transition to cold after days setting. The transition to cold after days setting cannot
/// be changed after a backup has been transitioned to cold.</p>
/// <p>Only Amazon EFS file system backups can be transitioned to cold storage.</p>
/// <p>Does not support continuous backups.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateRecoveryPointLifecycle {
    _private: (),
}
impl UpdateRecoveryPointLifecycle {
    /// Creates a new builder-style object to manufacture [`UpdateRecoveryPointLifecycleInput`](crate::input::UpdateRecoveryPointLifecycleInput)
    pub fn builder() -> crate::input::update_recovery_point_lifecycle_input::Builder {
        crate::input::update_recovery_point_lifecycle_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateRecoveryPointLifecycle {
    type Output = std::result::Result<
        crate::output::UpdateRecoveryPointLifecycleOutput,
        crate::error::UpdateRecoveryPointLifecycleError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_recovery_point_lifecycle_error(response)
        } else {
            crate::operation_deser::parse_update_recovery_point_lifecycle_response(response)
        }
    }
}

/// <p>Updates the current service opt-in settings for the Region. If service-opt-in is enabled
/// for a service, Backup tries to protect that service's resources in this Region,
/// when the resource is included in an on-demand backup or scheduled backup plan. Otherwise,
/// Backup does not try to protect that service's resources in this Region. Use
/// the <code>DescribeRegionSettings</code> API to determine the resource types that are
/// supported.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateRegionSettings {
    _private: (),
}
impl UpdateRegionSettings {
    /// Creates a new builder-style object to manufacture [`UpdateRegionSettingsInput`](crate::input::UpdateRegionSettingsInput)
    pub fn builder() -> crate::input::update_region_settings_input::Builder {
        crate::input::update_region_settings_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateRegionSettings {
    type Output = std::result::Result<
        crate::output::UpdateRegionSettingsOutput,
        crate::error::UpdateRegionSettingsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_region_settings_error(response)
        } else {
            crate::operation_deser::parse_update_region_settings_response(response)
        }
    }
}

/// <p>Updates an existing report plan identified by its <code>ReportPlanName</code> with the
/// input document in JSON format.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateReportPlan {
    _private: (),
}
impl UpdateReportPlan {
    /// Creates a new builder-style object to manufacture [`UpdateReportPlanInput`](crate::input::UpdateReportPlanInput)
    pub fn builder() -> crate::input::update_report_plan_input::Builder {
        crate::input::update_report_plan_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateReportPlan {
    type Output = std::result::Result<
        crate::output::UpdateReportPlanOutput,
        crate::error::UpdateReportPlanError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_report_plan_error(response)
        } else {
            crate::operation_deser::parse_update_report_plan_response(response)
        }
    }
}
