// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[derive(Debug)]
pub(crate) struct Handle<
    C = smithy_client::erase::DynConnector,
    M = aws_hyper::AwsMiddleware,
    R = smithy_client::retry::Standard,
> {
    client: smithy_client::Client<C, M, R>,
    conf: crate::Config,
}

/// An ergonomic service client for `CryoControllerUserManager`.
///
/// This client allows ergonomic access to a `CryoControllerUserManager`-shaped service.
/// Each method corresponds to an endpoint defined in the service's Smithy model,
/// and the request and response shapes are auto-generated from that same model.
///
/// # Using a Client
///
/// Once you have a client set up, you can access the service's endpoints
/// by calling the appropriate method on [`Client`]. Each such method
/// returns a request builder for that endpoint, with methods for setting
/// the various fields of the request. Once your request is complete, use
/// the `send` method to send the request. `send` returns a future, which
/// you then have to `.await` to get the service's response.
///
/// [builder pattern]: https://rust-lang.github.io/api-guidelines/type-safety.html#c-builder
/// [SigV4-signed requests]: https://docs.aws.amazon.com/general/latest/gr/signature-version-4.html
#[derive(std::fmt::Debug)]
pub struct Client<
    C = smithy_client::erase::DynConnector,
    M = aws_hyper::AwsMiddleware,
    R = smithy_client::retry::Standard,
> {
    handle: std::sync::Arc<Handle<C, M, R>>,
}

impl<C, M, R> std::clone::Clone for Client<C, M, R> {
    fn clone(&self) -> Self {
        Self {
            handle: self.handle.clone(),
        }
    }
}

#[doc(inline)]
pub use smithy_client::Builder;

impl<C, M, R> From<smithy_client::Client<C, M, R>> for Client<C, M, R> {
    fn from(client: smithy_client::Client<C, M, R>) -> Self {
        Self::with_config(client, crate::Config::builder().build())
    }
}

impl<C, M, R> Client<C, M, R> {
    pub fn with_config(client: smithy_client::Client<C, M, R>, conf: crate::Config) -> Self {
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }

    pub fn conf(&self) -> &crate::Config {
        &self.handle.conf
    }
}
impl<C, M, R> Client<C, M, R>
where
    C: smithy_client::bounds::SmithyConnector,
    M: smithy_client::bounds::SmithyMiddleware<C>,
    R: smithy_client::retry::NewRequestPolicy,
{
    pub fn create_backup_plan(&self) -> fluent_builders::CreateBackupPlan<C, M, R> {
        fluent_builders::CreateBackupPlan::new(self.handle.clone())
    }
    pub fn create_backup_selection(&self) -> fluent_builders::CreateBackupSelection<C, M, R> {
        fluent_builders::CreateBackupSelection::new(self.handle.clone())
    }
    pub fn create_backup_vault(&self) -> fluent_builders::CreateBackupVault<C, M, R> {
        fluent_builders::CreateBackupVault::new(self.handle.clone())
    }
    pub fn create_framework(&self) -> fluent_builders::CreateFramework<C, M, R> {
        fluent_builders::CreateFramework::new(self.handle.clone())
    }
    pub fn create_report_plan(&self) -> fluent_builders::CreateReportPlan<C, M, R> {
        fluent_builders::CreateReportPlan::new(self.handle.clone())
    }
    pub fn delete_backup_plan(&self) -> fluent_builders::DeleteBackupPlan<C, M, R> {
        fluent_builders::DeleteBackupPlan::new(self.handle.clone())
    }
    pub fn delete_backup_selection(&self) -> fluent_builders::DeleteBackupSelection<C, M, R> {
        fluent_builders::DeleteBackupSelection::new(self.handle.clone())
    }
    pub fn delete_backup_vault(&self) -> fluent_builders::DeleteBackupVault<C, M, R> {
        fluent_builders::DeleteBackupVault::new(self.handle.clone())
    }
    pub fn delete_backup_vault_access_policy(
        &self,
    ) -> fluent_builders::DeleteBackupVaultAccessPolicy<C, M, R> {
        fluent_builders::DeleteBackupVaultAccessPolicy::new(self.handle.clone())
    }
    pub fn delete_backup_vault_notifications(
        &self,
    ) -> fluent_builders::DeleteBackupVaultNotifications<C, M, R> {
        fluent_builders::DeleteBackupVaultNotifications::new(self.handle.clone())
    }
    pub fn delete_framework(&self) -> fluent_builders::DeleteFramework<C, M, R> {
        fluent_builders::DeleteFramework::new(self.handle.clone())
    }
    pub fn delete_recovery_point(&self) -> fluent_builders::DeleteRecoveryPoint<C, M, R> {
        fluent_builders::DeleteRecoveryPoint::new(self.handle.clone())
    }
    pub fn delete_report_plan(&self) -> fluent_builders::DeleteReportPlan<C, M, R> {
        fluent_builders::DeleteReportPlan::new(self.handle.clone())
    }
    pub fn describe_backup_job(&self) -> fluent_builders::DescribeBackupJob<C, M, R> {
        fluent_builders::DescribeBackupJob::new(self.handle.clone())
    }
    pub fn describe_backup_vault(&self) -> fluent_builders::DescribeBackupVault<C, M, R> {
        fluent_builders::DescribeBackupVault::new(self.handle.clone())
    }
    pub fn describe_copy_job(&self) -> fluent_builders::DescribeCopyJob<C, M, R> {
        fluent_builders::DescribeCopyJob::new(self.handle.clone())
    }
    pub fn describe_framework(&self) -> fluent_builders::DescribeFramework<C, M, R> {
        fluent_builders::DescribeFramework::new(self.handle.clone())
    }
    pub fn describe_global_settings(&self) -> fluent_builders::DescribeGlobalSettings<C, M, R> {
        fluent_builders::DescribeGlobalSettings::new(self.handle.clone())
    }
    pub fn describe_protected_resource(
        &self,
    ) -> fluent_builders::DescribeProtectedResource<C, M, R> {
        fluent_builders::DescribeProtectedResource::new(self.handle.clone())
    }
    pub fn describe_recovery_point(&self) -> fluent_builders::DescribeRecoveryPoint<C, M, R> {
        fluent_builders::DescribeRecoveryPoint::new(self.handle.clone())
    }
    pub fn describe_region_settings(&self) -> fluent_builders::DescribeRegionSettings<C, M, R> {
        fluent_builders::DescribeRegionSettings::new(self.handle.clone())
    }
    pub fn describe_report_job(&self) -> fluent_builders::DescribeReportJob<C, M, R> {
        fluent_builders::DescribeReportJob::new(self.handle.clone())
    }
    pub fn describe_report_plan(&self) -> fluent_builders::DescribeReportPlan<C, M, R> {
        fluent_builders::DescribeReportPlan::new(self.handle.clone())
    }
    pub fn describe_restore_job(&self) -> fluent_builders::DescribeRestoreJob<C, M, R> {
        fluent_builders::DescribeRestoreJob::new(self.handle.clone())
    }
    pub fn disassociate_recovery_point(
        &self,
    ) -> fluent_builders::DisassociateRecoveryPoint<C, M, R> {
        fluent_builders::DisassociateRecoveryPoint::new(self.handle.clone())
    }
    pub fn export_backup_plan_template(
        &self,
    ) -> fluent_builders::ExportBackupPlanTemplate<C, M, R> {
        fluent_builders::ExportBackupPlanTemplate::new(self.handle.clone())
    }
    pub fn get_backup_plan(&self) -> fluent_builders::GetBackupPlan<C, M, R> {
        fluent_builders::GetBackupPlan::new(self.handle.clone())
    }
    pub fn get_backup_plan_from_json(&self) -> fluent_builders::GetBackupPlanFromJSON<C, M, R> {
        fluent_builders::GetBackupPlanFromJSON::new(self.handle.clone())
    }
    pub fn get_backup_plan_from_template(
        &self,
    ) -> fluent_builders::GetBackupPlanFromTemplate<C, M, R> {
        fluent_builders::GetBackupPlanFromTemplate::new(self.handle.clone())
    }
    pub fn get_backup_selection(&self) -> fluent_builders::GetBackupSelection<C, M, R> {
        fluent_builders::GetBackupSelection::new(self.handle.clone())
    }
    pub fn get_backup_vault_access_policy(
        &self,
    ) -> fluent_builders::GetBackupVaultAccessPolicy<C, M, R> {
        fluent_builders::GetBackupVaultAccessPolicy::new(self.handle.clone())
    }
    pub fn get_backup_vault_notifications(
        &self,
    ) -> fluent_builders::GetBackupVaultNotifications<C, M, R> {
        fluent_builders::GetBackupVaultNotifications::new(self.handle.clone())
    }
    pub fn get_recovery_point_restore_metadata(
        &self,
    ) -> fluent_builders::GetRecoveryPointRestoreMetadata<C, M, R> {
        fluent_builders::GetRecoveryPointRestoreMetadata::new(self.handle.clone())
    }
    pub fn get_supported_resource_types(
        &self,
    ) -> fluent_builders::GetSupportedResourceTypes<C, M, R> {
        fluent_builders::GetSupportedResourceTypes::new(self.handle.clone())
    }
    pub fn list_backup_jobs(&self) -> fluent_builders::ListBackupJobs<C, M, R> {
        fluent_builders::ListBackupJobs::new(self.handle.clone())
    }
    pub fn list_backup_plans(&self) -> fluent_builders::ListBackupPlans<C, M, R> {
        fluent_builders::ListBackupPlans::new(self.handle.clone())
    }
    pub fn list_backup_plan_templates(&self) -> fluent_builders::ListBackupPlanTemplates<C, M, R> {
        fluent_builders::ListBackupPlanTemplates::new(self.handle.clone())
    }
    pub fn list_backup_plan_versions(&self) -> fluent_builders::ListBackupPlanVersions<C, M, R> {
        fluent_builders::ListBackupPlanVersions::new(self.handle.clone())
    }
    pub fn list_backup_selections(&self) -> fluent_builders::ListBackupSelections<C, M, R> {
        fluent_builders::ListBackupSelections::new(self.handle.clone())
    }
    pub fn list_backup_vaults(&self) -> fluent_builders::ListBackupVaults<C, M, R> {
        fluent_builders::ListBackupVaults::new(self.handle.clone())
    }
    pub fn list_copy_jobs(&self) -> fluent_builders::ListCopyJobs<C, M, R> {
        fluent_builders::ListCopyJobs::new(self.handle.clone())
    }
    pub fn list_frameworks(&self) -> fluent_builders::ListFrameworks<C, M, R> {
        fluent_builders::ListFrameworks::new(self.handle.clone())
    }
    pub fn list_protected_resources(&self) -> fluent_builders::ListProtectedResources<C, M, R> {
        fluent_builders::ListProtectedResources::new(self.handle.clone())
    }
    pub fn list_recovery_points_by_backup_vault(
        &self,
    ) -> fluent_builders::ListRecoveryPointsByBackupVault<C, M, R> {
        fluent_builders::ListRecoveryPointsByBackupVault::new(self.handle.clone())
    }
    pub fn list_recovery_points_by_resource(
        &self,
    ) -> fluent_builders::ListRecoveryPointsByResource<C, M, R> {
        fluent_builders::ListRecoveryPointsByResource::new(self.handle.clone())
    }
    pub fn list_report_jobs(&self) -> fluent_builders::ListReportJobs<C, M, R> {
        fluent_builders::ListReportJobs::new(self.handle.clone())
    }
    pub fn list_report_plans(&self) -> fluent_builders::ListReportPlans<C, M, R> {
        fluent_builders::ListReportPlans::new(self.handle.clone())
    }
    pub fn list_restore_jobs(&self) -> fluent_builders::ListRestoreJobs<C, M, R> {
        fluent_builders::ListRestoreJobs::new(self.handle.clone())
    }
    pub fn list_tags(&self) -> fluent_builders::ListTags<C, M, R> {
        fluent_builders::ListTags::new(self.handle.clone())
    }
    pub fn put_backup_vault_access_policy(
        &self,
    ) -> fluent_builders::PutBackupVaultAccessPolicy<C, M, R> {
        fluent_builders::PutBackupVaultAccessPolicy::new(self.handle.clone())
    }
    pub fn put_backup_vault_notifications(
        &self,
    ) -> fluent_builders::PutBackupVaultNotifications<C, M, R> {
        fluent_builders::PutBackupVaultNotifications::new(self.handle.clone())
    }
    pub fn start_backup_job(&self) -> fluent_builders::StartBackupJob<C, M, R> {
        fluent_builders::StartBackupJob::new(self.handle.clone())
    }
    pub fn start_copy_job(&self) -> fluent_builders::StartCopyJob<C, M, R> {
        fluent_builders::StartCopyJob::new(self.handle.clone())
    }
    pub fn start_report_job(&self) -> fluent_builders::StartReportJob<C, M, R> {
        fluent_builders::StartReportJob::new(self.handle.clone())
    }
    pub fn start_restore_job(&self) -> fluent_builders::StartRestoreJob<C, M, R> {
        fluent_builders::StartRestoreJob::new(self.handle.clone())
    }
    pub fn stop_backup_job(&self) -> fluent_builders::StopBackupJob<C, M, R> {
        fluent_builders::StopBackupJob::new(self.handle.clone())
    }
    pub fn tag_resource(&self) -> fluent_builders::TagResource<C, M, R> {
        fluent_builders::TagResource::new(self.handle.clone())
    }
    pub fn untag_resource(&self) -> fluent_builders::UntagResource<C, M, R> {
        fluent_builders::UntagResource::new(self.handle.clone())
    }
    pub fn update_backup_plan(&self) -> fluent_builders::UpdateBackupPlan<C, M, R> {
        fluent_builders::UpdateBackupPlan::new(self.handle.clone())
    }
    pub fn update_framework(&self) -> fluent_builders::UpdateFramework<C, M, R> {
        fluent_builders::UpdateFramework::new(self.handle.clone())
    }
    pub fn update_global_settings(&self) -> fluent_builders::UpdateGlobalSettings<C, M, R> {
        fluent_builders::UpdateGlobalSettings::new(self.handle.clone())
    }
    pub fn update_recovery_point_lifecycle(
        &self,
    ) -> fluent_builders::UpdateRecoveryPointLifecycle<C, M, R> {
        fluent_builders::UpdateRecoveryPointLifecycle::new(self.handle.clone())
    }
    pub fn update_region_settings(&self) -> fluent_builders::UpdateRegionSettings<C, M, R> {
        fluent_builders::UpdateRegionSettings::new(self.handle.clone())
    }
    pub fn update_report_plan(&self) -> fluent_builders::UpdateReportPlan<C, M, R> {
        fluent_builders::UpdateReportPlan::new(self.handle.clone())
    }
}
pub mod fluent_builders {
    #[derive(std::fmt::Debug)]
    pub struct CreateBackupPlan<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::create_backup_plan_input::Builder,
    }
    impl<C, M, R> CreateBackupPlan<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateBackupPlanOutput,
            smithy_http::result::SdkError<crate::error::CreateBackupPlanError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CreateBackupPlanInputOperationOutputAlias,
                crate::output::CreateBackupPlanOutput,
                crate::error::CreateBackupPlanError,
                crate::input::CreateBackupPlanInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Specifies the body of a backup plan. Includes a <code>BackupPlanName</code> and one or
        /// more sets of <code>Rules</code>.</p>
        pub fn backup_plan(mut self, inp: crate::model::BackupPlanInput) -> Self {
            self.inner = self.inner.backup_plan(inp);
            self
        }
        pub fn set_backup_plan(
            mut self,
            input: std::option::Option<crate::model::BackupPlanInput>,
        ) -> Self {
            self.inner = self.inner.set_backup_plan(input);
            self
        }
        /// Adds a key-value pair to `BackupPlanTags`.
        ///
        /// To override the contents of this collection use [`set_backup_plan_tags`](Self::set_backup_plan_tags).
        /// <p>To help organize your resources, you can assign your own metadata to the resources that
        /// you create. Each tag is a key-value pair. The specified tags are assigned to all backups
        /// created with this plan.</p>
        pub fn backup_plan_tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.backup_plan_tags(k, v);
            self
        }
        pub fn set_backup_plan_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_backup_plan_tags(input);
            self
        }
        /// <p>Identifies the request and allows failed requests to be retried without the risk of
        /// running the operation twice. If the request includes a <code>CreatorRequestId</code> that
        /// matches an existing backup plan, that plan is returned. This parameter is optional.</p>
        pub fn creator_request_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.creator_request_id(inp);
            self
        }
        pub fn set_creator_request_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_creator_request_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateBackupSelection<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::create_backup_selection_input::Builder,
    }
    impl<C, M, R> CreateBackupSelection<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateBackupSelectionOutput,
            smithy_http::result::SdkError<crate::error::CreateBackupSelectionError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CreateBackupSelectionInputOperationOutputAlias,
                crate::output::CreateBackupSelectionOutput,
                crate::error::CreateBackupSelectionError,
                crate::input::CreateBackupSelectionInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Uniquely identifies the backup plan to be associated with the selection of
        /// resources.</p>
        pub fn backup_plan_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.backup_plan_id(inp);
            self
        }
        pub fn set_backup_plan_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_backup_plan_id(input);
            self
        }
        /// <p>Specifies the body of a request to assign a set of resources to a backup plan.</p>
        pub fn backup_selection(mut self, inp: crate::model::BackupSelection) -> Self {
            self.inner = self.inner.backup_selection(inp);
            self
        }
        pub fn set_backup_selection(
            mut self,
            input: std::option::Option<crate::model::BackupSelection>,
        ) -> Self {
            self.inner = self.inner.set_backup_selection(input);
            self
        }
        /// <p>A unique string that identifies the request and allows failed requests to be retried
        /// without the risk of running the operation twice.</p>
        pub fn creator_request_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.creator_request_id(inp);
            self
        }
        pub fn set_creator_request_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_creator_request_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateBackupVault<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::create_backup_vault_input::Builder,
    }
    impl<C, M, R> CreateBackupVault<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateBackupVaultOutput,
            smithy_http::result::SdkError<crate::error::CreateBackupVaultError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CreateBackupVaultInputOperationOutputAlias,
                crate::output::CreateBackupVaultOutput,
                crate::error::CreateBackupVaultError,
                crate::input::CreateBackupVaultInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of a logical container where backups are stored. Backup vaults are identified
        /// by names that are unique to the account used to create them and the Amazon Web Services
        /// Region where they are created. They consist of letters, numbers, and hyphens.</p>
        pub fn backup_vault_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.backup_vault_name(inp);
            self
        }
        pub fn set_backup_vault_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_backup_vault_name(input);
            self
        }
        /// Adds a key-value pair to `BackupVaultTags`.
        ///
        /// To override the contents of this collection use [`set_backup_vault_tags`](Self::set_backup_vault_tags).
        /// <p>Metadata that you can assign to help organize the resources that you create. Each tag is
        /// a key-value pair.</p>
        pub fn backup_vault_tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.backup_vault_tags(k, v);
            self
        }
        pub fn set_backup_vault_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_backup_vault_tags(input);
            self
        }
        /// <p>The server-side encryption key that is used to protect your backups; for example,
        /// <code>arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>.</p>
        pub fn encryption_key_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.encryption_key_arn(inp);
            self
        }
        pub fn set_encryption_key_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_encryption_key_arn(input);
            self
        }
        /// <p>A unique string that identifies the request and allows failed requests to be retried
        /// without the risk of running the operation twice.</p>
        pub fn creator_request_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.creator_request_id(inp);
            self
        }
        pub fn set_creator_request_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_creator_request_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateFramework<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::create_framework_input::Builder,
    }
    impl<C, M, R> CreateFramework<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateFrameworkOutput,
            smithy_http::result::SdkError<crate::error::CreateFrameworkError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CreateFrameworkInputOperationOutputAlias,
                crate::output::CreateFrameworkOutput,
                crate::error::CreateFrameworkError,
                crate::input::CreateFrameworkInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The unique name of the framework. The name must be between 1 and 256 characters,
        /// starting with a letter, and consisting of letters (a-z, A-Z), numbers (0-9), and
        /// underscores (_).</p>
        pub fn framework_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.framework_name(inp);
            self
        }
        pub fn set_framework_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_framework_name(input);
            self
        }
        /// <p>An optional description of the framework with a maximum of 1,024 characters.</p>
        pub fn framework_description(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.framework_description(inp);
            self
        }
        pub fn set_framework_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_framework_description(input);
            self
        }
        /// Appends an item to `FrameworkControls`.
        ///
        /// To override the contents of this collection use [`set_framework_controls`](Self::set_framework_controls).
        /// <p>A list of the controls that make up the framework. Each control in the list has a name,
        /// input parameters, and scope.</p>
        pub fn framework_controls(
            mut self,
            inp: impl Into<crate::model::FrameworkControl>,
        ) -> Self {
            self.inner = self.inner.framework_controls(inp);
            self
        }
        pub fn set_framework_controls(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::FrameworkControl>>,
        ) -> Self {
            self.inner = self.inner.set_framework_controls(input);
            self
        }
        /// <p>A customer-chosen string that you can use to distinguish between otherwise identical
        /// calls to <code>CreateFrameworkInput</code>. Retrying a successful request with the same
        /// idempotency token results in a success message with no action taken.</p>
        pub fn idempotency_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.idempotency_token(inp);
            self
        }
        pub fn set_idempotency_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_idempotency_token(input);
            self
        }
        /// Adds a key-value pair to `FrameworkTags`.
        ///
        /// To override the contents of this collection use [`set_framework_tags`](Self::set_framework_tags).
        /// <p>Metadata that you can assign to help organize the frameworks that you create. Each tag
        /// is a key-value pair.</p>
        pub fn framework_tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.framework_tags(k, v);
            self
        }
        pub fn set_framework_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_framework_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateReportPlan<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::create_report_plan_input::Builder,
    }
    impl<C, M, R> CreateReportPlan<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateReportPlanOutput,
            smithy_http::result::SdkError<crate::error::CreateReportPlanError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CreateReportPlanInputOperationOutputAlias,
                crate::output::CreateReportPlanOutput,
                crate::error::CreateReportPlanError,
                crate::input::CreateReportPlanInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The unique name of the report plan. The name must be between 1 and 256 characters,
        /// starting with a letter, and consisting of letters (a-z, A-Z), numbers (0-9), and
        /// underscores (_).</p>
        pub fn report_plan_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.report_plan_name(inp);
            self
        }
        pub fn set_report_plan_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_report_plan_name(input);
            self
        }
        /// <p>An optional description of the report plan with a maximum of 1,024 characters.</p>
        pub fn report_plan_description(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.report_plan_description(inp);
            self
        }
        pub fn set_report_plan_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_report_plan_description(input);
            self
        }
        /// <p>A structure that contains information about where and how to deliver your reports,
        /// specifically your Amazon S3 bucket name, S3 key prefix, and the formats of your
        /// reports.</p>
        pub fn report_delivery_channel(mut self, inp: crate::model::ReportDeliveryChannel) -> Self {
            self.inner = self.inner.report_delivery_channel(inp);
            self
        }
        pub fn set_report_delivery_channel(
            mut self,
            input: std::option::Option<crate::model::ReportDeliveryChannel>,
        ) -> Self {
            self.inner = self.inner.set_report_delivery_channel(input);
            self
        }
        /// <p>Identifies the report template for the report. Reports are built using a report
        /// template. The report templates are:</p>
        /// <p>
        /// <code>BACKUP_JOB_REPORT | COPY_JOB_REPORT | RESTORE_JOB_REPORT</code>
        /// </p>
        pub fn report_setting(mut self, inp: crate::model::ReportSetting) -> Self {
            self.inner = self.inner.report_setting(inp);
            self
        }
        pub fn set_report_setting(
            mut self,
            input: std::option::Option<crate::model::ReportSetting>,
        ) -> Self {
            self.inner = self.inner.set_report_setting(input);
            self
        }
        /// Adds a key-value pair to `ReportPlanTags`.
        ///
        /// To override the contents of this collection use [`set_report_plan_tags`](Self::set_report_plan_tags).
        /// <p>Metadata that you can assign to help organize the frameworks that you create. Each tag
        /// is a key-value pair.</p>
        pub fn report_plan_tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.report_plan_tags(k, v);
            self
        }
        pub fn set_report_plan_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_report_plan_tags(input);
            self
        }
        /// <p>A customer-chosen string that you can use to distinguish between otherwise identical
        /// calls to <code>CreateReportPlanInput</code>. Retrying a successful request with the same
        /// idempotency token results in a success message with no action taken.</p>
        pub fn idempotency_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.idempotency_token(inp);
            self
        }
        pub fn set_idempotency_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_idempotency_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteBackupPlan<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::delete_backup_plan_input::Builder,
    }
    impl<C, M, R> DeleteBackupPlan<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteBackupPlanOutput,
            smithy_http::result::SdkError<crate::error::DeleteBackupPlanError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DeleteBackupPlanInputOperationOutputAlias,
                crate::output::DeleteBackupPlanOutput,
                crate::error::DeleteBackupPlanError,
                crate::input::DeleteBackupPlanInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Uniquely identifies a backup plan.</p>
        pub fn backup_plan_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.backup_plan_id(inp);
            self
        }
        pub fn set_backup_plan_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_backup_plan_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteBackupSelection<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::delete_backup_selection_input::Builder,
    }
    impl<C, M, R> DeleteBackupSelection<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteBackupSelectionOutput,
            smithy_http::result::SdkError<crate::error::DeleteBackupSelectionError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DeleteBackupSelectionInputOperationOutputAlias,
                crate::output::DeleteBackupSelectionOutput,
                crate::error::DeleteBackupSelectionError,
                crate::input::DeleteBackupSelectionInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Uniquely identifies a backup plan.</p>
        pub fn backup_plan_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.backup_plan_id(inp);
            self
        }
        pub fn set_backup_plan_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_backup_plan_id(input);
            self
        }
        /// <p>Uniquely identifies the body of a request to assign a set of resources to a backup
        /// plan.</p>
        pub fn selection_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.selection_id(inp);
            self
        }
        pub fn set_selection_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_selection_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteBackupVault<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::delete_backup_vault_input::Builder,
    }
    impl<C, M, R> DeleteBackupVault<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteBackupVaultOutput,
            smithy_http::result::SdkError<crate::error::DeleteBackupVaultError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DeleteBackupVaultInputOperationOutputAlias,
                crate::output::DeleteBackupVaultOutput,
                crate::error::DeleteBackupVaultError,
                crate::input::DeleteBackupVaultInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of a logical container where backups are stored. Backup vaults are identified
        /// by names that are unique to the account used to create them and the Amazon Web Services
        /// Region where they are created. They consist of lowercase letters, numbers, and
        /// hyphens.</p>
        pub fn backup_vault_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.backup_vault_name(inp);
            self
        }
        pub fn set_backup_vault_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_backup_vault_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteBackupVaultAccessPolicy<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::delete_backup_vault_access_policy_input::Builder,
    }
    impl<C, M, R> DeleteBackupVaultAccessPolicy<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteBackupVaultAccessPolicyOutput,
            smithy_http::result::SdkError<crate::error::DeleteBackupVaultAccessPolicyError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DeleteBackupVaultAccessPolicyInputOperationOutputAlias,
                crate::output::DeleteBackupVaultAccessPolicyOutput,
                crate::error::DeleteBackupVaultAccessPolicyError,
                crate::input::DeleteBackupVaultAccessPolicyInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of a logical container where backups are stored. Backup vaults are identified
        /// by names that are unique to the account used to create them and the Amazon Web Services
        /// Region where they are created. They consist of lowercase letters, numbers, and
        /// hyphens.</p>
        pub fn backup_vault_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.backup_vault_name(inp);
            self
        }
        pub fn set_backup_vault_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_backup_vault_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteBackupVaultNotifications<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::delete_backup_vault_notifications_input::Builder,
    }
    impl<C, M, R> DeleteBackupVaultNotifications<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteBackupVaultNotificationsOutput,
            smithy_http::result::SdkError<crate::error::DeleteBackupVaultNotificationsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DeleteBackupVaultNotificationsInputOperationOutputAlias,
                crate::output::DeleteBackupVaultNotificationsOutput,
                crate::error::DeleteBackupVaultNotificationsError,
                crate::input::DeleteBackupVaultNotificationsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of a logical container where backups are stored. Backup vaults are identified
        /// by names that are unique to the account used to create them and the Region where they are
        /// created. They consist of lowercase letters, numbers, and hyphens.</p>
        pub fn backup_vault_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.backup_vault_name(inp);
            self
        }
        pub fn set_backup_vault_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_backup_vault_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteFramework<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::delete_framework_input::Builder,
    }
    impl<C, M, R> DeleteFramework<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteFrameworkOutput,
            smithy_http::result::SdkError<crate::error::DeleteFrameworkError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DeleteFrameworkInputOperationOutputAlias,
                crate::output::DeleteFrameworkOutput,
                crate::error::DeleteFrameworkError,
                crate::input::DeleteFrameworkInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The unique name of a framework.</p>
        pub fn framework_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.framework_name(inp);
            self
        }
        pub fn set_framework_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_framework_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteRecoveryPoint<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::delete_recovery_point_input::Builder,
    }
    impl<C, M, R> DeleteRecoveryPoint<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteRecoveryPointOutput,
            smithy_http::result::SdkError<crate::error::DeleteRecoveryPointError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DeleteRecoveryPointInputOperationOutputAlias,
                crate::output::DeleteRecoveryPointOutput,
                crate::error::DeleteRecoveryPointError,
                crate::input::DeleteRecoveryPointInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of a logical container where backups are stored. Backup vaults are identified
        /// by names that are unique to the account used to create them and the Amazon Web Services
        /// Region where they are created. They consist of lowercase letters, numbers, and
        /// hyphens.</p>
        pub fn backup_vault_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.backup_vault_name(inp);
            self
        }
        pub fn set_backup_vault_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_backup_vault_name(input);
            self
        }
        /// <p>An Amazon Resource Name (ARN) that uniquely identifies a recovery point; for example,
        /// <code>arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45</code>.</p>
        pub fn recovery_point_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.recovery_point_arn(inp);
            self
        }
        pub fn set_recovery_point_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_recovery_point_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteReportPlan<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::delete_report_plan_input::Builder,
    }
    impl<C, M, R> DeleteReportPlan<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteReportPlanOutput,
            smithy_http::result::SdkError<crate::error::DeleteReportPlanError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DeleteReportPlanInputOperationOutputAlias,
                crate::output::DeleteReportPlanOutput,
                crate::error::DeleteReportPlanError,
                crate::input::DeleteReportPlanInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The unique name of a report plan.</p>
        pub fn report_plan_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.report_plan_name(inp);
            self
        }
        pub fn set_report_plan_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_report_plan_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeBackupJob<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_backup_job_input::Builder,
    }
    impl<C, M, R> DescribeBackupJob<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeBackupJobOutput,
            smithy_http::result::SdkError<crate::error::DescribeBackupJobError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeBackupJobInputOperationOutputAlias,
                crate::output::DescribeBackupJobOutput,
                crate::error::DescribeBackupJobError,
                crate::input::DescribeBackupJobInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Uniquely identifies a request to Backup to back up a resource.</p>
        pub fn backup_job_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.backup_job_id(inp);
            self
        }
        pub fn set_backup_job_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_backup_job_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeBackupVault<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_backup_vault_input::Builder,
    }
    impl<C, M, R> DescribeBackupVault<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeBackupVaultOutput,
            smithy_http::result::SdkError<crate::error::DescribeBackupVaultError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeBackupVaultInputOperationOutputAlias,
                crate::output::DescribeBackupVaultOutput,
                crate::error::DescribeBackupVaultError,
                crate::input::DescribeBackupVaultInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of a logical container where backups are stored. Backup vaults are identified
        /// by names that are unique to the account used to create them and the Amazon Web Services
        /// Region where they are created. They consist of lowercase letters, numbers, and
        /// hyphens.</p>
        pub fn backup_vault_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.backup_vault_name(inp);
            self
        }
        pub fn set_backup_vault_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_backup_vault_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeCopyJob<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_copy_job_input::Builder,
    }
    impl<C, M, R> DescribeCopyJob<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeCopyJobOutput,
            smithy_http::result::SdkError<crate::error::DescribeCopyJobError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeCopyJobInputOperationOutputAlias,
                crate::output::DescribeCopyJobOutput,
                crate::error::DescribeCopyJobError,
                crate::input::DescribeCopyJobInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Uniquely identifies a copy job.</p>
        pub fn copy_job_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.copy_job_id(inp);
            self
        }
        pub fn set_copy_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_copy_job_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeFramework<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_framework_input::Builder,
    }
    impl<C, M, R> DescribeFramework<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeFrameworkOutput,
            smithy_http::result::SdkError<crate::error::DescribeFrameworkError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeFrameworkInputOperationOutputAlias,
                crate::output::DescribeFrameworkOutput,
                crate::error::DescribeFrameworkError,
                crate::input::DescribeFrameworkInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The unique name of a framework.</p>
        pub fn framework_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.framework_name(inp);
            self
        }
        pub fn set_framework_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_framework_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeGlobalSettings<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_global_settings_input::Builder,
    }
    impl<C, M, R> DescribeGlobalSettings<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeGlobalSettingsOutput,
            smithy_http::result::SdkError<crate::error::DescribeGlobalSettingsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeGlobalSettingsInputOperationOutputAlias,
                crate::output::DescribeGlobalSettingsOutput,
                crate::error::DescribeGlobalSettingsError,
                crate::input::DescribeGlobalSettingsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeProtectedResource<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_protected_resource_input::Builder,
    }
    impl<C, M, R> DescribeProtectedResource<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeProtectedResourceOutput,
            smithy_http::result::SdkError<crate::error::DescribeProtectedResourceError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeProtectedResourceInputOperationOutputAlias,
                crate::output::DescribeProtectedResourceOutput,
                crate::error::DescribeProtectedResourceError,
                crate::input::DescribeProtectedResourceInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>An Amazon Resource Name (ARN) that uniquely identifies a resource. The format of the ARN
        /// depends on the resource type.</p>
        pub fn resource_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(inp);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeRecoveryPoint<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_recovery_point_input::Builder,
    }
    impl<C, M, R> DescribeRecoveryPoint<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeRecoveryPointOutput,
            smithy_http::result::SdkError<crate::error::DescribeRecoveryPointError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeRecoveryPointInputOperationOutputAlias,
                crate::output::DescribeRecoveryPointOutput,
                crate::error::DescribeRecoveryPointError,
                crate::input::DescribeRecoveryPointInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of a logical container where backups are stored. Backup vaults are identified
        /// by names that are unique to the account used to create them and the Amazon Web Services
        /// Region where they are created. They consist of lowercase letters, numbers, and
        /// hyphens.</p>
        pub fn backup_vault_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.backup_vault_name(inp);
            self
        }
        pub fn set_backup_vault_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_backup_vault_name(input);
            self
        }
        /// <p>An Amazon Resource Name (ARN) that uniquely identifies a recovery point; for example,
        /// <code>arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45</code>.</p>
        pub fn recovery_point_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.recovery_point_arn(inp);
            self
        }
        pub fn set_recovery_point_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_recovery_point_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeRegionSettings<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_region_settings_input::Builder,
    }
    impl<C, M, R> DescribeRegionSettings<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeRegionSettingsOutput,
            smithy_http::result::SdkError<crate::error::DescribeRegionSettingsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeRegionSettingsInputOperationOutputAlias,
                crate::output::DescribeRegionSettingsOutput,
                crate::error::DescribeRegionSettingsError,
                crate::input::DescribeRegionSettingsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeReportJob<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_report_job_input::Builder,
    }
    impl<C, M, R> DescribeReportJob<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeReportJobOutput,
            smithy_http::result::SdkError<crate::error::DescribeReportJobError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeReportJobInputOperationOutputAlias,
                crate::output::DescribeReportJobOutput,
                crate::error::DescribeReportJobError,
                crate::input::DescribeReportJobInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier of the report job. A unique, randomly generated, Unicode, UTF-8 encoded
        /// string that is at most 1,024 bytes long. The report job ID cannot be edited.</p>
        pub fn report_job_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.report_job_id(inp);
            self
        }
        pub fn set_report_job_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_report_job_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeReportPlan<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_report_plan_input::Builder,
    }
    impl<C, M, R> DescribeReportPlan<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeReportPlanOutput,
            smithy_http::result::SdkError<crate::error::DescribeReportPlanError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeReportPlanInputOperationOutputAlias,
                crate::output::DescribeReportPlanOutput,
                crate::error::DescribeReportPlanError,
                crate::input::DescribeReportPlanInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The unique name of a report plan.</p>
        pub fn report_plan_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.report_plan_name(inp);
            self
        }
        pub fn set_report_plan_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_report_plan_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeRestoreJob<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_restore_job_input::Builder,
    }
    impl<C, M, R> DescribeRestoreJob<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeRestoreJobOutput,
            smithy_http::result::SdkError<crate::error::DescribeRestoreJobError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeRestoreJobInputOperationOutputAlias,
                crate::output::DescribeRestoreJobOutput,
                crate::error::DescribeRestoreJobError,
                crate::input::DescribeRestoreJobInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Uniquely identifies the job that restores a recovery point.</p>
        pub fn restore_job_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.restore_job_id(inp);
            self
        }
        pub fn set_restore_job_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_restore_job_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DisassociateRecoveryPoint<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::disassociate_recovery_point_input::Builder,
    }
    impl<C, M, R> DisassociateRecoveryPoint<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DisassociateRecoveryPointOutput,
            smithy_http::result::SdkError<crate::error::DisassociateRecoveryPointError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DisassociateRecoveryPointInputOperationOutputAlias,
                crate::output::DisassociateRecoveryPointOutput,
                crate::error::DisassociateRecoveryPointError,
                crate::input::DisassociateRecoveryPointInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The unique name of an Backup vault.</p>
        pub fn backup_vault_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.backup_vault_name(inp);
            self
        }
        pub fn set_backup_vault_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_backup_vault_name(input);
            self
        }
        /// <p>An Amazon Resource Name (ARN) that uniquely identifies an Backup recovery
        /// point.</p>
        pub fn recovery_point_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.recovery_point_arn(inp);
            self
        }
        pub fn set_recovery_point_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_recovery_point_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ExportBackupPlanTemplate<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::export_backup_plan_template_input::Builder,
    }
    impl<C, M, R> ExportBackupPlanTemplate<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ExportBackupPlanTemplateOutput,
            smithy_http::result::SdkError<crate::error::ExportBackupPlanTemplateError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ExportBackupPlanTemplateInputOperationOutputAlias,
                crate::output::ExportBackupPlanTemplateOutput,
                crate::error::ExportBackupPlanTemplateError,
                crate::input::ExportBackupPlanTemplateInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Uniquely identifies a backup plan.</p>
        pub fn backup_plan_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.backup_plan_id(inp);
            self
        }
        pub fn set_backup_plan_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_backup_plan_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetBackupPlan<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::get_backup_plan_input::Builder,
    }
    impl<C, M, R> GetBackupPlan<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetBackupPlanOutput,
            smithy_http::result::SdkError<crate::error::GetBackupPlanError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::GetBackupPlanInputOperationOutputAlias,
                crate::output::GetBackupPlanOutput,
                crate::error::GetBackupPlanError,
                crate::input::GetBackupPlanInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Uniquely identifies a backup plan.</p>
        pub fn backup_plan_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.backup_plan_id(inp);
            self
        }
        pub fn set_backup_plan_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_backup_plan_id(input);
            self
        }
        /// <p>Unique, randomly generated, Unicode, UTF-8 encoded strings that are at most 1,024 bytes
        /// long. Version IDs cannot be edited.</p>
        pub fn version_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.version_id(inp);
            self
        }
        pub fn set_version_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_version_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetBackupPlanFromJSON<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::get_backup_plan_from_json_input::Builder,
    }
    impl<C, M, R> GetBackupPlanFromJSON<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetBackupPlanFromJsonOutput,
            smithy_http::result::SdkError<crate::error::GetBackupPlanFromJSONError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::GetBackupPlanFromJsonInputOperationOutputAlias,
                crate::output::GetBackupPlanFromJsonOutput,
                crate::error::GetBackupPlanFromJSONError,
                crate::input::GetBackupPlanFromJsonInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A customer-supplied backup plan document in JSON format.</p>
        pub fn backup_plan_template_json(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.backup_plan_template_json(inp);
            self
        }
        pub fn set_backup_plan_template_json(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_backup_plan_template_json(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetBackupPlanFromTemplate<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::get_backup_plan_from_template_input::Builder,
    }
    impl<C, M, R> GetBackupPlanFromTemplate<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetBackupPlanFromTemplateOutput,
            smithy_http::result::SdkError<crate::error::GetBackupPlanFromTemplateError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::GetBackupPlanFromTemplateInputOperationOutputAlias,
                crate::output::GetBackupPlanFromTemplateOutput,
                crate::error::GetBackupPlanFromTemplateError,
                crate::input::GetBackupPlanFromTemplateInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Uniquely identifies a stored backup plan template.</p>
        pub fn backup_plan_template_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.backup_plan_template_id(inp);
            self
        }
        pub fn set_backup_plan_template_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_backup_plan_template_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetBackupSelection<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::get_backup_selection_input::Builder,
    }
    impl<C, M, R> GetBackupSelection<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetBackupSelectionOutput,
            smithy_http::result::SdkError<crate::error::GetBackupSelectionError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::GetBackupSelectionInputOperationOutputAlias,
                crate::output::GetBackupSelectionOutput,
                crate::error::GetBackupSelectionError,
                crate::input::GetBackupSelectionInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Uniquely identifies a backup plan.</p>
        pub fn backup_plan_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.backup_plan_id(inp);
            self
        }
        pub fn set_backup_plan_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_backup_plan_id(input);
            self
        }
        /// <p>Uniquely identifies the body of a request to assign a set of resources to a backup
        /// plan.</p>
        pub fn selection_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.selection_id(inp);
            self
        }
        pub fn set_selection_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_selection_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetBackupVaultAccessPolicy<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::get_backup_vault_access_policy_input::Builder,
    }
    impl<C, M, R> GetBackupVaultAccessPolicy<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetBackupVaultAccessPolicyOutput,
            smithy_http::result::SdkError<crate::error::GetBackupVaultAccessPolicyError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::GetBackupVaultAccessPolicyInputOperationOutputAlias,
                crate::output::GetBackupVaultAccessPolicyOutput,
                crate::error::GetBackupVaultAccessPolicyError,
                crate::input::GetBackupVaultAccessPolicyInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of a logical container where backups are stored. Backup vaults are identified
        /// by names that are unique to the account used to create them and the Amazon Web Services
        /// Region where they are created. They consist of lowercase letters, numbers, and
        /// hyphens.</p>
        pub fn backup_vault_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.backup_vault_name(inp);
            self
        }
        pub fn set_backup_vault_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_backup_vault_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetBackupVaultNotifications<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::get_backup_vault_notifications_input::Builder,
    }
    impl<C, M, R> GetBackupVaultNotifications<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetBackupVaultNotificationsOutput,
            smithy_http::result::SdkError<crate::error::GetBackupVaultNotificationsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::GetBackupVaultNotificationsInputOperationOutputAlias,
                crate::output::GetBackupVaultNotificationsOutput,
                crate::error::GetBackupVaultNotificationsError,
                crate::input::GetBackupVaultNotificationsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of a logical container where backups are stored. Backup vaults are identified
        /// by names that are unique to the account used to create them and the Amazon Web Services
        /// Region where they are created. They consist of lowercase letters, numbers, and
        /// hyphens.</p>
        pub fn backup_vault_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.backup_vault_name(inp);
            self
        }
        pub fn set_backup_vault_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_backup_vault_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetRecoveryPointRestoreMetadata<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::get_recovery_point_restore_metadata_input::Builder,
    }
    impl<C, M, R> GetRecoveryPointRestoreMetadata<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetRecoveryPointRestoreMetadataOutput,
            smithy_http::result::SdkError<crate::error::GetRecoveryPointRestoreMetadataError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::GetRecoveryPointRestoreMetadataInputOperationOutputAlias,
                crate::output::GetRecoveryPointRestoreMetadataOutput,
                crate::error::GetRecoveryPointRestoreMetadataError,
                crate::input::GetRecoveryPointRestoreMetadataInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of a logical container where backups are stored. Backup vaults are identified
        /// by names that are unique to the account used to create them and the Amazon Web Services
        /// Region where they are created. They consist of lowercase letters, numbers, and
        /// hyphens.</p>
        pub fn backup_vault_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.backup_vault_name(inp);
            self
        }
        pub fn set_backup_vault_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_backup_vault_name(input);
            self
        }
        /// <p>An Amazon Resource Name (ARN) that uniquely identifies a recovery point; for example,
        /// <code>arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45</code>.</p>
        pub fn recovery_point_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.recovery_point_arn(inp);
            self
        }
        pub fn set_recovery_point_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_recovery_point_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetSupportedResourceTypes<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::get_supported_resource_types_input::Builder,
    }
    impl<C, M, R> GetSupportedResourceTypes<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetSupportedResourceTypesOutput,
            smithy_http::result::SdkError<crate::error::GetSupportedResourceTypesError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::GetSupportedResourceTypesInputOperationOutputAlias,
                crate::output::GetSupportedResourceTypesOutput,
                crate::error::GetSupportedResourceTypesError,
                crate::input::GetSupportedResourceTypesInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListBackupJobs<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_backup_jobs_input::Builder,
    }
    impl<C, M, R> ListBackupJobs<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListBackupJobsOutput,
            smithy_http::result::SdkError<crate::error::ListBackupJobsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListBackupJobsInputOperationOutputAlias,
                crate::output::ListBackupJobsOutput,
                crate::error::ListBackupJobsError,
                crate::input::ListBackupJobsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The next item following a partial list of returned items. For example, if a request is
        /// made to return <code>maxResults</code> number of items, <code>NextToken</code> allows you
        /// to return more items in your list starting at the location pointed to by the next
        /// token.</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of items to be returned.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>Returns only backup jobs that match the specified resource Amazon Resource Name
        /// (ARN).</p>
        pub fn by_resource_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.by_resource_arn(inp);
            self
        }
        pub fn set_by_resource_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_by_resource_arn(input);
            self
        }
        /// <p>Returns only backup jobs that are in the specified state.</p>
        pub fn by_state(mut self, inp: crate::model::BackupJobState) -> Self {
            self.inner = self.inner.by_state(inp);
            self
        }
        pub fn set_by_state(
            mut self,
            input: std::option::Option<crate::model::BackupJobState>,
        ) -> Self {
            self.inner = self.inner.set_by_state(input);
            self
        }
        /// <p>Returns only backup jobs that will be stored in the specified backup vault. Backup
        /// vaults are identified by names that are unique to the account used to create them and the
        /// Amazon Web Services Region where they are created. They consist of lowercase letters,
        /// numbers, and hyphens.</p>
        pub fn by_backup_vault_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.by_backup_vault_name(inp);
            self
        }
        pub fn set_by_backup_vault_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_by_backup_vault_name(input);
            self
        }
        /// <p>Returns only backup jobs that were created before the specified date.</p>
        pub fn by_created_before(mut self, inp: smithy_types::Instant) -> Self {
            self.inner = self.inner.by_created_before(inp);
            self
        }
        pub fn set_by_created_before(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.inner = self.inner.set_by_created_before(input);
            self
        }
        /// <p>Returns only backup jobs that were created after the specified date.</p>
        pub fn by_created_after(mut self, inp: smithy_types::Instant) -> Self {
            self.inner = self.inner.by_created_after(inp);
            self
        }
        pub fn set_by_created_after(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.inner = self.inner.set_by_created_after(input);
            self
        }
        /// <p>Returns only backup jobs for the specified resources:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>DynamoDB</code> for Amazon DynamoDB</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>EBS</code> for Amazon Elastic Block Store</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>EC2</code> for Amazon Elastic Compute Cloud</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>EFS</code> for Amazon Elastic File System</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>RDS</code> for Amazon Relational Database Service</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Aurora</code> for Amazon Aurora</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Storage Gateway</code> for Storage Gateway</p>
        /// </li>
        /// </ul>
        pub fn by_resource_type(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.by_resource_type(inp);
            self
        }
        pub fn set_by_resource_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_by_resource_type(input);
            self
        }
        /// <p>The account ID to list the jobs from. Returns only backup jobs associated with the
        /// specified account ID.</p>
        /// <p>If used from an Organizations management account, passing <code>*</code> returns
        /// all jobs across the organization.</p>
        pub fn by_account_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.by_account_id(inp);
            self
        }
        pub fn set_by_account_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_by_account_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListBackupPlans<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_backup_plans_input::Builder,
    }
    impl<C, M, R> ListBackupPlans<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListBackupPlansOutput,
            smithy_http::result::SdkError<crate::error::ListBackupPlansError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListBackupPlansInputOperationOutputAlias,
                crate::output::ListBackupPlansOutput,
                crate::error::ListBackupPlansError,
                crate::input::ListBackupPlansInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The next item following a partial list of returned items. For example, if a request is
        /// made to return <code>maxResults</code> number of items, <code>NextToken</code> allows you
        /// to return more items in your list starting at the location pointed to by the next
        /// token.</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of items to be returned.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>A Boolean value with a default value of <code>FALSE</code> that returns deleted backup
        /// plans when set to <code>TRUE</code>.</p>
        pub fn include_deleted(mut self, inp: bool) -> Self {
            self.inner = self.inner.include_deleted(inp);
            self
        }
        pub fn set_include_deleted(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_include_deleted(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListBackupPlanTemplates<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_backup_plan_templates_input::Builder,
    }
    impl<C, M, R> ListBackupPlanTemplates<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListBackupPlanTemplatesOutput,
            smithy_http::result::SdkError<crate::error::ListBackupPlanTemplatesError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListBackupPlanTemplatesInputOperationOutputAlias,
                crate::output::ListBackupPlanTemplatesOutput,
                crate::error::ListBackupPlanTemplatesError,
                crate::input::ListBackupPlanTemplatesInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The next item following a partial list of returned items. For example, if a request is
        /// made to return <code>maxResults</code> number of items, <code>NextToken</code> allows you
        /// to return more items in your list starting at the location pointed to by the next
        /// token.</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of items to be returned.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListBackupPlanVersions<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_backup_plan_versions_input::Builder,
    }
    impl<C, M, R> ListBackupPlanVersions<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListBackupPlanVersionsOutput,
            smithy_http::result::SdkError<crate::error::ListBackupPlanVersionsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListBackupPlanVersionsInputOperationOutputAlias,
                crate::output::ListBackupPlanVersionsOutput,
                crate::error::ListBackupPlanVersionsError,
                crate::input::ListBackupPlanVersionsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Uniquely identifies a backup plan.</p>
        pub fn backup_plan_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.backup_plan_id(inp);
            self
        }
        pub fn set_backup_plan_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_backup_plan_id(input);
            self
        }
        /// <p>The next item following a partial list of returned items. For example, if a request is
        /// made to return <code>maxResults</code> number of items, <code>NextToken</code> allows you
        /// to return more items in your list starting at the location pointed to by the next
        /// token.</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of items to be returned.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListBackupSelections<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_backup_selections_input::Builder,
    }
    impl<C, M, R> ListBackupSelections<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListBackupSelectionsOutput,
            smithy_http::result::SdkError<crate::error::ListBackupSelectionsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListBackupSelectionsInputOperationOutputAlias,
                crate::output::ListBackupSelectionsOutput,
                crate::error::ListBackupSelectionsError,
                crate::input::ListBackupSelectionsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Uniquely identifies a backup plan.</p>
        pub fn backup_plan_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.backup_plan_id(inp);
            self
        }
        pub fn set_backup_plan_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_backup_plan_id(input);
            self
        }
        /// <p>The next item following a partial list of returned items. For example, if a request is
        /// made to return <code>maxResults</code> number of items, <code>NextToken</code> allows you
        /// to return more items in your list starting at the location pointed to by the next
        /// token.</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of items to be returned.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListBackupVaults<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_backup_vaults_input::Builder,
    }
    impl<C, M, R> ListBackupVaults<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListBackupVaultsOutput,
            smithy_http::result::SdkError<crate::error::ListBackupVaultsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListBackupVaultsInputOperationOutputAlias,
                crate::output::ListBackupVaultsOutput,
                crate::error::ListBackupVaultsError,
                crate::input::ListBackupVaultsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The next item following a partial list of returned items. For example, if a request is
        /// made to return <code>maxResults</code> number of items, <code>NextToken</code> allows you
        /// to return more items in your list starting at the location pointed to by the next
        /// token.</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of items to be returned.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListCopyJobs<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_copy_jobs_input::Builder,
    }
    impl<C, M, R> ListCopyJobs<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListCopyJobsOutput,
            smithy_http::result::SdkError<crate::error::ListCopyJobsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListCopyJobsInputOperationOutputAlias,
                crate::output::ListCopyJobsOutput,
                crate::error::ListCopyJobsError,
                crate::input::ListCopyJobsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The next item following a partial list of returned items. For example, if a request is
        /// made to return maxResults number of items, NextToken allows you to return more items in
        /// your list starting at the location pointed to by the next token. </p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of items to be returned.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>Returns only copy jobs that match the specified resource Amazon Resource Name (ARN).
        /// </p>
        pub fn by_resource_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.by_resource_arn(inp);
            self
        }
        pub fn set_by_resource_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_by_resource_arn(input);
            self
        }
        /// <p>Returns only copy jobs that are in the specified state.</p>
        pub fn by_state(mut self, inp: crate::model::CopyJobState) -> Self {
            self.inner = self.inner.by_state(inp);
            self
        }
        pub fn set_by_state(
            mut self,
            input: std::option::Option<crate::model::CopyJobState>,
        ) -> Self {
            self.inner = self.inner.set_by_state(input);
            self
        }
        /// <p>Returns only copy jobs that were created before the specified date.</p>
        pub fn by_created_before(mut self, inp: smithy_types::Instant) -> Self {
            self.inner = self.inner.by_created_before(inp);
            self
        }
        pub fn set_by_created_before(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.inner = self.inner.set_by_created_before(input);
            self
        }
        /// <p>Returns only copy jobs that were created after the specified date.</p>
        pub fn by_created_after(mut self, inp: smithy_types::Instant) -> Self {
            self.inner = self.inner.by_created_after(inp);
            self
        }
        pub fn set_by_created_after(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.inner = self.inner.set_by_created_after(input);
            self
        }
        /// <p>Returns only backup jobs for the specified resources:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>DynamoDB</code> for Amazon DynamoDB</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>EBS</code> for Amazon Elastic Block Store</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>EC2</code> for Amazon Elastic Compute Cloud</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>EFS</code> for Amazon Elastic File System</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>RDS</code> for Amazon Relational Database Service</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Aurora</code> for Amazon Aurora</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Storage Gateway</code> for Storage Gateway</p>
        /// </li>
        /// </ul>
        pub fn by_resource_type(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.by_resource_type(inp);
            self
        }
        pub fn set_by_resource_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_by_resource_type(input);
            self
        }
        /// <p>An Amazon Resource Name (ARN) that uniquely identifies a source backup vault to copy
        /// from; for example, <code>arn:aws:backup:us-east-1:123456789012:vault:aBackupVault</code>.
        /// </p>
        pub fn by_destination_vault_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.by_destination_vault_arn(inp);
            self
        }
        pub fn set_by_destination_vault_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_by_destination_vault_arn(input);
            self
        }
        /// <p>The account ID to list the jobs from. Returns only copy jobs associated with the
        /// specified account ID.</p>
        pub fn by_account_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.by_account_id(inp);
            self
        }
        pub fn set_by_account_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_by_account_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListFrameworks<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_frameworks_input::Builder,
    }
    impl<C, M, R> ListFrameworks<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListFrameworksOutput,
            smithy_http::result::SdkError<crate::error::ListFrameworksError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListFrameworksInputOperationOutputAlias,
                crate::output::ListFrameworksOutput,
                crate::error::ListFrameworksError,
                crate::input::ListFrameworksInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The number of desired results from 1 to 1000. Optional. If unspecified, the query will
        /// return 1 MB of data.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>An identifier that was returned from the previous call to this operation, which can be
        /// used to return the next set of items in the list.</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListProtectedResources<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_protected_resources_input::Builder,
    }
    impl<C, M, R> ListProtectedResources<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListProtectedResourcesOutput,
            smithy_http::result::SdkError<crate::error::ListProtectedResourcesError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListProtectedResourcesInputOperationOutputAlias,
                crate::output::ListProtectedResourcesOutput,
                crate::error::ListProtectedResourcesError,
                crate::input::ListProtectedResourcesInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The next item following a partial list of returned items. For example, if a request is
        /// made to return <code>maxResults</code> number of items, <code>NextToken</code> allows you
        /// to return more items in your list starting at the location pointed to by the next
        /// token.</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of items to be returned.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListRecoveryPointsByBackupVault<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_recovery_points_by_backup_vault_input::Builder,
    }
    impl<C, M, R> ListRecoveryPointsByBackupVault<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListRecoveryPointsByBackupVaultOutput,
            smithy_http::result::SdkError<crate::error::ListRecoveryPointsByBackupVaultError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListRecoveryPointsByBackupVaultInputOperationOutputAlias,
                crate::output::ListRecoveryPointsByBackupVaultOutput,
                crate::error::ListRecoveryPointsByBackupVaultError,
                crate::input::ListRecoveryPointsByBackupVaultInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of a logical container where backups are stored. Backup vaults are identified
        /// by names that are unique to the account used to create them and the Amazon Web Services
        /// Region where they are created. They consist of lowercase letters, numbers, and
        /// hyphens.</p>
        /// <note>
        /// <p>Backup vault name might not be available when a supported service creates the
        /// backup.</p>
        /// </note>
        pub fn backup_vault_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.backup_vault_name(inp);
            self
        }
        pub fn set_backup_vault_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_backup_vault_name(input);
            self
        }
        /// <p>The next item following a partial list of returned items. For example, if a request is
        /// made to return <code>maxResults</code> number of items, <code>NextToken</code> allows you
        /// to return more items in your list starting at the location pointed to by the next
        /// token.</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of items to be returned.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>Returns only recovery points that match the specified resource Amazon Resource Name
        /// (ARN).</p>
        pub fn by_resource_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.by_resource_arn(inp);
            self
        }
        pub fn set_by_resource_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_by_resource_arn(input);
            self
        }
        /// <p>Returns only recovery points that match the specified resource type.</p>
        pub fn by_resource_type(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.by_resource_type(inp);
            self
        }
        pub fn set_by_resource_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_by_resource_type(input);
            self
        }
        /// <p>Returns only recovery points that match the specified backup plan ID.</p>
        pub fn by_backup_plan_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.by_backup_plan_id(inp);
            self
        }
        pub fn set_by_backup_plan_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_by_backup_plan_id(input);
            self
        }
        /// <p>Returns only recovery points that were created before the specified timestamp.</p>
        pub fn by_created_before(mut self, inp: smithy_types::Instant) -> Self {
            self.inner = self.inner.by_created_before(inp);
            self
        }
        pub fn set_by_created_before(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.inner = self.inner.set_by_created_before(input);
            self
        }
        /// <p>Returns only recovery points that were created after the specified timestamp.</p>
        pub fn by_created_after(mut self, inp: smithy_types::Instant) -> Self {
            self.inner = self.inner.by_created_after(inp);
            self
        }
        pub fn set_by_created_after(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.inner = self.inner.set_by_created_after(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListRecoveryPointsByResource<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_recovery_points_by_resource_input::Builder,
    }
    impl<C, M, R> ListRecoveryPointsByResource<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListRecoveryPointsByResourceOutput,
            smithy_http::result::SdkError<crate::error::ListRecoveryPointsByResourceError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListRecoveryPointsByResourceInputOperationOutputAlias,
                crate::output::ListRecoveryPointsByResourceOutput,
                crate::error::ListRecoveryPointsByResourceError,
                crate::input::ListRecoveryPointsByResourceInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>An ARN that uniquely identifies a resource. The format of the ARN depends on the
        /// resource type.</p>
        pub fn resource_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(inp);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// <p>The next item following a partial list of returned items. For example, if a request is
        /// made to return <code>maxResults</code> number of items, <code>NextToken</code> allows you
        /// to return more items in your list starting at the location pointed to by the next
        /// token.</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of items to be returned.</p>
        /// <note>
        /// <p>Amazon RDS requires a value of at least 20.</p>
        /// </note>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListReportJobs<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_report_jobs_input::Builder,
    }
    impl<C, M, R> ListReportJobs<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListReportJobsOutput,
            smithy_http::result::SdkError<crate::error::ListReportJobsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListReportJobsInputOperationOutputAlias,
                crate::output::ListReportJobsOutput,
                crate::error::ListReportJobsError,
                crate::input::ListReportJobsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Returns only report jobs with the specified report plan name.</p>
        pub fn by_report_plan_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.by_report_plan_name(inp);
            self
        }
        pub fn set_by_report_plan_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_by_report_plan_name(input);
            self
        }
        /// <p>Returns only report jobs that were created before the date and time specified in Unix
        /// format and Coordinated Universal Time (UTC). For example, the value 1516925490 represents
        /// Friday, January 26, 2018 12:11:30 AM.</p>
        pub fn by_creation_before(mut self, inp: smithy_types::Instant) -> Self {
            self.inner = self.inner.by_creation_before(inp);
            self
        }
        pub fn set_by_creation_before(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.inner = self.inner.set_by_creation_before(input);
            self
        }
        /// <p>Returns only report jobs that were created after the date and time specified in Unix
        /// format and Coordinated Universal Time (UTC). For example, the value 1516925490 represents
        /// Friday, January 26, 2018 12:11:30 AM.</p>
        pub fn by_creation_after(mut self, inp: smithy_types::Instant) -> Self {
            self.inner = self.inner.by_creation_after(inp);
            self
        }
        pub fn set_by_creation_after(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.inner = self.inner.set_by_creation_after(input);
            self
        }
        /// <p>Returns only report jobs that are in the specified status. The statuses are:</p>
        /// <p>
        /// <code>CREATED | RUNNING | COMPLETED | FAILED</code>
        /// </p>
        pub fn by_status(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.by_status(inp);
            self
        }
        pub fn set_by_status(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_by_status(input);
            self
        }
        /// <p>The number of desired results from 1 to 1000. Optional. If unspecified, the query will
        /// return 1 MB of data.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>An identifier that was returned from the previous call to this operation, which can be
        /// used to return the next set of items in the list.</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListReportPlans<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_report_plans_input::Builder,
    }
    impl<C, M, R> ListReportPlans<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListReportPlansOutput,
            smithy_http::result::SdkError<crate::error::ListReportPlansError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListReportPlansInputOperationOutputAlias,
                crate::output::ListReportPlansOutput,
                crate::error::ListReportPlansError,
                crate::input::ListReportPlansInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The number of desired results from 1 to 1000. Optional. If unspecified, the query will
        /// return 1 MB of data.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>An identifier that was returned from the previous call to this operation, which can be
        /// used to return the next set of items in the list.</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListRestoreJobs<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_restore_jobs_input::Builder,
    }
    impl<C, M, R> ListRestoreJobs<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListRestoreJobsOutput,
            smithy_http::result::SdkError<crate::error::ListRestoreJobsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListRestoreJobsInputOperationOutputAlias,
                crate::output::ListRestoreJobsOutput,
                crate::error::ListRestoreJobsError,
                crate::input::ListRestoreJobsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The next item following a partial list of returned items. For example, if a request is
        /// made to return <code>maxResults</code> number of items, <code>NextToken</code> allows you
        /// to return more items in your list starting at the location pointed to by the next
        /// token.</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of items to be returned.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The account ID to list the jobs from. Returns only restore jobs associated with the
        /// specified account ID.</p>
        pub fn by_account_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.by_account_id(inp);
            self
        }
        pub fn set_by_account_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_by_account_id(input);
            self
        }
        /// <p>Returns only restore jobs that were created before the specified date.</p>
        pub fn by_created_before(mut self, inp: smithy_types::Instant) -> Self {
            self.inner = self.inner.by_created_before(inp);
            self
        }
        pub fn set_by_created_before(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.inner = self.inner.set_by_created_before(input);
            self
        }
        /// <p>Returns only restore jobs that were created after the specified date.</p>
        pub fn by_created_after(mut self, inp: smithy_types::Instant) -> Self {
            self.inner = self.inner.by_created_after(inp);
            self
        }
        pub fn set_by_created_after(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.inner = self.inner.set_by_created_after(input);
            self
        }
        /// <p>Returns only restore jobs associated with the specified job status.</p>
        pub fn by_status(mut self, inp: crate::model::RestoreJobStatus) -> Self {
            self.inner = self.inner.by_status(inp);
            self
        }
        pub fn set_by_status(
            mut self,
            input: std::option::Option<crate::model::RestoreJobStatus>,
        ) -> Self {
            self.inner = self.inner.set_by_status(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListTags<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_tags_input::Builder,
    }
    impl<C, M, R> ListTags<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListTagsOutput,
            smithy_http::result::SdkError<crate::error::ListTagsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListTagsInputOperationOutputAlias,
                crate::output::ListTagsOutput,
                crate::error::ListTagsError,
                crate::input::ListTagsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>An Amazon Resource Name (ARN) that uniquely identifies a resource. The format of the ARN
        /// depends on the type of resource. Valid targets for <code>ListTags</code> are recovery
        /// points, backup plans, and backup vaults.</p>
        pub fn resource_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(inp);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// <p>The next item following a partial list of returned items. For example, if a request is
        /// made to return <code>maxResults</code> number of items, <code>NextToken</code> allows you
        /// to return more items in your list starting at the location pointed to by the next
        /// token.</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of items to be returned.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutBackupVaultAccessPolicy<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::put_backup_vault_access_policy_input::Builder,
    }
    impl<C, M, R> PutBackupVaultAccessPolicy<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutBackupVaultAccessPolicyOutput,
            smithy_http::result::SdkError<crate::error::PutBackupVaultAccessPolicyError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::PutBackupVaultAccessPolicyInputOperationOutputAlias,
                crate::output::PutBackupVaultAccessPolicyOutput,
                crate::error::PutBackupVaultAccessPolicyError,
                crate::input::PutBackupVaultAccessPolicyInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of a logical container where backups are stored. Backup vaults are identified
        /// by names that are unique to the account used to create them and the Amazon Web Services
        /// Region where they are created. They consist of lowercase letters, numbers, and
        /// hyphens.</p>
        pub fn backup_vault_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.backup_vault_name(inp);
            self
        }
        pub fn set_backup_vault_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_backup_vault_name(input);
            self
        }
        /// <p>The backup vault access policy document in JSON format.</p>
        pub fn policy(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy(inp);
            self
        }
        pub fn set_policy(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_policy(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutBackupVaultNotifications<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::put_backup_vault_notifications_input::Builder,
    }
    impl<C, M, R> PutBackupVaultNotifications<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutBackupVaultNotificationsOutput,
            smithy_http::result::SdkError<crate::error::PutBackupVaultNotificationsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::PutBackupVaultNotificationsInputOperationOutputAlias,
                crate::output::PutBackupVaultNotificationsOutput,
                crate::error::PutBackupVaultNotificationsError,
                crate::input::PutBackupVaultNotificationsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of a logical container where backups are stored. Backup vaults are identified
        /// by names that are unique to the account used to create them and the Amazon Web Services
        /// Region where they are created. They consist of lowercase letters, numbers, and
        /// hyphens.</p>
        pub fn backup_vault_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.backup_vault_name(inp);
            self
        }
        pub fn set_backup_vault_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_backup_vault_name(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) that specifies the topic for a backup vaults events; for
        /// example, <code>arn:aws:sns:us-west-2:111122223333:MyVaultTopic</code>.</p>
        pub fn sns_topic_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.sns_topic_arn(inp);
            self
        }
        pub fn set_sns_topic_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_sns_topic_arn(input);
            self
        }
        /// Appends an item to `BackupVaultEvents`.
        ///
        /// To override the contents of this collection use [`set_backup_vault_events`](Self::set_backup_vault_events).
        /// <p>An array of events that indicate the status of jobs to back up resources to the backup
        /// vault.</p>
        /// <note>
        /// <p>The following events are supported:</p>
        /// <p>
        /// <code>BACKUP_JOB_STARTED</code>, <code>BACKUP_JOB_COMPLETED</code>,</p>
        /// <p>
        /// <code>COPY_JOB_STARTED</code>, <code>COPY_JOB_SUCCESSFUL</code>,
        /// <code>COPY_JOB_FAILED</code>,</p>
        /// <p>
        /// <code>RESTORE_JOB_STARTED</code>, <code>RESTORE_JOB_COMPLETED</code>, and
        /// <code>RECOVERY_POINT_MODIFIED</code>.</p>
        /// <p>To find failed backup jobs, use <code>BACKUP_JOB_COMPLETED</code> and filter using
        /// event metadata.</p>
        /// <p>Other events in the following list are deprecated.</p>
        /// </note>
        pub fn backup_vault_events(
            mut self,
            inp: impl Into<crate::model::BackupVaultEvent>,
        ) -> Self {
            self.inner = self.inner.backup_vault_events(inp);
            self
        }
        pub fn set_backup_vault_events(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::BackupVaultEvent>>,
        ) -> Self {
            self.inner = self.inner.set_backup_vault_events(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StartBackupJob<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::start_backup_job_input::Builder,
    }
    impl<C, M, R> StartBackupJob<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StartBackupJobOutput,
            smithy_http::result::SdkError<crate::error::StartBackupJobError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::StartBackupJobInputOperationOutputAlias,
                crate::output::StartBackupJobOutput,
                crate::error::StartBackupJobError,
                crate::input::StartBackupJobInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of a logical container where backups are stored. Backup vaults are identified
        /// by names that are unique to the account used to create them and the Amazon Web Services
        /// Region where they are created. They consist of lowercase letters, numbers, and
        /// hyphens.</p>
        pub fn backup_vault_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.backup_vault_name(inp);
            self
        }
        pub fn set_backup_vault_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_backup_vault_name(input);
            self
        }
        /// <p>An Amazon Resource Name (ARN) that uniquely identifies a resource. The format of the ARN
        /// depends on the resource type.</p>
        pub fn resource_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(inp);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// <p>Specifies the IAM role ARN used to create the target recovery point; for example,
        /// <code>arn:aws:iam::123456789012:role/S3Access</code>.</p>
        pub fn iam_role_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.iam_role_arn(inp);
            self
        }
        pub fn set_iam_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_iam_role_arn(input);
            self
        }
        /// <p>A customer-chosen string that you can use to distinguish between otherwise identical
        /// calls to <code>StartBackupJob</code>. Retrying a successful request with the same
        /// idempotency token results in a success message with no action taken.</p>
        pub fn idempotency_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.idempotency_token(inp);
            self
        }
        pub fn set_idempotency_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_idempotency_token(input);
            self
        }
        /// <p>A value in minutes after a backup is scheduled before a job will be canceled if it
        /// doesn't start successfully. This value is optional, and the default is 8 hours.</p>
        pub fn start_window_minutes(mut self, inp: i64) -> Self {
            self.inner = self.inner.start_window_minutes(inp);
            self
        }
        pub fn set_start_window_minutes(mut self, input: std::option::Option<i64>) -> Self {
            self.inner = self.inner.set_start_window_minutes(input);
            self
        }
        /// <p>A value in minutes during which a successfully started backup must complete, or else AWS
        /// Backup will cancel the job. This value is optional. This value begins counting down from
        /// when the backup was scheduled. It does not add additional time for
        /// <code>StartWindowMinutes</code>, or if the backup started later than scheduled.</p>
        pub fn complete_window_minutes(mut self, inp: i64) -> Self {
            self.inner = self.inner.complete_window_minutes(inp);
            self
        }
        pub fn set_complete_window_minutes(mut self, input: std::option::Option<i64>) -> Self {
            self.inner = self.inner.set_complete_window_minutes(input);
            self
        }
        /// <p>The lifecycle defines when a protected resource is transitioned to cold storage and when
        /// it expires. Backup will transition and expire backups automatically according
        /// to the lifecycle that you define. </p>
        /// <p>Backups transitioned to cold storage must be stored in cold storage for a minimum of 90
        /// days. Therefore, the expire after days setting must be 90 days greater than the
        /// transition to cold after days setting. The transition to cold after days setting cannot
        /// be changed after a backup has been transitioned to cold. </p>
        /// <p>Only Amazon EFS file system backups can be transitioned to cold storage.</p>
        pub fn lifecycle(mut self, inp: crate::model::Lifecycle) -> Self {
            self.inner = self.inner.lifecycle(inp);
            self
        }
        pub fn set_lifecycle(
            mut self,
            input: std::option::Option<crate::model::Lifecycle>,
        ) -> Self {
            self.inner = self.inner.set_lifecycle(input);
            self
        }
        /// Adds a key-value pair to `RecoveryPointTags`.
        ///
        /// To override the contents of this collection use [`set_recovery_point_tags`](Self::set_recovery_point_tags).
        /// <p>To help organize your resources, you can assign your own metadata to the resources that
        /// you create. Each tag is a key-value pair.</p>
        pub fn recovery_point_tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.recovery_point_tags(k, v);
            self
        }
        pub fn set_recovery_point_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_recovery_point_tags(input);
            self
        }
        /// Adds a key-value pair to `BackupOptions`.
        ///
        /// To override the contents of this collection use [`set_backup_options`](Self::set_backup_options).
        /// <p>Specifies the backup option for a selected resource. This option is only available for
        /// Windows Volume Shadow Copy Service (VSS) backup jobs.</p>
        /// <p>Valid values: Set to <code>"WindowsVSS":"enabled"</code> to enable the
        /// <code>WindowsVSS</code> backup option and create a Windows VSS backup. Set to
        /// <code>"WindowsVSS""disabled"</code> to create a regular backup. The
        /// <code>WindowsVSS</code> option is not enabled by default.</p>
        pub fn backup_options(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.backup_options(k, v);
            self
        }
        pub fn set_backup_options(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_backup_options(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StartCopyJob<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::start_copy_job_input::Builder,
    }
    impl<C, M, R> StartCopyJob<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StartCopyJobOutput,
            smithy_http::result::SdkError<crate::error::StartCopyJobError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::StartCopyJobInputOperationOutputAlias,
                crate::output::StartCopyJobOutput,
                crate::error::StartCopyJobError,
                crate::input::StartCopyJobInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>An ARN that uniquely identifies a recovery point to use for the copy job; for example,
        /// arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
        /// </p>
        pub fn recovery_point_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.recovery_point_arn(inp);
            self
        }
        pub fn set_recovery_point_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_recovery_point_arn(input);
            self
        }
        /// <p>The name of a logical source container where backups are stored. Backup vaults are
        /// identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created. They consist of lowercase letters, numbers,
        /// and hyphens.</p>
        pub fn source_backup_vault_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.source_backup_vault_name(inp);
            self
        }
        pub fn set_source_backup_vault_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_source_backup_vault_name(input);
            self
        }
        /// <p>An Amazon Resource Name (ARN) that uniquely identifies a destination backup vault to
        /// copy to; for example,
        /// <code>arn:aws:backup:us-east-1:123456789012:vault:aBackupVault</code>.</p>
        pub fn destination_backup_vault_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.destination_backup_vault_arn(inp);
            self
        }
        pub fn set_destination_backup_vault_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_destination_backup_vault_arn(input);
            self
        }
        /// <p>Specifies the IAM role ARN used to copy the target recovery point; for example,
        /// <code>arn:aws:iam::123456789012:role/S3Access</code>.</p>
        pub fn iam_role_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.iam_role_arn(inp);
            self
        }
        pub fn set_iam_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_iam_role_arn(input);
            self
        }
        /// <p>A customer-chosen string that you can use to distinguish between otherwise identical
        /// calls to <code>StartCopyJob</code>. Retrying a successful request with the same idempotency
        /// token results in a success message with no action taken.</p>
        pub fn idempotency_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.idempotency_token(inp);
            self
        }
        pub fn set_idempotency_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_idempotency_token(input);
            self
        }
        /// <p>Contains an array of <code>Transition</code> objects specifying how long in days before
        /// a recovery point transitions to cold storage or is deleted.</p>
        /// <p>Backups transitioned to cold storage must be stored in cold storage for a minimum of 90
        /// days. Therefore, on the console, the expire after days setting must be 90 days greater
        /// than the transition to cold after days setting. The transition to cold after days
        /// setting cannot be changed after a backup has been transitioned to cold.</p>
        /// <p>Only Amazon EFS file system backups can be transitioned to cold storage.</p>
        pub fn lifecycle(mut self, inp: crate::model::Lifecycle) -> Self {
            self.inner = self.inner.lifecycle(inp);
            self
        }
        pub fn set_lifecycle(
            mut self,
            input: std::option::Option<crate::model::Lifecycle>,
        ) -> Self {
            self.inner = self.inner.set_lifecycle(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StartReportJob<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::start_report_job_input::Builder,
    }
    impl<C, M, R> StartReportJob<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StartReportJobOutput,
            smithy_http::result::SdkError<crate::error::StartReportJobError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::StartReportJobInputOperationOutputAlias,
                crate::output::StartReportJobOutput,
                crate::error::StartReportJobError,
                crate::input::StartReportJobInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The unique name of a report plan.</p>
        pub fn report_plan_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.report_plan_name(inp);
            self
        }
        pub fn set_report_plan_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_report_plan_name(input);
            self
        }
        /// <p>A customer-chosen string that you can use to distinguish between otherwise identical
        /// calls to <code>StartReportJobInput</code>. Retrying a successful request with the same
        /// idempotency token results in a success message with no action taken.</p>
        pub fn idempotency_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.idempotency_token(inp);
            self
        }
        pub fn set_idempotency_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_idempotency_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StartRestoreJob<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::start_restore_job_input::Builder,
    }
    impl<C, M, R> StartRestoreJob<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StartRestoreJobOutput,
            smithy_http::result::SdkError<crate::error::StartRestoreJobError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::StartRestoreJobInputOperationOutputAlias,
                crate::output::StartRestoreJobOutput,
                crate::error::StartRestoreJobError,
                crate::input::StartRestoreJobInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>An ARN that uniquely identifies a recovery point; for example,
        /// <code>arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45</code>.</p>
        pub fn recovery_point_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.recovery_point_arn(inp);
            self
        }
        pub fn set_recovery_point_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_recovery_point_arn(input);
            self
        }
        /// Adds a key-value pair to `Metadata`.
        ///
        /// To override the contents of this collection use [`set_metadata`](Self::set_metadata).
        /// <p>A set of metadata key-value pairs. Contains information, such as a resource name,
        /// required to restore a recovery point.</p>
        /// <p> You can get configuration metadata about a resource at the time it was backed up by
        /// calling <code>GetRecoveryPointRestoreMetadata</code>. However, values in addition to those
        /// provided by <code>GetRecoveryPointRestoreMetadata</code> might be required to restore a
        /// resource. For example, you might need to provide a new resource name if the original
        /// already exists.</p>
        /// <p>You need to specify specific metadata to restore an Amazon Elastic File System (Amazon EFS) instance:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>file-system-id</code>: The ID of the Amazon EFS file system that is
        /// backed up by Backup. Returned in
        /// <code>GetRecoveryPointRestoreMetadata</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Encrypted</code>: A Boolean value that, if true, specifies that the file
        /// system is encrypted. If <code>KmsKeyId</code> is specified, <code>Encrypted</code>
        /// must be set to <code>true</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>KmsKeyId</code>: Specifies the Amazon Web Services KMS key that is used to
        /// encrypt the restored file system. You can specify a key from another Amazon Web Services account provided that key it is properly shared with your account via Amazon Web Services KMS.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>PerformanceMode</code>: Specifies the throughput mode of the file
        /// system.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>CreationToken</code>: A user-supplied value that ensures the uniqueness
        /// (idempotency) of the request.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>newFileSystem</code>: A Boolean value that, if true, specifies that the
        /// recovery point is restored to a new Amazon EFS file system.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ItemsToRestore</code>: An array of one to five strings where each string is
        /// a file path. Use <code>ItemsToRestore</code> to restore specific files or directories
        /// rather than the entire file system. This parameter is optional. For example,
        /// <code>"itemsToRestore":"[\"/my.test\"]"</code>.</p>
        /// </li>
        /// </ul>
        pub fn metadata(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.metadata(k, v);
            self
        }
        pub fn set_metadata(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_metadata(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the IAM role that Backup uses to create
        /// the target recovery point; for example,
        /// <code>arn:aws:iam::123456789012:role/S3Access</code>.</p>
        pub fn iam_role_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.iam_role_arn(inp);
            self
        }
        pub fn set_iam_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_iam_role_arn(input);
            self
        }
        /// <p>A customer-chosen string that you can use to distinguish between otherwise identical
        /// calls to <code>StartRestoreJob</code>. Retrying a successful request with the same
        /// idempotency token results in a success message with no action taken.</p>
        pub fn idempotency_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.idempotency_token(inp);
            self
        }
        pub fn set_idempotency_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_idempotency_token(input);
            self
        }
        /// <p>Starts a job to restore a recovery point for one of the following resources:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>DynamoDB</code> for Amazon DynamoDB</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>EBS</code> for Amazon Elastic Block Store</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>EC2</code> for Amazon Elastic Compute Cloud</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>EFS</code> for Amazon Elastic File System</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>RDS</code> for Amazon Relational Database Service</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Aurora</code> for Amazon Aurora</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Storage Gateway</code> for Storage Gateway</p>
        /// </li>
        /// </ul>
        pub fn resource_type(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_type(inp);
            self
        }
        pub fn set_resource_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_resource_type(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StopBackupJob<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::stop_backup_job_input::Builder,
    }
    impl<C, M, R> StopBackupJob<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StopBackupJobOutput,
            smithy_http::result::SdkError<crate::error::StopBackupJobError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::StopBackupJobInputOperationOutputAlias,
                crate::output::StopBackupJobOutput,
                crate::error::StopBackupJobError,
                crate::input::StopBackupJobInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Uniquely identifies a request to Backup to back up a resource.</p>
        pub fn backup_job_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.backup_job_id(inp);
            self
        }
        pub fn set_backup_job_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_backup_job_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct TagResource<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::tag_resource_input::Builder,
    }
    impl<C, M, R> TagResource<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::TagResourceOutput,
            smithy_http::result::SdkError<crate::error::TagResourceError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::TagResourceInputOperationOutputAlias,
                crate::output::TagResourceOutput,
                crate::error::TagResourceError,
                crate::input::TagResourceInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>An ARN that uniquely identifies a resource. The format of the ARN depends on the type of
        /// the tagged resource.</p>
        pub fn resource_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(inp);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// Adds a key-value pair to `Tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        /// <p>Key-value pairs that are used to help organize your resources. You can assign your own
        /// metadata to the resources you create.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.tags(k, v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UntagResource<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::untag_resource_input::Builder,
    }
    impl<C, M, R> UntagResource<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UntagResourceOutput,
            smithy_http::result::SdkError<crate::error::UntagResourceError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::UntagResourceInputOperationOutputAlias,
                crate::output::UntagResourceOutput,
                crate::error::UntagResourceError,
                crate::input::UntagResourceInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>An ARN that uniquely identifies a resource. The format of the ARN depends on the type of
        /// the tagged resource.</p>
        pub fn resource_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(inp);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// Appends an item to `TagKeyList`.
        ///
        /// To override the contents of this collection use [`set_tag_key_list`](Self::set_tag_key_list).
        /// <p>A list of keys to identify which key-value tags to remove from a resource.</p>
        pub fn tag_key_list(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tag_key_list(inp);
            self
        }
        pub fn set_tag_key_list(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_tag_key_list(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateBackupPlan<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::update_backup_plan_input::Builder,
    }
    impl<C, M, R> UpdateBackupPlan<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateBackupPlanOutput,
            smithy_http::result::SdkError<crate::error::UpdateBackupPlanError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::UpdateBackupPlanInputOperationOutputAlias,
                crate::output::UpdateBackupPlanOutput,
                crate::error::UpdateBackupPlanError,
                crate::input::UpdateBackupPlanInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Uniquely identifies a backup plan.</p>
        pub fn backup_plan_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.backup_plan_id(inp);
            self
        }
        pub fn set_backup_plan_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_backup_plan_id(input);
            self
        }
        /// <p>Specifies the body of a backup plan. Includes a <code>BackupPlanName</code> and one or
        /// more sets of <code>Rules</code>.</p>
        pub fn backup_plan(mut self, inp: crate::model::BackupPlanInput) -> Self {
            self.inner = self.inner.backup_plan(inp);
            self
        }
        pub fn set_backup_plan(
            mut self,
            input: std::option::Option<crate::model::BackupPlanInput>,
        ) -> Self {
            self.inner = self.inner.set_backup_plan(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateFramework<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::update_framework_input::Builder,
    }
    impl<C, M, R> UpdateFramework<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateFrameworkOutput,
            smithy_http::result::SdkError<crate::error::UpdateFrameworkError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::UpdateFrameworkInputOperationOutputAlias,
                crate::output::UpdateFrameworkOutput,
                crate::error::UpdateFrameworkError,
                crate::input::UpdateFrameworkInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The unique name of a framework. This name is between 1 and 256 characters, starting with
        /// a letter, and consisting of letters (a-z, A-Z), numbers (0-9), and underscores (_).</p>
        pub fn framework_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.framework_name(inp);
            self
        }
        pub fn set_framework_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_framework_name(input);
            self
        }
        /// <p>An optional description of the framework with a maximum 1,024 characters.</p>
        pub fn framework_description(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.framework_description(inp);
            self
        }
        pub fn set_framework_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_framework_description(input);
            self
        }
        /// Appends an item to `FrameworkControls`.
        ///
        /// To override the contents of this collection use [`set_framework_controls`](Self::set_framework_controls).
        /// <p>A list of the controls that make up the framework. Each control in the list has a name,
        /// input parameters, and scope.</p>
        pub fn framework_controls(
            mut self,
            inp: impl Into<crate::model::FrameworkControl>,
        ) -> Self {
            self.inner = self.inner.framework_controls(inp);
            self
        }
        pub fn set_framework_controls(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::FrameworkControl>>,
        ) -> Self {
            self.inner = self.inner.set_framework_controls(input);
            self
        }
        /// <p>A customer-chosen string that you can use to distinguish between otherwise identical
        /// calls to <code>UpdateFrameworkInput</code>. Retrying a successful request with the same
        /// idempotency token results in a success message with no action taken.</p>
        pub fn idempotency_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.idempotency_token(inp);
            self
        }
        pub fn set_idempotency_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_idempotency_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateGlobalSettings<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::update_global_settings_input::Builder,
    }
    impl<C, M, R> UpdateGlobalSettings<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateGlobalSettingsOutput,
            smithy_http::result::SdkError<crate::error::UpdateGlobalSettingsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::UpdateGlobalSettingsInputOperationOutputAlias,
                crate::output::UpdateGlobalSettingsOutput,
                crate::error::UpdateGlobalSettingsError,
                crate::input::UpdateGlobalSettingsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// Adds a key-value pair to `GlobalSettings`.
        ///
        /// To override the contents of this collection use [`set_global_settings`](Self::set_global_settings).
        /// <p>A value for <code>isCrossAccountBackupEnabled</code> and a Region. Example:
        /// <code>update-global-settings --global-settings isCrossAccountBackupEnabled=false
        /// --region us-west-2</code>.</p>
        pub fn global_settings(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.global_settings(k, v);
            self
        }
        pub fn set_global_settings(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_global_settings(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateRecoveryPointLifecycle<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::update_recovery_point_lifecycle_input::Builder,
    }
    impl<C, M, R> UpdateRecoveryPointLifecycle<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateRecoveryPointLifecycleOutput,
            smithy_http::result::SdkError<crate::error::UpdateRecoveryPointLifecycleError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::UpdateRecoveryPointLifecycleInputOperationOutputAlias,
                crate::output::UpdateRecoveryPointLifecycleOutput,
                crate::error::UpdateRecoveryPointLifecycleError,
                crate::input::UpdateRecoveryPointLifecycleInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of a logical container where backups are stored. Backup vaults are identified
        /// by names that are unique to the account used to create them and the Amazon Web Services
        /// Region where they are created. They consist of lowercase letters, numbers, and
        /// hyphens.</p>
        pub fn backup_vault_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.backup_vault_name(inp);
            self
        }
        pub fn set_backup_vault_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_backup_vault_name(input);
            self
        }
        /// <p>An Amazon Resource Name (ARN) that uniquely identifies a recovery point; for example,
        /// <code>arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45</code>.</p>
        pub fn recovery_point_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.recovery_point_arn(inp);
            self
        }
        pub fn set_recovery_point_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_recovery_point_arn(input);
            self
        }
        /// <p>The lifecycle defines when a protected resource is transitioned to cold storage and when
        /// it expires. Backup transitions and expires backups automatically according to
        /// the lifecycle that you define. </p>
        /// <p>Backups transitioned to cold storage must be stored in cold storage for a minimum of 90
        /// days. Therefore, the expire after days setting must be 90 days greater than the
        /// transition to cold after days setting. The transition to cold after days setting cannot
        /// be changed after a backup has been transitioned to cold. </p>
        pub fn lifecycle(mut self, inp: crate::model::Lifecycle) -> Self {
            self.inner = self.inner.lifecycle(inp);
            self
        }
        pub fn set_lifecycle(
            mut self,
            input: std::option::Option<crate::model::Lifecycle>,
        ) -> Self {
            self.inner = self.inner.set_lifecycle(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateRegionSettings<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::update_region_settings_input::Builder,
    }
    impl<C, M, R> UpdateRegionSettings<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateRegionSettingsOutput,
            smithy_http::result::SdkError<crate::error::UpdateRegionSettingsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::UpdateRegionSettingsInputOperationOutputAlias,
                crate::output::UpdateRegionSettingsOutput,
                crate::error::UpdateRegionSettingsError,
                crate::input::UpdateRegionSettingsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// Adds a key-value pair to `ResourceTypeOptInPreference`.
        ///
        /// To override the contents of this collection use [`set_resource_type_opt_in_preference`](Self::set_resource_type_opt_in_preference).
        /// <p>Updates the list of services along with the opt-in preferences for the Region.</p>
        pub fn resource_type_opt_in_preference(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<bool>,
        ) -> Self {
            self.inner = self.inner.resource_type_opt_in_preference(k, v);
            self
        }
        pub fn set_resource_type_opt_in_preference(
            mut self,
            input: std::option::Option<std::collections::HashMap<std::string::String, bool>>,
        ) -> Self {
            self.inner = self.inner.set_resource_type_opt_in_preference(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateReportPlan<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::update_report_plan_input::Builder,
    }
    impl<C, M, R> UpdateReportPlan<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateReportPlanOutput,
            smithy_http::result::SdkError<crate::error::UpdateReportPlanError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::UpdateReportPlanInputOperationOutputAlias,
                crate::output::UpdateReportPlanOutput,
                crate::error::UpdateReportPlanError,
                crate::input::UpdateReportPlanInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The unique name of the report plan. This name is between 1 and 256 characters, starting
        /// with a letter, and consisting of letters (a-z, A-Z), numbers (0-9), and underscores
        /// (_).</p>
        pub fn report_plan_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.report_plan_name(inp);
            self
        }
        pub fn set_report_plan_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_report_plan_name(input);
            self
        }
        /// <p>An optional description of the report plan with a maximum 1,024 characters.</p>
        pub fn report_plan_description(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.report_plan_description(inp);
            self
        }
        pub fn set_report_plan_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_report_plan_description(input);
            self
        }
        /// <p>A structure that contains information about where to deliver your reports, specifically
        /// your Amazon S3 bucket name, S3 key prefix, and the formats of your reports.</p>
        pub fn report_delivery_channel(mut self, inp: crate::model::ReportDeliveryChannel) -> Self {
            self.inner = self.inner.report_delivery_channel(inp);
            self
        }
        pub fn set_report_delivery_channel(
            mut self,
            input: std::option::Option<crate::model::ReportDeliveryChannel>,
        ) -> Self {
            self.inner = self.inner.set_report_delivery_channel(input);
            self
        }
        /// <p>Identifies the report template for the report. Reports are built using a report
        /// template. The report templates are:</p>
        /// <p>
        /// <code>BACKUP_JOB_REPORT | COPY_JOB_REPORT | RESTORE_JOB_REPORT</code>
        /// </p>
        pub fn report_setting(mut self, inp: crate::model::ReportSetting) -> Self {
            self.inner = self.inner.report_setting(inp);
            self
        }
        pub fn set_report_setting(
            mut self,
            input: std::option::Option<crate::model::ReportSetting>,
        ) -> Self {
            self.inner = self.inner.set_report_setting(input);
            self
        }
        /// <p>A customer-chosen string that you can use to distinguish between otherwise identical
        /// calls to <code>UpdateReportPlanInput</code>. Retrying a successful request with the same
        /// idempotency token results in a success message with no action taken.</p>
        pub fn idempotency_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.idempotency_token(inp);
            self
        }
        pub fn set_idempotency_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_idempotency_token(input);
            self
        }
    }
}
impl<C> Client<C, aws_hyper::AwsMiddleware, smithy_client::retry::Standard> {
    pub fn from_conf_conn(conf: crate::Config, conn: C) -> Self {
        let client = aws_hyper::Client::new(conn);
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
impl
    Client<
        smithy_client::erase::DynConnector,
        aws_hyper::AwsMiddleware,
        smithy_client::retry::Standard,
    >
{
    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn new(config: &aws_types::config::Config) -> Self {
        Self::from_conf(config.into())
    }

    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_conf(conf: crate::Config) -> Self {
        let client = aws_hyper::Client::https();
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
