// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
use std::fmt::Write;
/// See [`CreateBackupPlanInput`](crate::input::CreateBackupPlanInput)
pub mod create_backup_plan_input {
    /// A builder for [`CreateBackupPlanInput`](crate::input::CreateBackupPlanInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) backup_plan: std::option::Option<crate::model::BackupPlanInput>,
        pub(crate) backup_plan_tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) creator_request_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Specifies the body of a backup plan. Includes a <code>BackupPlanName</code> and one or
        /// more sets of <code>Rules</code>.</p>
        pub fn backup_plan(mut self, input: crate::model::BackupPlanInput) -> Self {
            self.backup_plan = Some(input);
            self
        }
        pub fn set_backup_plan(
            mut self,
            input: std::option::Option<crate::model::BackupPlanInput>,
        ) -> Self {
            self.backup_plan = input;
            self
        }
        pub fn backup_plan_tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.backup_plan_tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.backup_plan_tags = Some(hash_map);
            self
        }
        pub fn set_backup_plan_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.backup_plan_tags = input;
            self
        }
        /// <p>Identifies the request and allows failed requests to be retried without the risk of
        /// running the operation twice. If the request includes a <code>CreatorRequestId</code> that
        /// matches an existing backup plan, that plan is returned. This parameter is optional.</p>
        pub fn creator_request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.creator_request_id = Some(input.into());
            self
        }
        pub fn set_creator_request_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.creator_request_id = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateBackupPlanInput`](crate::input::CreateBackupPlanInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateBackupPlanInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateBackupPlanInput {
                backup_plan: self.backup_plan,
                backup_plan_tags: self.backup_plan_tags,
                creator_request_id: self.creator_request_id,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateBackupPlanInputOperationOutputAlias = crate::operation::CreateBackupPlan;
#[doc(hidden)]
pub type CreateBackupPlanInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl CreateBackupPlanInput {
    /// Consumes the builder and constructs an Operation<[`CreateBackupPlan`](crate::operation::CreateBackupPlan)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::CreateBackupPlan,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_create_backup_plan(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::CreateBackupPlan::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "CreateBackupPlan",
                "backup",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/backup/plans").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("PUT").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CreateBackupPlanInput`](crate::input::CreateBackupPlanInput)
    pub fn builder() -> crate::input::create_backup_plan_input::Builder {
        crate::input::create_backup_plan_input::Builder::default()
    }
}

/// See [`CreateBackupSelectionInput`](crate::input::CreateBackupSelectionInput)
pub mod create_backup_selection_input {
    /// A builder for [`CreateBackupSelectionInput`](crate::input::CreateBackupSelectionInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) backup_plan_id: std::option::Option<std::string::String>,
        pub(crate) backup_selection: std::option::Option<crate::model::BackupSelection>,
        pub(crate) creator_request_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Uniquely identifies the backup plan to be associated with the selection of
        /// resources.</p>
        pub fn backup_plan_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.backup_plan_id = Some(input.into());
            self
        }
        pub fn set_backup_plan_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.backup_plan_id = input;
            self
        }
        /// <p>Specifies the body of a request to assign a set of resources to a backup plan.</p>
        pub fn backup_selection(mut self, input: crate::model::BackupSelection) -> Self {
            self.backup_selection = Some(input);
            self
        }
        pub fn set_backup_selection(
            mut self,
            input: std::option::Option<crate::model::BackupSelection>,
        ) -> Self {
            self.backup_selection = input;
            self
        }
        /// <p>A unique string that identifies the request and allows failed requests to be retried
        /// without the risk of running the operation twice.</p>
        pub fn creator_request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.creator_request_id = Some(input.into());
            self
        }
        pub fn set_creator_request_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.creator_request_id = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateBackupSelectionInput`](crate::input::CreateBackupSelectionInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateBackupSelectionInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateBackupSelectionInput {
                backup_plan_id: self.backup_plan_id,
                backup_selection: self.backup_selection,
                creator_request_id: self.creator_request_id,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateBackupSelectionInputOperationOutputAlias = crate::operation::CreateBackupSelection;
#[doc(hidden)]
pub type CreateBackupSelectionInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl CreateBackupSelectionInput {
    /// Consumes the builder and constructs an Operation<[`CreateBackupSelection`](crate::operation::CreateBackupSelection)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::CreateBackupSelection,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_create_backup_selection(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::CreateBackupSelection::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "CreateBackupSelection",
                "backup",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let input_1 = &self.backup_plan_id;
        let input_1 = input_1
            .as_ref()
            .ok_or(smithy_http::operation::BuildError::MissingField {
                field: "backup_plan_id",
                details: "cannot be empty or unset",
            })?;
        let backup_plan_id = smithy_http::label::fmt_string(input_1, false);
        if backup_plan_id.is_empty() {
            return Err(smithy_http::operation::BuildError::MissingField {
                field: "backup_plan_id",
                details: "cannot be empty or unset",
            });
        }
        write!(
            output,
            "/backup/plans/{BackupPlanId}/selections",
            BackupPlanId = backup_plan_id
        )
        .expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("PUT").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CreateBackupSelectionInput`](crate::input::CreateBackupSelectionInput)
    pub fn builder() -> crate::input::create_backup_selection_input::Builder {
        crate::input::create_backup_selection_input::Builder::default()
    }
}

/// See [`CreateBackupVaultInput`](crate::input::CreateBackupVaultInput)
pub mod create_backup_vault_input {
    /// A builder for [`CreateBackupVaultInput`](crate::input::CreateBackupVaultInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) backup_vault_name: std::option::Option<std::string::String>,
        pub(crate) backup_vault_tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) encryption_key_arn: std::option::Option<std::string::String>,
        pub(crate) creator_request_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of a logical container where backups are stored. Backup vaults are identified
        /// by names that are unique to the account used to create them and the AWS Region where they
        /// are created. They consist of letters, numbers, and hyphens.</p>
        pub fn backup_vault_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.backup_vault_name = Some(input.into());
            self
        }
        pub fn set_backup_vault_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.backup_vault_name = input;
            self
        }
        pub fn backup_vault_tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.backup_vault_tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.backup_vault_tags = Some(hash_map);
            self
        }
        pub fn set_backup_vault_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.backup_vault_tags = input;
            self
        }
        /// <p>The server-side encryption key that is used to protect your backups; for example,
        /// <code>arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>.</p>
        pub fn encryption_key_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.encryption_key_arn = Some(input.into());
            self
        }
        pub fn set_encryption_key_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.encryption_key_arn = input;
            self
        }
        /// <p>A unique string that identifies the request and allows failed requests to be retried
        /// without the risk of running the operation twice.</p>
        pub fn creator_request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.creator_request_id = Some(input.into());
            self
        }
        pub fn set_creator_request_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.creator_request_id = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateBackupVaultInput`](crate::input::CreateBackupVaultInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateBackupVaultInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateBackupVaultInput {
                backup_vault_name: self.backup_vault_name,
                backup_vault_tags: self.backup_vault_tags,
                encryption_key_arn: self.encryption_key_arn,
                creator_request_id: self.creator_request_id,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateBackupVaultInputOperationOutputAlias = crate::operation::CreateBackupVault;
#[doc(hidden)]
pub type CreateBackupVaultInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl CreateBackupVaultInput {
    /// Consumes the builder and constructs an Operation<[`CreateBackupVault`](crate::operation::CreateBackupVault)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::CreateBackupVault,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_create_backup_vault(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::CreateBackupVault::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "CreateBackupVault",
                "backup",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let input_2 = &self.backup_vault_name;
        let input_2 = input_2
            .as_ref()
            .ok_or(smithy_http::operation::BuildError::MissingField {
                field: "backup_vault_name",
                details: "cannot be empty or unset",
            })?;
        let backup_vault_name = smithy_http::label::fmt_string(input_2, false);
        if backup_vault_name.is_empty() {
            return Err(smithy_http::operation::BuildError::MissingField {
                field: "backup_vault_name",
                details: "cannot be empty or unset",
            });
        }
        write!(
            output,
            "/backup-vaults/{BackupVaultName}",
            BackupVaultName = backup_vault_name
        )
        .expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("PUT").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CreateBackupVaultInput`](crate::input::CreateBackupVaultInput)
    pub fn builder() -> crate::input::create_backup_vault_input::Builder {
        crate::input::create_backup_vault_input::Builder::default()
    }
}

/// See [`DeleteBackupPlanInput`](crate::input::DeleteBackupPlanInput)
pub mod delete_backup_plan_input {
    /// A builder for [`DeleteBackupPlanInput`](crate::input::DeleteBackupPlanInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) backup_plan_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Uniquely identifies a backup plan.</p>
        pub fn backup_plan_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.backup_plan_id = Some(input.into());
            self
        }
        pub fn set_backup_plan_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.backup_plan_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteBackupPlanInput`](crate::input::DeleteBackupPlanInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteBackupPlanInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteBackupPlanInput {
                backup_plan_id: self.backup_plan_id,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteBackupPlanInputOperationOutputAlias = crate::operation::DeleteBackupPlan;
#[doc(hidden)]
pub type DeleteBackupPlanInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteBackupPlanInput {
    /// Consumes the builder and constructs an Operation<[`DeleteBackupPlan`](crate::operation::DeleteBackupPlan)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DeleteBackupPlan,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DeleteBackupPlan::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DeleteBackupPlan",
                "backup",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let input_3 = &self.backup_plan_id;
        let input_3 = input_3
            .as_ref()
            .ok_or(smithy_http::operation::BuildError::MissingField {
                field: "backup_plan_id",
                details: "cannot be empty or unset",
            })?;
        let backup_plan_id = smithy_http::label::fmt_string(input_3, false);
        if backup_plan_id.is_empty() {
            return Err(smithy_http::operation::BuildError::MissingField {
                field: "backup_plan_id",
                details: "cannot be empty or unset",
            });
        }
        write!(
            output,
            "/backup/plans/{BackupPlanId}",
            BackupPlanId = backup_plan_id
        )
        .expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("DELETE").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteBackupPlanInput`](crate::input::DeleteBackupPlanInput)
    pub fn builder() -> crate::input::delete_backup_plan_input::Builder {
        crate::input::delete_backup_plan_input::Builder::default()
    }
}

/// See [`DeleteBackupSelectionInput`](crate::input::DeleteBackupSelectionInput)
pub mod delete_backup_selection_input {
    /// A builder for [`DeleteBackupSelectionInput`](crate::input::DeleteBackupSelectionInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) backup_plan_id: std::option::Option<std::string::String>,
        pub(crate) selection_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Uniquely identifies a backup plan.</p>
        pub fn backup_plan_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.backup_plan_id = Some(input.into());
            self
        }
        pub fn set_backup_plan_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.backup_plan_id = input;
            self
        }
        /// <p>Uniquely identifies the body of a request to assign a set of resources to a backup
        /// plan.</p>
        pub fn selection_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.selection_id = Some(input.into());
            self
        }
        pub fn set_selection_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.selection_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteBackupSelectionInput`](crate::input::DeleteBackupSelectionInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteBackupSelectionInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteBackupSelectionInput {
                backup_plan_id: self.backup_plan_id,
                selection_id: self.selection_id,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteBackupSelectionInputOperationOutputAlias = crate::operation::DeleteBackupSelection;
#[doc(hidden)]
pub type DeleteBackupSelectionInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteBackupSelectionInput {
    /// Consumes the builder and constructs an Operation<[`DeleteBackupSelection`](crate::operation::DeleteBackupSelection)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DeleteBackupSelection,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DeleteBackupSelection::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DeleteBackupSelection",
                "backup",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let input_4 = &self.backup_plan_id;
        let input_4 = input_4
            .as_ref()
            .ok_or(smithy_http::operation::BuildError::MissingField {
                field: "backup_plan_id",
                details: "cannot be empty or unset",
            })?;
        let backup_plan_id = smithy_http::label::fmt_string(input_4, false);
        if backup_plan_id.is_empty() {
            return Err(smithy_http::operation::BuildError::MissingField {
                field: "backup_plan_id",
                details: "cannot be empty or unset",
            });
        }
        let input_5 = &self.selection_id;
        let input_5 = input_5
            .as_ref()
            .ok_or(smithy_http::operation::BuildError::MissingField {
                field: "selection_id",
                details: "cannot be empty or unset",
            })?;
        let selection_id = smithy_http::label::fmt_string(input_5, false);
        if selection_id.is_empty() {
            return Err(smithy_http::operation::BuildError::MissingField {
                field: "selection_id",
                details: "cannot be empty or unset",
            });
        }
        write!(
            output,
            "/backup/plans/{BackupPlanId}/selections/{SelectionId}",
            BackupPlanId = backup_plan_id,
            SelectionId = selection_id
        )
        .expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("DELETE").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteBackupSelectionInput`](crate::input::DeleteBackupSelectionInput)
    pub fn builder() -> crate::input::delete_backup_selection_input::Builder {
        crate::input::delete_backup_selection_input::Builder::default()
    }
}

/// See [`DeleteBackupVaultInput`](crate::input::DeleteBackupVaultInput)
pub mod delete_backup_vault_input {
    /// A builder for [`DeleteBackupVaultInput`](crate::input::DeleteBackupVaultInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) backup_vault_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of a logical container where backups are stored. Backup vaults are identified
        /// by names that are unique to the account used to create them and the AWS Region where they
        /// are created. They consist of lowercase letters, numbers, and hyphens.</p>
        pub fn backup_vault_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.backup_vault_name = Some(input.into());
            self
        }
        pub fn set_backup_vault_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.backup_vault_name = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteBackupVaultInput`](crate::input::DeleteBackupVaultInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteBackupVaultInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteBackupVaultInput {
                backup_vault_name: self.backup_vault_name,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteBackupVaultInputOperationOutputAlias = crate::operation::DeleteBackupVault;
#[doc(hidden)]
pub type DeleteBackupVaultInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteBackupVaultInput {
    /// Consumes the builder and constructs an Operation<[`DeleteBackupVault`](crate::operation::DeleteBackupVault)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DeleteBackupVault,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DeleteBackupVault::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DeleteBackupVault",
                "backup",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let input_6 = &self.backup_vault_name;
        let input_6 = input_6
            .as_ref()
            .ok_or(smithy_http::operation::BuildError::MissingField {
                field: "backup_vault_name",
                details: "cannot be empty or unset",
            })?;
        let backup_vault_name = smithy_http::label::fmt_string(input_6, false);
        if backup_vault_name.is_empty() {
            return Err(smithy_http::operation::BuildError::MissingField {
                field: "backup_vault_name",
                details: "cannot be empty or unset",
            });
        }
        write!(
            output,
            "/backup-vaults/{BackupVaultName}",
            BackupVaultName = backup_vault_name
        )
        .expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("DELETE").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteBackupVaultInput`](crate::input::DeleteBackupVaultInput)
    pub fn builder() -> crate::input::delete_backup_vault_input::Builder {
        crate::input::delete_backup_vault_input::Builder::default()
    }
}

/// See [`DeleteBackupVaultAccessPolicyInput`](crate::input::DeleteBackupVaultAccessPolicyInput)
pub mod delete_backup_vault_access_policy_input {
    /// A builder for [`DeleteBackupVaultAccessPolicyInput`](crate::input::DeleteBackupVaultAccessPolicyInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) backup_vault_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of a logical container where backups are stored. Backup vaults are identified
        /// by names that are unique to the account used to create them and the AWS Region where they
        /// are created. They consist of lowercase letters, numbers, and hyphens.</p>
        pub fn backup_vault_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.backup_vault_name = Some(input.into());
            self
        }
        pub fn set_backup_vault_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.backup_vault_name = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteBackupVaultAccessPolicyInput`](crate::input::DeleteBackupVaultAccessPolicyInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteBackupVaultAccessPolicyInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteBackupVaultAccessPolicyInput {
                backup_vault_name: self.backup_vault_name,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteBackupVaultAccessPolicyInputOperationOutputAlias =
    crate::operation::DeleteBackupVaultAccessPolicy;
#[doc(hidden)]
pub type DeleteBackupVaultAccessPolicyInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteBackupVaultAccessPolicyInput {
    /// Consumes the builder and constructs an Operation<[`DeleteBackupVaultAccessPolicy`](crate::operation::DeleteBackupVaultAccessPolicy)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DeleteBackupVaultAccessPolicy,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DeleteBackupVaultAccessPolicy::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DeleteBackupVaultAccessPolicy",
                "backup",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let input_7 = &self.backup_vault_name;
        let input_7 = input_7
            .as_ref()
            .ok_or(smithy_http::operation::BuildError::MissingField {
                field: "backup_vault_name",
                details: "cannot be empty or unset",
            })?;
        let backup_vault_name = smithy_http::label::fmt_string(input_7, false);
        if backup_vault_name.is_empty() {
            return Err(smithy_http::operation::BuildError::MissingField {
                field: "backup_vault_name",
                details: "cannot be empty or unset",
            });
        }
        write!(
            output,
            "/backup-vaults/{BackupVaultName}/access-policy",
            BackupVaultName = backup_vault_name
        )
        .expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("DELETE").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteBackupVaultAccessPolicyInput`](crate::input::DeleteBackupVaultAccessPolicyInput)
    pub fn builder() -> crate::input::delete_backup_vault_access_policy_input::Builder {
        crate::input::delete_backup_vault_access_policy_input::Builder::default()
    }
}

/// See [`DeleteBackupVaultNotificationsInput`](crate::input::DeleteBackupVaultNotificationsInput)
pub mod delete_backup_vault_notifications_input {
    /// A builder for [`DeleteBackupVaultNotificationsInput`](crate::input::DeleteBackupVaultNotificationsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) backup_vault_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of a logical container where backups are stored. Backup vaults are identified
        /// by names that are unique to the account used to create them and the Region where they are
        /// created. They consist of lowercase letters, numbers, and hyphens.</p>
        pub fn backup_vault_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.backup_vault_name = Some(input.into());
            self
        }
        pub fn set_backup_vault_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.backup_vault_name = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteBackupVaultNotificationsInput`](crate::input::DeleteBackupVaultNotificationsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteBackupVaultNotificationsInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteBackupVaultNotificationsInput {
                backup_vault_name: self.backup_vault_name,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteBackupVaultNotificationsInputOperationOutputAlias =
    crate::operation::DeleteBackupVaultNotifications;
#[doc(hidden)]
pub type DeleteBackupVaultNotificationsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteBackupVaultNotificationsInput {
    /// Consumes the builder and constructs an Operation<[`DeleteBackupVaultNotifications`](crate::operation::DeleteBackupVaultNotifications)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DeleteBackupVaultNotifications,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DeleteBackupVaultNotifications::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DeleteBackupVaultNotifications",
                "backup",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let input_8 = &self.backup_vault_name;
        let input_8 = input_8
            .as_ref()
            .ok_or(smithy_http::operation::BuildError::MissingField {
                field: "backup_vault_name",
                details: "cannot be empty or unset",
            })?;
        let backup_vault_name = smithy_http::label::fmt_string(input_8, false);
        if backup_vault_name.is_empty() {
            return Err(smithy_http::operation::BuildError::MissingField {
                field: "backup_vault_name",
                details: "cannot be empty or unset",
            });
        }
        write!(
            output,
            "/backup-vaults/{BackupVaultName}/notification-configuration",
            BackupVaultName = backup_vault_name
        )
        .expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("DELETE").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteBackupVaultNotificationsInput`](crate::input::DeleteBackupVaultNotificationsInput)
    pub fn builder() -> crate::input::delete_backup_vault_notifications_input::Builder {
        crate::input::delete_backup_vault_notifications_input::Builder::default()
    }
}

/// See [`DeleteRecoveryPointInput`](crate::input::DeleteRecoveryPointInput)
pub mod delete_recovery_point_input {
    /// A builder for [`DeleteRecoveryPointInput`](crate::input::DeleteRecoveryPointInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) backup_vault_name: std::option::Option<std::string::String>,
        pub(crate) recovery_point_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of a logical container where backups are stored. Backup vaults are identified
        /// by names that are unique to the account used to create them and the AWS Region where they
        /// are created. They consist of lowercase letters, numbers, and hyphens.</p>
        pub fn backup_vault_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.backup_vault_name = Some(input.into());
            self
        }
        pub fn set_backup_vault_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.backup_vault_name = input;
            self
        }
        /// <p>An Amazon Resource Name (ARN) that uniquely identifies a recovery point; for example,
        /// <code>arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45</code>.</p>
        pub fn recovery_point_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.recovery_point_arn = Some(input.into());
            self
        }
        pub fn set_recovery_point_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.recovery_point_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteRecoveryPointInput`](crate::input::DeleteRecoveryPointInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteRecoveryPointInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteRecoveryPointInput {
                backup_vault_name: self.backup_vault_name,
                recovery_point_arn: self.recovery_point_arn,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteRecoveryPointInputOperationOutputAlias = crate::operation::DeleteRecoveryPoint;
#[doc(hidden)]
pub type DeleteRecoveryPointInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteRecoveryPointInput {
    /// Consumes the builder and constructs an Operation<[`DeleteRecoveryPoint`](crate::operation::DeleteRecoveryPoint)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DeleteRecoveryPoint,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DeleteRecoveryPoint::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DeleteRecoveryPoint",
                "backup",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let input_9 = &self.backup_vault_name;
        let input_9 = input_9
            .as_ref()
            .ok_or(smithy_http::operation::BuildError::MissingField {
                field: "backup_vault_name",
                details: "cannot be empty or unset",
            })?;
        let backup_vault_name = smithy_http::label::fmt_string(input_9, false);
        if backup_vault_name.is_empty() {
            return Err(smithy_http::operation::BuildError::MissingField {
                field: "backup_vault_name",
                details: "cannot be empty or unset",
            });
        }
        let input_10 = &self.recovery_point_arn;
        let input_10 =
            input_10
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "recovery_point_arn",
                    details: "cannot be empty or unset",
                })?;
        let recovery_point_arn = smithy_http::label::fmt_string(input_10, false);
        if recovery_point_arn.is_empty() {
            return Err(smithy_http::operation::BuildError::MissingField {
                field: "recovery_point_arn",
                details: "cannot be empty or unset",
            });
        }
        write!(
            output,
            "/backup-vaults/{BackupVaultName}/recovery-points/{RecoveryPointArn}",
            BackupVaultName = backup_vault_name,
            RecoveryPointArn = recovery_point_arn
        )
        .expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("DELETE").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteRecoveryPointInput`](crate::input::DeleteRecoveryPointInput)
    pub fn builder() -> crate::input::delete_recovery_point_input::Builder {
        crate::input::delete_recovery_point_input::Builder::default()
    }
}

/// See [`DescribeBackupJobInput`](crate::input::DescribeBackupJobInput)
pub mod describe_backup_job_input {
    /// A builder for [`DescribeBackupJobInput`](crate::input::DescribeBackupJobInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) backup_job_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Uniquely identifies a request to AWS Backup to back up a resource.</p>
        pub fn backup_job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.backup_job_id = Some(input.into());
            self
        }
        pub fn set_backup_job_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.backup_job_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeBackupJobInput`](crate::input::DescribeBackupJobInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DescribeBackupJobInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DescribeBackupJobInput {
                backup_job_id: self.backup_job_id,
            })
        }
    }
}
#[doc(hidden)]
pub type DescribeBackupJobInputOperationOutputAlias = crate::operation::DescribeBackupJob;
#[doc(hidden)]
pub type DescribeBackupJobInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DescribeBackupJobInput {
    /// Consumes the builder and constructs an Operation<[`DescribeBackupJob`](crate::operation::DescribeBackupJob)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DescribeBackupJob,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DescribeBackupJob::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DescribeBackupJob",
                "backup",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let input_11 = &self.backup_job_id;
        let input_11 =
            input_11
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "backup_job_id",
                    details: "cannot be empty or unset",
                })?;
        let backup_job_id = smithy_http::label::fmt_string(input_11, false);
        if backup_job_id.is_empty() {
            return Err(smithy_http::operation::BuildError::MissingField {
                field: "backup_job_id",
                details: "cannot be empty or unset",
            });
        }
        write!(
            output,
            "/backup-jobs/{BackupJobId}",
            BackupJobId = backup_job_id
        )
        .expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("GET").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DescribeBackupJobInput`](crate::input::DescribeBackupJobInput)
    pub fn builder() -> crate::input::describe_backup_job_input::Builder {
        crate::input::describe_backup_job_input::Builder::default()
    }
}

/// See [`DescribeBackupVaultInput`](crate::input::DescribeBackupVaultInput)
pub mod describe_backup_vault_input {
    /// A builder for [`DescribeBackupVaultInput`](crate::input::DescribeBackupVaultInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) backup_vault_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of a logical container where backups are stored. Backup vaults are identified
        /// by names that are unique to the account used to create them and the AWS Region where they
        /// are created. They consist of lowercase letters, numbers, and hyphens.</p>
        pub fn backup_vault_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.backup_vault_name = Some(input.into());
            self
        }
        pub fn set_backup_vault_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.backup_vault_name = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeBackupVaultInput`](crate::input::DescribeBackupVaultInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DescribeBackupVaultInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DescribeBackupVaultInput {
                backup_vault_name: self.backup_vault_name,
            })
        }
    }
}
#[doc(hidden)]
pub type DescribeBackupVaultInputOperationOutputAlias = crate::operation::DescribeBackupVault;
#[doc(hidden)]
pub type DescribeBackupVaultInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DescribeBackupVaultInput {
    /// Consumes the builder and constructs an Operation<[`DescribeBackupVault`](crate::operation::DescribeBackupVault)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DescribeBackupVault,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DescribeBackupVault::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DescribeBackupVault",
                "backup",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let input_12 = &self.backup_vault_name;
        let input_12 =
            input_12
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "backup_vault_name",
                    details: "cannot be empty or unset",
                })?;
        let backup_vault_name = smithy_http::label::fmt_string(input_12, false);
        if backup_vault_name.is_empty() {
            return Err(smithy_http::operation::BuildError::MissingField {
                field: "backup_vault_name",
                details: "cannot be empty or unset",
            });
        }
        write!(
            output,
            "/backup-vaults/{BackupVaultName}",
            BackupVaultName = backup_vault_name
        )
        .expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("GET").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DescribeBackupVaultInput`](crate::input::DescribeBackupVaultInput)
    pub fn builder() -> crate::input::describe_backup_vault_input::Builder {
        crate::input::describe_backup_vault_input::Builder::default()
    }
}

/// See [`DescribeCopyJobInput`](crate::input::DescribeCopyJobInput)
pub mod describe_copy_job_input {
    /// A builder for [`DescribeCopyJobInput`](crate::input::DescribeCopyJobInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) copy_job_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Uniquely identifies a copy job.</p>
        pub fn copy_job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.copy_job_id = Some(input.into());
            self
        }
        pub fn set_copy_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.copy_job_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeCopyJobInput`](crate::input::DescribeCopyJobInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DescribeCopyJobInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DescribeCopyJobInput {
                copy_job_id: self.copy_job_id,
            })
        }
    }
}
#[doc(hidden)]
pub type DescribeCopyJobInputOperationOutputAlias = crate::operation::DescribeCopyJob;
#[doc(hidden)]
pub type DescribeCopyJobInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DescribeCopyJobInput {
    /// Consumes the builder and constructs an Operation<[`DescribeCopyJob`](crate::operation::DescribeCopyJob)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DescribeCopyJob,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DescribeCopyJob::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DescribeCopyJob",
                "backup",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let input_13 = &self.copy_job_id;
        let input_13 =
            input_13
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "copy_job_id",
                    details: "cannot be empty or unset",
                })?;
        let copy_job_id = smithy_http::label::fmt_string(input_13, false);
        if copy_job_id.is_empty() {
            return Err(smithy_http::operation::BuildError::MissingField {
                field: "copy_job_id",
                details: "cannot be empty or unset",
            });
        }
        write!(output, "/copy-jobs/{CopyJobId}", CopyJobId = copy_job_id)
            .expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("GET").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DescribeCopyJobInput`](crate::input::DescribeCopyJobInput)
    pub fn builder() -> crate::input::describe_copy_job_input::Builder {
        crate::input::describe_copy_job_input::Builder::default()
    }
}

/// See [`DescribeGlobalSettingsInput`](crate::input::DescribeGlobalSettingsInput)
pub mod describe_global_settings_input {
    /// A builder for [`DescribeGlobalSettingsInput`](crate::input::DescribeGlobalSettingsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`DescribeGlobalSettingsInput`](crate::input::DescribeGlobalSettingsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DescribeGlobalSettingsInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DescribeGlobalSettingsInput {})
        }
    }
}
#[doc(hidden)]
pub type DescribeGlobalSettingsInputOperationOutputAlias = crate::operation::DescribeGlobalSettings;
#[doc(hidden)]
pub type DescribeGlobalSettingsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DescribeGlobalSettingsInput {
    /// Consumes the builder and constructs an Operation<[`DescribeGlobalSettings`](crate::operation::DescribeGlobalSettings)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DescribeGlobalSettings,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DescribeGlobalSettings::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DescribeGlobalSettings",
                "backup",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/global-settings").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("GET").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DescribeGlobalSettingsInput`](crate::input::DescribeGlobalSettingsInput)
    pub fn builder() -> crate::input::describe_global_settings_input::Builder {
        crate::input::describe_global_settings_input::Builder::default()
    }
}

/// See [`DescribeProtectedResourceInput`](crate::input::DescribeProtectedResourceInput)
pub mod describe_protected_resource_input {
    /// A builder for [`DescribeProtectedResourceInput`](crate::input::DescribeProtectedResourceInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>An Amazon Resource Name (ARN) that uniquely identifies a resource. The format of the ARN
        /// depends on the resource type.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeProtectedResourceInput`](crate::input::DescribeProtectedResourceInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DescribeProtectedResourceInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DescribeProtectedResourceInput {
                resource_arn: self.resource_arn,
            })
        }
    }
}
#[doc(hidden)]
pub type DescribeProtectedResourceInputOperationOutputAlias =
    crate::operation::DescribeProtectedResource;
#[doc(hidden)]
pub type DescribeProtectedResourceInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DescribeProtectedResourceInput {
    /// Consumes the builder and constructs an Operation<[`DescribeProtectedResource`](crate::operation::DescribeProtectedResource)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DescribeProtectedResource,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DescribeProtectedResource::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DescribeProtectedResource",
                "backup",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let input_14 = &self.resource_arn;
        let input_14 =
            input_14
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "resource_arn",
                    details: "cannot be empty or unset",
                })?;
        let resource_arn = smithy_http::label::fmt_string(input_14, false);
        if resource_arn.is_empty() {
            return Err(smithy_http::operation::BuildError::MissingField {
                field: "resource_arn",
                details: "cannot be empty or unset",
            });
        }
        write!(
            output,
            "/resources/{ResourceArn}",
            ResourceArn = resource_arn
        )
        .expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("GET").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DescribeProtectedResourceInput`](crate::input::DescribeProtectedResourceInput)
    pub fn builder() -> crate::input::describe_protected_resource_input::Builder {
        crate::input::describe_protected_resource_input::Builder::default()
    }
}

/// See [`DescribeRecoveryPointInput`](crate::input::DescribeRecoveryPointInput)
pub mod describe_recovery_point_input {
    /// A builder for [`DescribeRecoveryPointInput`](crate::input::DescribeRecoveryPointInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) backup_vault_name: std::option::Option<std::string::String>,
        pub(crate) recovery_point_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of a logical container where backups are stored. Backup vaults are identified
        /// by names that are unique to the account used to create them and the AWS Region where they
        /// are created. They consist of lowercase letters, numbers, and hyphens.</p>
        pub fn backup_vault_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.backup_vault_name = Some(input.into());
            self
        }
        pub fn set_backup_vault_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.backup_vault_name = input;
            self
        }
        /// <p>An Amazon Resource Name (ARN) that uniquely identifies a recovery point; for example,
        /// <code>arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45</code>.</p>
        pub fn recovery_point_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.recovery_point_arn = Some(input.into());
            self
        }
        pub fn set_recovery_point_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.recovery_point_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeRecoveryPointInput`](crate::input::DescribeRecoveryPointInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DescribeRecoveryPointInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DescribeRecoveryPointInput {
                backup_vault_name: self.backup_vault_name,
                recovery_point_arn: self.recovery_point_arn,
            })
        }
    }
}
#[doc(hidden)]
pub type DescribeRecoveryPointInputOperationOutputAlias = crate::operation::DescribeRecoveryPoint;
#[doc(hidden)]
pub type DescribeRecoveryPointInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DescribeRecoveryPointInput {
    /// Consumes the builder and constructs an Operation<[`DescribeRecoveryPoint`](crate::operation::DescribeRecoveryPoint)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DescribeRecoveryPoint,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DescribeRecoveryPoint::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DescribeRecoveryPoint",
                "backup",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let input_15 = &self.backup_vault_name;
        let input_15 =
            input_15
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "backup_vault_name",
                    details: "cannot be empty or unset",
                })?;
        let backup_vault_name = smithy_http::label::fmt_string(input_15, false);
        if backup_vault_name.is_empty() {
            return Err(smithy_http::operation::BuildError::MissingField {
                field: "backup_vault_name",
                details: "cannot be empty or unset",
            });
        }
        let input_16 = &self.recovery_point_arn;
        let input_16 =
            input_16
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "recovery_point_arn",
                    details: "cannot be empty or unset",
                })?;
        let recovery_point_arn = smithy_http::label::fmt_string(input_16, false);
        if recovery_point_arn.is_empty() {
            return Err(smithy_http::operation::BuildError::MissingField {
                field: "recovery_point_arn",
                details: "cannot be empty or unset",
            });
        }
        write!(
            output,
            "/backup-vaults/{BackupVaultName}/recovery-points/{RecoveryPointArn}",
            BackupVaultName = backup_vault_name,
            RecoveryPointArn = recovery_point_arn
        )
        .expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("GET").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DescribeRecoveryPointInput`](crate::input::DescribeRecoveryPointInput)
    pub fn builder() -> crate::input::describe_recovery_point_input::Builder {
        crate::input::describe_recovery_point_input::Builder::default()
    }
}

/// See [`DescribeRegionSettingsInput`](crate::input::DescribeRegionSettingsInput)
pub mod describe_region_settings_input {
    /// A builder for [`DescribeRegionSettingsInput`](crate::input::DescribeRegionSettingsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`DescribeRegionSettingsInput`](crate::input::DescribeRegionSettingsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DescribeRegionSettingsInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DescribeRegionSettingsInput {})
        }
    }
}
#[doc(hidden)]
pub type DescribeRegionSettingsInputOperationOutputAlias = crate::operation::DescribeRegionSettings;
#[doc(hidden)]
pub type DescribeRegionSettingsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DescribeRegionSettingsInput {
    /// Consumes the builder and constructs an Operation<[`DescribeRegionSettings`](crate::operation::DescribeRegionSettings)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DescribeRegionSettings,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DescribeRegionSettings::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DescribeRegionSettings",
                "backup",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/account-settings").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("GET").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DescribeRegionSettingsInput`](crate::input::DescribeRegionSettingsInput)
    pub fn builder() -> crate::input::describe_region_settings_input::Builder {
        crate::input::describe_region_settings_input::Builder::default()
    }
}

/// See [`DescribeRestoreJobInput`](crate::input::DescribeRestoreJobInput)
pub mod describe_restore_job_input {
    /// A builder for [`DescribeRestoreJobInput`](crate::input::DescribeRestoreJobInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) restore_job_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Uniquely identifies the job that restores a recovery point.</p>
        pub fn restore_job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.restore_job_id = Some(input.into());
            self
        }
        pub fn set_restore_job_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.restore_job_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeRestoreJobInput`](crate::input::DescribeRestoreJobInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DescribeRestoreJobInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DescribeRestoreJobInput {
                restore_job_id: self.restore_job_id,
            })
        }
    }
}
#[doc(hidden)]
pub type DescribeRestoreJobInputOperationOutputAlias = crate::operation::DescribeRestoreJob;
#[doc(hidden)]
pub type DescribeRestoreJobInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DescribeRestoreJobInput {
    /// Consumes the builder and constructs an Operation<[`DescribeRestoreJob`](crate::operation::DescribeRestoreJob)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DescribeRestoreJob,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DescribeRestoreJob::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DescribeRestoreJob",
                "backup",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let input_17 = &self.restore_job_id;
        let input_17 =
            input_17
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "restore_job_id",
                    details: "cannot be empty or unset",
                })?;
        let restore_job_id = smithy_http::label::fmt_string(input_17, false);
        if restore_job_id.is_empty() {
            return Err(smithy_http::operation::BuildError::MissingField {
                field: "restore_job_id",
                details: "cannot be empty or unset",
            });
        }
        write!(
            output,
            "/restore-jobs/{RestoreJobId}",
            RestoreJobId = restore_job_id
        )
        .expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("GET").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DescribeRestoreJobInput`](crate::input::DescribeRestoreJobInput)
    pub fn builder() -> crate::input::describe_restore_job_input::Builder {
        crate::input::describe_restore_job_input::Builder::default()
    }
}

/// See [`DisassociateRecoveryPointInput`](crate::input::DisassociateRecoveryPointInput)
pub mod disassociate_recovery_point_input {
    /// A builder for [`DisassociateRecoveryPointInput`](crate::input::DisassociateRecoveryPointInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) backup_vault_name: std::option::Option<std::string::String>,
        pub(crate) recovery_point_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique name of an AWS Backup vault. Required.</p>
        pub fn backup_vault_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.backup_vault_name = Some(input.into());
            self
        }
        pub fn set_backup_vault_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.backup_vault_name = input;
            self
        }
        /// <p>An Amazon Resource Name (ARN) that uniquely identifies an AWS Backup recovery point.
        /// Required.</p>
        pub fn recovery_point_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.recovery_point_arn = Some(input.into());
            self
        }
        pub fn set_recovery_point_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.recovery_point_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`DisassociateRecoveryPointInput`](crate::input::DisassociateRecoveryPointInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DisassociateRecoveryPointInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DisassociateRecoveryPointInput {
                backup_vault_name: self.backup_vault_name,
                recovery_point_arn: self.recovery_point_arn,
            })
        }
    }
}
#[doc(hidden)]
pub type DisassociateRecoveryPointInputOperationOutputAlias =
    crate::operation::DisassociateRecoveryPoint;
#[doc(hidden)]
pub type DisassociateRecoveryPointInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DisassociateRecoveryPointInput {
    /// Consumes the builder and constructs an Operation<[`DisassociateRecoveryPoint`](crate::operation::DisassociateRecoveryPoint)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DisassociateRecoveryPoint,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DisassociateRecoveryPoint::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DisassociateRecoveryPoint",
                "backup",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let input_18 = &self.backup_vault_name;
        let input_18 =
            input_18
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "backup_vault_name",
                    details: "cannot be empty or unset",
                })?;
        let backup_vault_name = smithy_http::label::fmt_string(input_18, false);
        if backup_vault_name.is_empty() {
            return Err(smithy_http::operation::BuildError::MissingField {
                field: "backup_vault_name",
                details: "cannot be empty or unset",
            });
        }
        let input_19 = &self.recovery_point_arn;
        let input_19 =
            input_19
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "recovery_point_arn",
                    details: "cannot be empty or unset",
                })?;
        let recovery_point_arn = smithy_http::label::fmt_string(input_19, false);
        if recovery_point_arn.is_empty() {
            return Err(smithy_http::operation::BuildError::MissingField {
                field: "recovery_point_arn",
                details: "cannot be empty or unset",
            });
        }
        write!(
            output,
            "/backup-vaults/{BackupVaultName}/recovery-points/{RecoveryPointArn}/disassociate",
            BackupVaultName = backup_vault_name,
            RecoveryPointArn = recovery_point_arn
        )
        .expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DisassociateRecoveryPointInput`](crate::input::DisassociateRecoveryPointInput)
    pub fn builder() -> crate::input::disassociate_recovery_point_input::Builder {
        crate::input::disassociate_recovery_point_input::Builder::default()
    }
}

/// See [`ExportBackupPlanTemplateInput`](crate::input::ExportBackupPlanTemplateInput)
pub mod export_backup_plan_template_input {
    /// A builder for [`ExportBackupPlanTemplateInput`](crate::input::ExportBackupPlanTemplateInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) backup_plan_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Uniquely identifies a backup plan.</p>
        pub fn backup_plan_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.backup_plan_id = Some(input.into());
            self
        }
        pub fn set_backup_plan_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.backup_plan_id = input;
            self
        }
        /// Consumes the builder and constructs a [`ExportBackupPlanTemplateInput`](crate::input::ExportBackupPlanTemplateInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ExportBackupPlanTemplateInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ExportBackupPlanTemplateInput {
                backup_plan_id: self.backup_plan_id,
            })
        }
    }
}
#[doc(hidden)]
pub type ExportBackupPlanTemplateInputOperationOutputAlias =
    crate::operation::ExportBackupPlanTemplate;
#[doc(hidden)]
pub type ExportBackupPlanTemplateInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ExportBackupPlanTemplateInput {
    /// Consumes the builder and constructs an Operation<[`ExportBackupPlanTemplate`](crate::operation::ExportBackupPlanTemplate)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::ExportBackupPlanTemplate,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::ExportBackupPlanTemplate::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "ExportBackupPlanTemplate",
                "backup",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let input_20 = &self.backup_plan_id;
        let input_20 =
            input_20
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "backup_plan_id",
                    details: "cannot be empty or unset",
                })?;
        let backup_plan_id = smithy_http::label::fmt_string(input_20, false);
        if backup_plan_id.is_empty() {
            return Err(smithy_http::operation::BuildError::MissingField {
                field: "backup_plan_id",
                details: "cannot be empty or unset",
            });
        }
        write!(
            output,
            "/backup/plans/{BackupPlanId}/toTemplate",
            BackupPlanId = backup_plan_id
        )
        .expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("GET").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ExportBackupPlanTemplateInput`](crate::input::ExportBackupPlanTemplateInput)
    pub fn builder() -> crate::input::export_backup_plan_template_input::Builder {
        crate::input::export_backup_plan_template_input::Builder::default()
    }
}

/// See [`GetBackupPlanInput`](crate::input::GetBackupPlanInput)
pub mod get_backup_plan_input {
    /// A builder for [`GetBackupPlanInput`](crate::input::GetBackupPlanInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) backup_plan_id: std::option::Option<std::string::String>,
        pub(crate) version_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Uniquely identifies a backup plan.</p>
        pub fn backup_plan_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.backup_plan_id = Some(input.into());
            self
        }
        pub fn set_backup_plan_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.backup_plan_id = input;
            self
        }
        /// <p>Unique, randomly generated, Unicode, UTF-8 encoded strings that are at most 1,024 bytes
        /// long. Version IDs cannot be edited.</p>
        pub fn version_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.version_id = Some(input.into());
            self
        }
        pub fn set_version_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.version_id = input;
            self
        }
        /// Consumes the builder and constructs a [`GetBackupPlanInput`](crate::input::GetBackupPlanInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::GetBackupPlanInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::GetBackupPlanInput {
                backup_plan_id: self.backup_plan_id,
                version_id: self.version_id,
            })
        }
    }
}
#[doc(hidden)]
pub type GetBackupPlanInputOperationOutputAlias = crate::operation::GetBackupPlan;
#[doc(hidden)]
pub type GetBackupPlanInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetBackupPlanInput {
    /// Consumes the builder and constructs an Operation<[`GetBackupPlan`](crate::operation::GetBackupPlan)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::GetBackupPlan,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::GetBackupPlan::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "GetBackupPlan",
                "backup",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let input_21 = &self.backup_plan_id;
        let input_21 =
            input_21
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "backup_plan_id",
                    details: "cannot be empty or unset",
                })?;
        let backup_plan_id = smithy_http::label::fmt_string(input_21, false);
        if backup_plan_id.is_empty() {
            return Err(smithy_http::operation::BuildError::MissingField {
                field: "backup_plan_id",
                details: "cannot be empty or unset",
            });
        }
        write!(
            output,
            "/backup/plans/{BackupPlanId}",
            BackupPlanId = backup_plan_id
        )
        .expect("formatting should succeed");
        Ok(())
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        if let Some(inner_22) = &self.version_id {
            query.push_kv("versionId", &smithy_http::query::fmt_string(&inner_22));
        }
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        Ok(builder.method("GET").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetBackupPlanInput`](crate::input::GetBackupPlanInput)
    pub fn builder() -> crate::input::get_backup_plan_input::Builder {
        crate::input::get_backup_plan_input::Builder::default()
    }
}

/// See [`GetBackupPlanFromJsonInput`](crate::input::GetBackupPlanFromJsonInput)
pub mod get_backup_plan_from_json_input {
    /// A builder for [`GetBackupPlanFromJsonInput`](crate::input::GetBackupPlanFromJsonInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) backup_plan_template_json: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A customer-supplied backup plan document in JSON format.</p>
        pub fn backup_plan_template_json(mut self, input: impl Into<std::string::String>) -> Self {
            self.backup_plan_template_json = Some(input.into());
            self
        }
        pub fn set_backup_plan_template_json(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.backup_plan_template_json = input;
            self
        }
        /// Consumes the builder and constructs a [`GetBackupPlanFromJsonInput`](crate::input::GetBackupPlanFromJsonInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetBackupPlanFromJsonInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetBackupPlanFromJsonInput {
                backup_plan_template_json: self.backup_plan_template_json,
            })
        }
    }
}
#[doc(hidden)]
pub type GetBackupPlanFromJSONInputOperationOutputAlias = crate::operation::GetBackupPlanFromJSON;
#[doc(hidden)]
pub type GetBackupPlanFromJSONInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetBackupPlanFromJsonInput {
    /// Consumes the builder and constructs an Operation<[`GetBackupPlanFromJSON`](crate::operation::GetBackupPlanFromJSON)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::GetBackupPlanFromJSON,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_get_backup_plan_from_json(&self)
                .map_err(|err| {
                smithy_http::operation::BuildError::SerializationError(err.into())
            })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::GetBackupPlanFromJSON::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "GetBackupPlanFromJSON",
                "backup",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/backup/template/json/toPlan").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetBackupPlanFromJsonInput`](crate::input::GetBackupPlanFromJsonInput)
    pub fn builder() -> crate::input::get_backup_plan_from_json_input::Builder {
        crate::input::get_backup_plan_from_json_input::Builder::default()
    }
}

/// See [`GetBackupPlanFromTemplateInput`](crate::input::GetBackupPlanFromTemplateInput)
pub mod get_backup_plan_from_template_input {
    /// A builder for [`GetBackupPlanFromTemplateInput`](crate::input::GetBackupPlanFromTemplateInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) backup_plan_template_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Uniquely identifies a stored backup plan template.</p>
        pub fn backup_plan_template_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.backup_plan_template_id = Some(input.into());
            self
        }
        pub fn set_backup_plan_template_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.backup_plan_template_id = input;
            self
        }
        /// Consumes the builder and constructs a [`GetBackupPlanFromTemplateInput`](crate::input::GetBackupPlanFromTemplateInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetBackupPlanFromTemplateInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetBackupPlanFromTemplateInput {
                backup_plan_template_id: self.backup_plan_template_id,
            })
        }
    }
}
#[doc(hidden)]
pub type GetBackupPlanFromTemplateInputOperationOutputAlias =
    crate::operation::GetBackupPlanFromTemplate;
#[doc(hidden)]
pub type GetBackupPlanFromTemplateInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetBackupPlanFromTemplateInput {
    /// Consumes the builder and constructs an Operation<[`GetBackupPlanFromTemplate`](crate::operation::GetBackupPlanFromTemplate)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::GetBackupPlanFromTemplate,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::GetBackupPlanFromTemplate::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "GetBackupPlanFromTemplate",
                "backup",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let input_23 = &self.backup_plan_template_id;
        let input_23 =
            input_23
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "backup_plan_template_id",
                    details: "cannot be empty or unset",
                })?;
        let backup_plan_template_id = smithy_http::label::fmt_string(input_23, false);
        if backup_plan_template_id.is_empty() {
            return Err(smithy_http::operation::BuildError::MissingField {
                field: "backup_plan_template_id",
                details: "cannot be empty or unset",
            });
        }
        write!(
            output,
            "/backup/template/plans/{BackupPlanTemplateId}/toPlan",
            BackupPlanTemplateId = backup_plan_template_id
        )
        .expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("GET").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetBackupPlanFromTemplateInput`](crate::input::GetBackupPlanFromTemplateInput)
    pub fn builder() -> crate::input::get_backup_plan_from_template_input::Builder {
        crate::input::get_backup_plan_from_template_input::Builder::default()
    }
}

/// See [`GetBackupSelectionInput`](crate::input::GetBackupSelectionInput)
pub mod get_backup_selection_input {
    /// A builder for [`GetBackupSelectionInput`](crate::input::GetBackupSelectionInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) backup_plan_id: std::option::Option<std::string::String>,
        pub(crate) selection_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Uniquely identifies a backup plan.</p>
        pub fn backup_plan_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.backup_plan_id = Some(input.into());
            self
        }
        pub fn set_backup_plan_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.backup_plan_id = input;
            self
        }
        /// <p>Uniquely identifies the body of a request to assign a set of resources to a backup
        /// plan.</p>
        pub fn selection_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.selection_id = Some(input.into());
            self
        }
        pub fn set_selection_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.selection_id = input;
            self
        }
        /// Consumes the builder and constructs a [`GetBackupSelectionInput`](crate::input::GetBackupSelectionInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetBackupSelectionInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetBackupSelectionInput {
                backup_plan_id: self.backup_plan_id,
                selection_id: self.selection_id,
            })
        }
    }
}
#[doc(hidden)]
pub type GetBackupSelectionInputOperationOutputAlias = crate::operation::GetBackupSelection;
#[doc(hidden)]
pub type GetBackupSelectionInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetBackupSelectionInput {
    /// Consumes the builder and constructs an Operation<[`GetBackupSelection`](crate::operation::GetBackupSelection)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::GetBackupSelection,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::GetBackupSelection::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "GetBackupSelection",
                "backup",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let input_24 = &self.backup_plan_id;
        let input_24 =
            input_24
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "backup_plan_id",
                    details: "cannot be empty or unset",
                })?;
        let backup_plan_id = smithy_http::label::fmt_string(input_24, false);
        if backup_plan_id.is_empty() {
            return Err(smithy_http::operation::BuildError::MissingField {
                field: "backup_plan_id",
                details: "cannot be empty or unset",
            });
        }
        let input_25 = &self.selection_id;
        let input_25 =
            input_25
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "selection_id",
                    details: "cannot be empty or unset",
                })?;
        let selection_id = smithy_http::label::fmt_string(input_25, false);
        if selection_id.is_empty() {
            return Err(smithy_http::operation::BuildError::MissingField {
                field: "selection_id",
                details: "cannot be empty or unset",
            });
        }
        write!(
            output,
            "/backup/plans/{BackupPlanId}/selections/{SelectionId}",
            BackupPlanId = backup_plan_id,
            SelectionId = selection_id
        )
        .expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("GET").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetBackupSelectionInput`](crate::input::GetBackupSelectionInput)
    pub fn builder() -> crate::input::get_backup_selection_input::Builder {
        crate::input::get_backup_selection_input::Builder::default()
    }
}

/// See [`GetBackupVaultAccessPolicyInput`](crate::input::GetBackupVaultAccessPolicyInput)
pub mod get_backup_vault_access_policy_input {
    /// A builder for [`GetBackupVaultAccessPolicyInput`](crate::input::GetBackupVaultAccessPolicyInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) backup_vault_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of a logical container where backups are stored. Backup vaults are identified
        /// by names that are unique to the account used to create them and the AWS Region where they
        /// are created. They consist of lowercase letters, numbers, and hyphens.</p>
        pub fn backup_vault_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.backup_vault_name = Some(input.into());
            self
        }
        pub fn set_backup_vault_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.backup_vault_name = input;
            self
        }
        /// Consumes the builder and constructs a [`GetBackupVaultAccessPolicyInput`](crate::input::GetBackupVaultAccessPolicyInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetBackupVaultAccessPolicyInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetBackupVaultAccessPolicyInput {
                backup_vault_name: self.backup_vault_name,
            })
        }
    }
}
#[doc(hidden)]
pub type GetBackupVaultAccessPolicyInputOperationOutputAlias =
    crate::operation::GetBackupVaultAccessPolicy;
#[doc(hidden)]
pub type GetBackupVaultAccessPolicyInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetBackupVaultAccessPolicyInput {
    /// Consumes the builder and constructs an Operation<[`GetBackupVaultAccessPolicy`](crate::operation::GetBackupVaultAccessPolicy)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::GetBackupVaultAccessPolicy,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::GetBackupVaultAccessPolicy::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "GetBackupVaultAccessPolicy",
                "backup",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let input_26 = &self.backup_vault_name;
        let input_26 =
            input_26
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "backup_vault_name",
                    details: "cannot be empty or unset",
                })?;
        let backup_vault_name = smithy_http::label::fmt_string(input_26, false);
        if backup_vault_name.is_empty() {
            return Err(smithy_http::operation::BuildError::MissingField {
                field: "backup_vault_name",
                details: "cannot be empty or unset",
            });
        }
        write!(
            output,
            "/backup-vaults/{BackupVaultName}/access-policy",
            BackupVaultName = backup_vault_name
        )
        .expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("GET").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetBackupVaultAccessPolicyInput`](crate::input::GetBackupVaultAccessPolicyInput)
    pub fn builder() -> crate::input::get_backup_vault_access_policy_input::Builder {
        crate::input::get_backup_vault_access_policy_input::Builder::default()
    }
}

/// See [`GetBackupVaultNotificationsInput`](crate::input::GetBackupVaultNotificationsInput)
pub mod get_backup_vault_notifications_input {
    /// A builder for [`GetBackupVaultNotificationsInput`](crate::input::GetBackupVaultNotificationsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) backup_vault_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of a logical container where backups are stored. Backup vaults are identified
        /// by names that are unique to the account used to create them and the AWS Region where they
        /// are created. They consist of lowercase letters, numbers, and hyphens.</p>
        pub fn backup_vault_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.backup_vault_name = Some(input.into());
            self
        }
        pub fn set_backup_vault_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.backup_vault_name = input;
            self
        }
        /// Consumes the builder and constructs a [`GetBackupVaultNotificationsInput`](crate::input::GetBackupVaultNotificationsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetBackupVaultNotificationsInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetBackupVaultNotificationsInput {
                backup_vault_name: self.backup_vault_name,
            })
        }
    }
}
#[doc(hidden)]
pub type GetBackupVaultNotificationsInputOperationOutputAlias =
    crate::operation::GetBackupVaultNotifications;
#[doc(hidden)]
pub type GetBackupVaultNotificationsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetBackupVaultNotificationsInput {
    /// Consumes the builder and constructs an Operation<[`GetBackupVaultNotifications`](crate::operation::GetBackupVaultNotifications)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::GetBackupVaultNotifications,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::GetBackupVaultNotifications::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "GetBackupVaultNotifications",
                "backup",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let input_27 = &self.backup_vault_name;
        let input_27 =
            input_27
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "backup_vault_name",
                    details: "cannot be empty or unset",
                })?;
        let backup_vault_name = smithy_http::label::fmt_string(input_27, false);
        if backup_vault_name.is_empty() {
            return Err(smithy_http::operation::BuildError::MissingField {
                field: "backup_vault_name",
                details: "cannot be empty or unset",
            });
        }
        write!(
            output,
            "/backup-vaults/{BackupVaultName}/notification-configuration",
            BackupVaultName = backup_vault_name
        )
        .expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("GET").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetBackupVaultNotificationsInput`](crate::input::GetBackupVaultNotificationsInput)
    pub fn builder() -> crate::input::get_backup_vault_notifications_input::Builder {
        crate::input::get_backup_vault_notifications_input::Builder::default()
    }
}

/// See [`GetRecoveryPointRestoreMetadataInput`](crate::input::GetRecoveryPointRestoreMetadataInput)
pub mod get_recovery_point_restore_metadata_input {
    /// A builder for [`GetRecoveryPointRestoreMetadataInput`](crate::input::GetRecoveryPointRestoreMetadataInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) backup_vault_name: std::option::Option<std::string::String>,
        pub(crate) recovery_point_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of a logical container where backups are stored. Backup vaults are identified
        /// by names that are unique to the account used to create them and the AWS Region where they
        /// are created. They consist of lowercase letters, numbers, and hyphens.</p>
        pub fn backup_vault_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.backup_vault_name = Some(input.into());
            self
        }
        pub fn set_backup_vault_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.backup_vault_name = input;
            self
        }
        /// <p>An Amazon Resource Name (ARN) that uniquely identifies a recovery point; for example,
        /// <code>arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45</code>.</p>
        pub fn recovery_point_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.recovery_point_arn = Some(input.into());
            self
        }
        pub fn set_recovery_point_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.recovery_point_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`GetRecoveryPointRestoreMetadataInput`](crate::input::GetRecoveryPointRestoreMetadataInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetRecoveryPointRestoreMetadataInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetRecoveryPointRestoreMetadataInput {
                backup_vault_name: self.backup_vault_name,
                recovery_point_arn: self.recovery_point_arn,
            })
        }
    }
}
#[doc(hidden)]
pub type GetRecoveryPointRestoreMetadataInputOperationOutputAlias =
    crate::operation::GetRecoveryPointRestoreMetadata;
#[doc(hidden)]
pub type GetRecoveryPointRestoreMetadataInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetRecoveryPointRestoreMetadataInput {
    /// Consumes the builder and constructs an Operation<[`GetRecoveryPointRestoreMetadata`](crate::operation::GetRecoveryPointRestoreMetadata)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::GetRecoveryPointRestoreMetadata,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::GetRecoveryPointRestoreMetadata::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "GetRecoveryPointRestoreMetadata",
                "backup",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let input_28 = &self.backup_vault_name;
        let input_28 =
            input_28
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "backup_vault_name",
                    details: "cannot be empty or unset",
                })?;
        let backup_vault_name = smithy_http::label::fmt_string(input_28, false);
        if backup_vault_name.is_empty() {
            return Err(smithy_http::operation::BuildError::MissingField {
                field: "backup_vault_name",
                details: "cannot be empty or unset",
            });
        }
        let input_29 = &self.recovery_point_arn;
        let input_29 =
            input_29
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "recovery_point_arn",
                    details: "cannot be empty or unset",
                })?;
        let recovery_point_arn = smithy_http::label::fmt_string(input_29, false);
        if recovery_point_arn.is_empty() {
            return Err(smithy_http::operation::BuildError::MissingField {
                field: "recovery_point_arn",
                details: "cannot be empty or unset",
            });
        }
        write!(
            output,
            "/backup-vaults/{BackupVaultName}/recovery-points/{RecoveryPointArn}/restore-metadata",
            BackupVaultName = backup_vault_name,
            RecoveryPointArn = recovery_point_arn
        )
        .expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("GET").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetRecoveryPointRestoreMetadataInput`](crate::input::GetRecoveryPointRestoreMetadataInput)
    pub fn builder() -> crate::input::get_recovery_point_restore_metadata_input::Builder {
        crate::input::get_recovery_point_restore_metadata_input::Builder::default()
    }
}

/// See [`GetSupportedResourceTypesInput`](crate::input::GetSupportedResourceTypesInput)
pub mod get_supported_resource_types_input {
    /// A builder for [`GetSupportedResourceTypesInput`](crate::input::GetSupportedResourceTypesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`GetSupportedResourceTypesInput`](crate::input::GetSupportedResourceTypesInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetSupportedResourceTypesInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetSupportedResourceTypesInput {})
        }
    }
}
#[doc(hidden)]
pub type GetSupportedResourceTypesInputOperationOutputAlias =
    crate::operation::GetSupportedResourceTypes;
#[doc(hidden)]
pub type GetSupportedResourceTypesInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetSupportedResourceTypesInput {
    /// Consumes the builder and constructs an Operation<[`GetSupportedResourceTypes`](crate::operation::GetSupportedResourceTypes)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::GetSupportedResourceTypes,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::GetSupportedResourceTypes::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "GetSupportedResourceTypes",
                "backup",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/supported-resource-types").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("GET").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetSupportedResourceTypesInput`](crate::input::GetSupportedResourceTypesInput)
    pub fn builder() -> crate::input::get_supported_resource_types_input::Builder {
        crate::input::get_supported_resource_types_input::Builder::default()
    }
}

/// See [`ListBackupJobsInput`](crate::input::ListBackupJobsInput)
pub mod list_backup_jobs_input {
    /// A builder for [`ListBackupJobsInput`](crate::input::ListBackupJobsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) by_resource_arn: std::option::Option<std::string::String>,
        pub(crate) by_state: std::option::Option<crate::model::BackupJobState>,
        pub(crate) by_backup_vault_name: std::option::Option<std::string::String>,
        pub(crate) by_created_before: std::option::Option<smithy_types::Instant>,
        pub(crate) by_created_after: std::option::Option<smithy_types::Instant>,
        pub(crate) by_resource_type: std::option::Option<std::string::String>,
        pub(crate) by_account_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The next item following a partial list of returned items. For example, if a request is
        /// made to return <code>maxResults</code> number of items, <code>NextToken</code> allows you
        /// to return more items in your list starting at the location pointed to by the next
        /// token.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of items to be returned.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>Returns only backup jobs that match the specified resource Amazon Resource Name
        /// (ARN).</p>
        pub fn by_resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.by_resource_arn = Some(input.into());
            self
        }
        pub fn set_by_resource_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.by_resource_arn = input;
            self
        }
        /// <p>Returns only backup jobs that are in the specified state.</p>
        pub fn by_state(mut self, input: crate::model::BackupJobState) -> Self {
            self.by_state = Some(input);
            self
        }
        pub fn set_by_state(
            mut self,
            input: std::option::Option<crate::model::BackupJobState>,
        ) -> Self {
            self.by_state = input;
            self
        }
        /// <p>Returns only backup jobs that will be stored in the specified backup vault. Backup
        /// vaults are identified by names that are unique to the account used to create them and the
        /// AWS Region where they are created. They consist of lowercase letters, numbers, and
        /// hyphens.</p>
        pub fn by_backup_vault_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.by_backup_vault_name = Some(input.into());
            self
        }
        pub fn set_by_backup_vault_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.by_backup_vault_name = input;
            self
        }
        /// <p>Returns only backup jobs that were created before the specified date.</p>
        pub fn by_created_before(mut self, input: smithy_types::Instant) -> Self {
            self.by_created_before = Some(input);
            self
        }
        pub fn set_by_created_before(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.by_created_before = input;
            self
        }
        /// <p>Returns only backup jobs that were created after the specified date.</p>
        pub fn by_created_after(mut self, input: smithy_types::Instant) -> Self {
            self.by_created_after = Some(input);
            self
        }
        pub fn set_by_created_after(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.by_created_after = input;
            self
        }
        /// <p>Returns only backup jobs for the specified resources:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>DynamoDB</code> for Amazon DynamoDB</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>EBS</code> for Amazon Elastic Block Store</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>EC2</code> for Amazon Elastic Compute Cloud</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>EFS</code> for Amazon Elastic File System</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>RDS</code> for Amazon Relational Database Service</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Aurora</code> for Amazon Aurora</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Storage Gateway</code> for AWS Storage Gateway</p>
        /// </li>
        /// </ul>
        pub fn by_resource_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.by_resource_type = Some(input.into());
            self
        }
        pub fn set_by_resource_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.by_resource_type = input;
            self
        }
        /// <p>The account ID to list the jobs from. Returns only backup jobs associated with the
        /// specified account ID.</p>
        /// <p>If used from an AWS Organizations management account, passing <code>*</code> returns all
        /// jobs across the organization.</p>
        pub fn by_account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.by_account_id = Some(input.into());
            self
        }
        pub fn set_by_account_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.by_account_id = input;
            self
        }
        /// Consumes the builder and constructs a [`ListBackupJobsInput`](crate::input::ListBackupJobsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListBackupJobsInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListBackupJobsInput {
                next_token: self.next_token,
                max_results: self.max_results,
                by_resource_arn: self.by_resource_arn,
                by_state: self.by_state,
                by_backup_vault_name: self.by_backup_vault_name,
                by_created_before: self.by_created_before,
                by_created_after: self.by_created_after,
                by_resource_type: self.by_resource_type,
                by_account_id: self.by_account_id,
            })
        }
    }
}
#[doc(hidden)]
pub type ListBackupJobsInputOperationOutputAlias = crate::operation::ListBackupJobs;
#[doc(hidden)]
pub type ListBackupJobsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListBackupJobsInput {
    /// Consumes the builder and constructs an Operation<[`ListBackupJobs`](crate::operation::ListBackupJobs)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::ListBackupJobs,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::ListBackupJobs::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "ListBackupJobs",
                "backup",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/backup-jobs").expect("formatting should succeed");
        Ok(())
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        if let Some(inner_30) = &self.next_token {
            query.push_kv("nextToken", &smithy_http::query::fmt_string(&inner_30));
        }
        if let Some(inner_31) = &self.max_results {
            query.push_kv(
                "maxResults",
                &smithy_types::primitive::Encoder::from(*inner_31).encode(),
            );
        }
        if let Some(inner_32) = &self.by_resource_arn {
            query.push_kv("resourceArn", &smithy_http::query::fmt_string(&inner_32));
        }
        if let Some(inner_33) = &self.by_state {
            query.push_kv("state", &smithy_http::query::fmt_string(&inner_33));
        }
        if let Some(inner_34) = &self.by_backup_vault_name {
            query.push_kv(
                "backupVaultName",
                &smithy_http::query::fmt_string(&inner_34),
            );
        }
        if let Some(inner_35) = &self.by_created_before {
            query.push_kv(
                "createdBefore",
                &smithy_http::query::fmt_timestamp(
                    inner_35,
                    smithy_types::instant::Format::DateTime,
                ),
            );
        }
        if let Some(inner_36) = &self.by_created_after {
            query.push_kv(
                "createdAfter",
                &smithy_http::query::fmt_timestamp(
                    inner_36,
                    smithy_types::instant::Format::DateTime,
                ),
            );
        }
        if let Some(inner_37) = &self.by_resource_type {
            query.push_kv("resourceType", &smithy_http::query::fmt_string(&inner_37));
        }
        if let Some(inner_38) = &self.by_account_id {
            query.push_kv("accountId", &smithy_http::query::fmt_string(&inner_38));
        }
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        Ok(builder.method("GET").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListBackupJobsInput`](crate::input::ListBackupJobsInput)
    pub fn builder() -> crate::input::list_backup_jobs_input::Builder {
        crate::input::list_backup_jobs_input::Builder::default()
    }
}

/// See [`ListBackupPlansInput`](crate::input::ListBackupPlansInput)
pub mod list_backup_plans_input {
    /// A builder for [`ListBackupPlansInput`](crate::input::ListBackupPlansInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) include_deleted: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The next item following a partial list of returned items. For example, if a request is
        /// made to return <code>maxResults</code> number of items, <code>NextToken</code> allows you
        /// to return more items in your list starting at the location pointed to by the next
        /// token.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of items to be returned.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>A Boolean value with a default value of <code>FALSE</code> that returns deleted backup
        /// plans when set to <code>TRUE</code>.</p>
        pub fn include_deleted(mut self, input: bool) -> Self {
            self.include_deleted = Some(input);
            self
        }
        pub fn set_include_deleted(mut self, input: std::option::Option<bool>) -> Self {
            self.include_deleted = input;
            self
        }
        /// Consumes the builder and constructs a [`ListBackupPlansInput`](crate::input::ListBackupPlansInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListBackupPlansInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListBackupPlansInput {
                next_token: self.next_token,
                max_results: self.max_results,
                include_deleted: self.include_deleted,
            })
        }
    }
}
#[doc(hidden)]
pub type ListBackupPlansInputOperationOutputAlias = crate::operation::ListBackupPlans;
#[doc(hidden)]
pub type ListBackupPlansInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListBackupPlansInput {
    /// Consumes the builder and constructs an Operation<[`ListBackupPlans`](crate::operation::ListBackupPlans)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::ListBackupPlans,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::ListBackupPlans::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "ListBackupPlans",
                "backup",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/backup/plans").expect("formatting should succeed");
        Ok(())
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        if let Some(inner_39) = &self.next_token {
            query.push_kv("nextToken", &smithy_http::query::fmt_string(&inner_39));
        }
        if let Some(inner_40) = &self.max_results {
            query.push_kv(
                "maxResults",
                &smithy_types::primitive::Encoder::from(*inner_40).encode(),
            );
        }
        if let Some(inner_41) = &self.include_deleted {
            query.push_kv(
                "includeDeleted",
                &smithy_types::primitive::Encoder::from(*inner_41).encode(),
            );
        }
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        Ok(builder.method("GET").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListBackupPlansInput`](crate::input::ListBackupPlansInput)
    pub fn builder() -> crate::input::list_backup_plans_input::Builder {
        crate::input::list_backup_plans_input::Builder::default()
    }
}

/// See [`ListBackupPlanTemplatesInput`](crate::input::ListBackupPlanTemplatesInput)
pub mod list_backup_plan_templates_input {
    /// A builder for [`ListBackupPlanTemplatesInput`](crate::input::ListBackupPlanTemplatesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The next item following a partial list of returned items. For example, if a request is
        /// made to return <code>maxResults</code> number of items, <code>NextToken</code> allows you
        /// to return more items in your list starting at the location pointed to by the next
        /// token.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of items to be returned.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListBackupPlanTemplatesInput`](crate::input::ListBackupPlanTemplatesInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListBackupPlanTemplatesInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListBackupPlanTemplatesInput {
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}
#[doc(hidden)]
pub type ListBackupPlanTemplatesInputOperationOutputAlias =
    crate::operation::ListBackupPlanTemplates;
#[doc(hidden)]
pub type ListBackupPlanTemplatesInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListBackupPlanTemplatesInput {
    /// Consumes the builder and constructs an Operation<[`ListBackupPlanTemplates`](crate::operation::ListBackupPlanTemplates)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::ListBackupPlanTemplates,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::ListBackupPlanTemplates::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "ListBackupPlanTemplates",
                "backup",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/backup/template/plans").expect("formatting should succeed");
        Ok(())
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        if let Some(inner_42) = &self.next_token {
            query.push_kv("nextToken", &smithy_http::query::fmt_string(&inner_42));
        }
        if let Some(inner_43) = &self.max_results {
            query.push_kv(
                "maxResults",
                &smithy_types::primitive::Encoder::from(*inner_43).encode(),
            );
        }
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        Ok(builder.method("GET").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListBackupPlanTemplatesInput`](crate::input::ListBackupPlanTemplatesInput)
    pub fn builder() -> crate::input::list_backup_plan_templates_input::Builder {
        crate::input::list_backup_plan_templates_input::Builder::default()
    }
}

/// See [`ListBackupPlanVersionsInput`](crate::input::ListBackupPlanVersionsInput)
pub mod list_backup_plan_versions_input {
    /// A builder for [`ListBackupPlanVersionsInput`](crate::input::ListBackupPlanVersionsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) backup_plan_id: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>Uniquely identifies a backup plan.</p>
        pub fn backup_plan_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.backup_plan_id = Some(input.into());
            self
        }
        pub fn set_backup_plan_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.backup_plan_id = input;
            self
        }
        /// <p>The next item following a partial list of returned items. For example, if a request is
        /// made to return <code>maxResults</code> number of items, <code>NextToken</code> allows you
        /// to return more items in your list starting at the location pointed to by the next
        /// token.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of items to be returned.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListBackupPlanVersionsInput`](crate::input::ListBackupPlanVersionsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListBackupPlanVersionsInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListBackupPlanVersionsInput {
                backup_plan_id: self.backup_plan_id,
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}
#[doc(hidden)]
pub type ListBackupPlanVersionsInputOperationOutputAlias = crate::operation::ListBackupPlanVersions;
#[doc(hidden)]
pub type ListBackupPlanVersionsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListBackupPlanVersionsInput {
    /// Consumes the builder and constructs an Operation<[`ListBackupPlanVersions`](crate::operation::ListBackupPlanVersions)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::ListBackupPlanVersions,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::ListBackupPlanVersions::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "ListBackupPlanVersions",
                "backup",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let input_44 = &self.backup_plan_id;
        let input_44 =
            input_44
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "backup_plan_id",
                    details: "cannot be empty or unset",
                })?;
        let backup_plan_id = smithy_http::label::fmt_string(input_44, false);
        if backup_plan_id.is_empty() {
            return Err(smithy_http::operation::BuildError::MissingField {
                field: "backup_plan_id",
                details: "cannot be empty or unset",
            });
        }
        write!(
            output,
            "/backup/plans/{BackupPlanId}/versions",
            BackupPlanId = backup_plan_id
        )
        .expect("formatting should succeed");
        Ok(())
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        if let Some(inner_45) = &self.next_token {
            query.push_kv("nextToken", &smithy_http::query::fmt_string(&inner_45));
        }
        if let Some(inner_46) = &self.max_results {
            query.push_kv(
                "maxResults",
                &smithy_types::primitive::Encoder::from(*inner_46).encode(),
            );
        }
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        Ok(builder.method("GET").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListBackupPlanVersionsInput`](crate::input::ListBackupPlanVersionsInput)
    pub fn builder() -> crate::input::list_backup_plan_versions_input::Builder {
        crate::input::list_backup_plan_versions_input::Builder::default()
    }
}

/// See [`ListBackupSelectionsInput`](crate::input::ListBackupSelectionsInput)
pub mod list_backup_selections_input {
    /// A builder for [`ListBackupSelectionsInput`](crate::input::ListBackupSelectionsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) backup_plan_id: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>Uniquely identifies a backup plan.</p>
        pub fn backup_plan_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.backup_plan_id = Some(input.into());
            self
        }
        pub fn set_backup_plan_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.backup_plan_id = input;
            self
        }
        /// <p>The next item following a partial list of returned items. For example, if a request is
        /// made to return <code>maxResults</code> number of items, <code>NextToken</code> allows you
        /// to return more items in your list starting at the location pointed to by the next
        /// token.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of items to be returned.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListBackupSelectionsInput`](crate::input::ListBackupSelectionsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListBackupSelectionsInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListBackupSelectionsInput {
                backup_plan_id: self.backup_plan_id,
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}
#[doc(hidden)]
pub type ListBackupSelectionsInputOperationOutputAlias = crate::operation::ListBackupSelections;
#[doc(hidden)]
pub type ListBackupSelectionsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListBackupSelectionsInput {
    /// Consumes the builder and constructs an Operation<[`ListBackupSelections`](crate::operation::ListBackupSelections)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::ListBackupSelections,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::ListBackupSelections::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "ListBackupSelections",
                "backup",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let input_47 = &self.backup_plan_id;
        let input_47 =
            input_47
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "backup_plan_id",
                    details: "cannot be empty or unset",
                })?;
        let backup_plan_id = smithy_http::label::fmt_string(input_47, false);
        if backup_plan_id.is_empty() {
            return Err(smithy_http::operation::BuildError::MissingField {
                field: "backup_plan_id",
                details: "cannot be empty or unset",
            });
        }
        write!(
            output,
            "/backup/plans/{BackupPlanId}/selections",
            BackupPlanId = backup_plan_id
        )
        .expect("formatting should succeed");
        Ok(())
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        if let Some(inner_48) = &self.next_token {
            query.push_kv("nextToken", &smithy_http::query::fmt_string(&inner_48));
        }
        if let Some(inner_49) = &self.max_results {
            query.push_kv(
                "maxResults",
                &smithy_types::primitive::Encoder::from(*inner_49).encode(),
            );
        }
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        Ok(builder.method("GET").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListBackupSelectionsInput`](crate::input::ListBackupSelectionsInput)
    pub fn builder() -> crate::input::list_backup_selections_input::Builder {
        crate::input::list_backup_selections_input::Builder::default()
    }
}

/// See [`ListBackupVaultsInput`](crate::input::ListBackupVaultsInput)
pub mod list_backup_vaults_input {
    /// A builder for [`ListBackupVaultsInput`](crate::input::ListBackupVaultsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The next item following a partial list of returned items. For example, if a request is
        /// made to return <code>maxResults</code> number of items, <code>NextToken</code> allows you
        /// to return more items in your list starting at the location pointed to by the next
        /// token.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of items to be returned.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListBackupVaultsInput`](crate::input::ListBackupVaultsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListBackupVaultsInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListBackupVaultsInput {
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}
#[doc(hidden)]
pub type ListBackupVaultsInputOperationOutputAlias = crate::operation::ListBackupVaults;
#[doc(hidden)]
pub type ListBackupVaultsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListBackupVaultsInput {
    /// Consumes the builder and constructs an Operation<[`ListBackupVaults`](crate::operation::ListBackupVaults)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::ListBackupVaults,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::ListBackupVaults::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "ListBackupVaults",
                "backup",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/backup-vaults").expect("formatting should succeed");
        Ok(())
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        if let Some(inner_50) = &self.next_token {
            query.push_kv("nextToken", &smithy_http::query::fmt_string(&inner_50));
        }
        if let Some(inner_51) = &self.max_results {
            query.push_kv(
                "maxResults",
                &smithy_types::primitive::Encoder::from(*inner_51).encode(),
            );
        }
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        Ok(builder.method("GET").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListBackupVaultsInput`](crate::input::ListBackupVaultsInput)
    pub fn builder() -> crate::input::list_backup_vaults_input::Builder {
        crate::input::list_backup_vaults_input::Builder::default()
    }
}

/// See [`ListCopyJobsInput`](crate::input::ListCopyJobsInput)
pub mod list_copy_jobs_input {
    /// A builder for [`ListCopyJobsInput`](crate::input::ListCopyJobsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) by_resource_arn: std::option::Option<std::string::String>,
        pub(crate) by_state: std::option::Option<crate::model::CopyJobState>,
        pub(crate) by_created_before: std::option::Option<smithy_types::Instant>,
        pub(crate) by_created_after: std::option::Option<smithy_types::Instant>,
        pub(crate) by_resource_type: std::option::Option<std::string::String>,
        pub(crate) by_destination_vault_arn: std::option::Option<std::string::String>,
        pub(crate) by_account_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The next item following a partial list of returned items. For example, if a request is
        /// made to return maxResults number of items, NextToken allows you to return more items in
        /// your list starting at the location pointed to by the next token. </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of items to be returned.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>Returns only copy jobs that match the specified resource Amazon Resource Name (ARN).
        /// </p>
        pub fn by_resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.by_resource_arn = Some(input.into());
            self
        }
        pub fn set_by_resource_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.by_resource_arn = input;
            self
        }
        /// <p>Returns only copy jobs that are in the specified state.</p>
        pub fn by_state(mut self, input: crate::model::CopyJobState) -> Self {
            self.by_state = Some(input);
            self
        }
        pub fn set_by_state(
            mut self,
            input: std::option::Option<crate::model::CopyJobState>,
        ) -> Self {
            self.by_state = input;
            self
        }
        /// <p>Returns only copy jobs that were created before the specified date.</p>
        pub fn by_created_before(mut self, input: smithy_types::Instant) -> Self {
            self.by_created_before = Some(input);
            self
        }
        pub fn set_by_created_before(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.by_created_before = input;
            self
        }
        /// <p>Returns only copy jobs that were created after the specified date.</p>
        pub fn by_created_after(mut self, input: smithy_types::Instant) -> Self {
            self.by_created_after = Some(input);
            self
        }
        pub fn set_by_created_after(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.by_created_after = input;
            self
        }
        /// <p>Returns only backup jobs for the specified resources:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>DynamoDB</code> for Amazon DynamoDB</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>EBS</code> for Amazon Elastic Block Store</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>EC2</code> for Amazon Elastic Compute Cloud</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>EFS</code> for Amazon Elastic File System</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>RDS</code> for Amazon Relational Database Service</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Aurora</code> for Amazon Aurora</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Storage Gateway</code> for AWS Storage Gateway</p>
        /// </li>
        /// </ul>
        pub fn by_resource_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.by_resource_type = Some(input.into());
            self
        }
        pub fn set_by_resource_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.by_resource_type = input;
            self
        }
        /// <p>An Amazon Resource Name (ARN) that uniquely identifies a source backup vault to copy
        /// from; for example, <code>arn:aws:backup:us-east-1:123456789012:vault:aBackupVault</code>.
        /// </p>
        pub fn by_destination_vault_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.by_destination_vault_arn = Some(input.into());
            self
        }
        pub fn set_by_destination_vault_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.by_destination_vault_arn = input;
            self
        }
        /// <p>The account ID to list the jobs from. Returns only copy jobs associated with the
        /// specified account ID.</p>
        pub fn by_account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.by_account_id = Some(input.into());
            self
        }
        pub fn set_by_account_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.by_account_id = input;
            self
        }
        /// Consumes the builder and constructs a [`ListCopyJobsInput`](crate::input::ListCopyJobsInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::ListCopyJobsInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::ListCopyJobsInput {
                next_token: self.next_token,
                max_results: self.max_results,
                by_resource_arn: self.by_resource_arn,
                by_state: self.by_state,
                by_created_before: self.by_created_before,
                by_created_after: self.by_created_after,
                by_resource_type: self.by_resource_type,
                by_destination_vault_arn: self.by_destination_vault_arn,
                by_account_id: self.by_account_id,
            })
        }
    }
}
#[doc(hidden)]
pub type ListCopyJobsInputOperationOutputAlias = crate::operation::ListCopyJobs;
#[doc(hidden)]
pub type ListCopyJobsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListCopyJobsInput {
    /// Consumes the builder and constructs an Operation<[`ListCopyJobs`](crate::operation::ListCopyJobs)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::ListCopyJobs,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::ListCopyJobs::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "ListCopyJobs",
                "backup",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/copy-jobs").expect("formatting should succeed");
        Ok(())
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        if let Some(inner_52) = &self.next_token {
            query.push_kv("nextToken", &smithy_http::query::fmt_string(&inner_52));
        }
        if let Some(inner_53) = &self.max_results {
            query.push_kv(
                "maxResults",
                &smithy_types::primitive::Encoder::from(*inner_53).encode(),
            );
        }
        if let Some(inner_54) = &self.by_resource_arn {
            query.push_kv("resourceArn", &smithy_http::query::fmt_string(&inner_54));
        }
        if let Some(inner_55) = &self.by_state {
            query.push_kv("state", &smithy_http::query::fmt_string(&inner_55));
        }
        if let Some(inner_56) = &self.by_created_before {
            query.push_kv(
                "createdBefore",
                &smithy_http::query::fmt_timestamp(
                    inner_56,
                    smithy_types::instant::Format::DateTime,
                ),
            );
        }
        if let Some(inner_57) = &self.by_created_after {
            query.push_kv(
                "createdAfter",
                &smithy_http::query::fmt_timestamp(
                    inner_57,
                    smithy_types::instant::Format::DateTime,
                ),
            );
        }
        if let Some(inner_58) = &self.by_resource_type {
            query.push_kv("resourceType", &smithy_http::query::fmt_string(&inner_58));
        }
        if let Some(inner_59) = &self.by_destination_vault_arn {
            query.push_kv(
                "destinationVaultArn",
                &smithy_http::query::fmt_string(&inner_59),
            );
        }
        if let Some(inner_60) = &self.by_account_id {
            query.push_kv("accountId", &smithy_http::query::fmt_string(&inner_60));
        }
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        Ok(builder.method("GET").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListCopyJobsInput`](crate::input::ListCopyJobsInput)
    pub fn builder() -> crate::input::list_copy_jobs_input::Builder {
        crate::input::list_copy_jobs_input::Builder::default()
    }
}

/// See [`ListProtectedResourcesInput`](crate::input::ListProtectedResourcesInput)
pub mod list_protected_resources_input {
    /// A builder for [`ListProtectedResourcesInput`](crate::input::ListProtectedResourcesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The next item following a partial list of returned items. For example, if a request is
        /// made to return <code>maxResults</code> number of items, <code>NextToken</code> allows you
        /// to return more items in your list starting at the location pointed to by the next
        /// token.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of items to be returned.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListProtectedResourcesInput`](crate::input::ListProtectedResourcesInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListProtectedResourcesInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListProtectedResourcesInput {
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}
#[doc(hidden)]
pub type ListProtectedResourcesInputOperationOutputAlias = crate::operation::ListProtectedResources;
#[doc(hidden)]
pub type ListProtectedResourcesInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListProtectedResourcesInput {
    /// Consumes the builder and constructs an Operation<[`ListProtectedResources`](crate::operation::ListProtectedResources)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::ListProtectedResources,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::ListProtectedResources::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "ListProtectedResources",
                "backup",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/resources").expect("formatting should succeed");
        Ok(())
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        if let Some(inner_61) = &self.next_token {
            query.push_kv("nextToken", &smithy_http::query::fmt_string(&inner_61));
        }
        if let Some(inner_62) = &self.max_results {
            query.push_kv(
                "maxResults",
                &smithy_types::primitive::Encoder::from(*inner_62).encode(),
            );
        }
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        Ok(builder.method("GET").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListProtectedResourcesInput`](crate::input::ListProtectedResourcesInput)
    pub fn builder() -> crate::input::list_protected_resources_input::Builder {
        crate::input::list_protected_resources_input::Builder::default()
    }
}

/// See [`ListRecoveryPointsByBackupVaultInput`](crate::input::ListRecoveryPointsByBackupVaultInput)
pub mod list_recovery_points_by_backup_vault_input {
    /// A builder for [`ListRecoveryPointsByBackupVaultInput`](crate::input::ListRecoveryPointsByBackupVaultInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) backup_vault_name: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) by_resource_arn: std::option::Option<std::string::String>,
        pub(crate) by_resource_type: std::option::Option<std::string::String>,
        pub(crate) by_backup_plan_id: std::option::Option<std::string::String>,
        pub(crate) by_created_before: std::option::Option<smithy_types::Instant>,
        pub(crate) by_created_after: std::option::Option<smithy_types::Instant>,
    }
    impl Builder {
        /// <p>The name of a logical container where backups are stored. Backup vaults are identified
        /// by names that are unique to the account used to create them and the AWS Region where they
        /// are created. They consist of lowercase letters, numbers, and hyphens.</p>
        pub fn backup_vault_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.backup_vault_name = Some(input.into());
            self
        }
        pub fn set_backup_vault_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.backup_vault_name = input;
            self
        }
        /// <p>The next item following a partial list of returned items. For example, if a request is
        /// made to return <code>maxResults</code> number of items, <code>NextToken</code> allows you
        /// to return more items in your list starting at the location pointed to by the next
        /// token.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of items to be returned.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>Returns only recovery points that match the specified resource Amazon Resource Name
        /// (ARN).</p>
        pub fn by_resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.by_resource_arn = Some(input.into());
            self
        }
        pub fn set_by_resource_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.by_resource_arn = input;
            self
        }
        /// <p>Returns only recovery points that match the specified resource type.</p>
        pub fn by_resource_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.by_resource_type = Some(input.into());
            self
        }
        pub fn set_by_resource_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.by_resource_type = input;
            self
        }
        /// <p>Returns only recovery points that match the specified backup plan ID.</p>
        pub fn by_backup_plan_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.by_backup_plan_id = Some(input.into());
            self
        }
        pub fn set_by_backup_plan_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.by_backup_plan_id = input;
            self
        }
        /// <p>Returns only recovery points that were created before the specified timestamp.</p>
        pub fn by_created_before(mut self, input: smithy_types::Instant) -> Self {
            self.by_created_before = Some(input);
            self
        }
        pub fn set_by_created_before(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.by_created_before = input;
            self
        }
        /// <p>Returns only recovery points that were created after the specified timestamp.</p>
        pub fn by_created_after(mut self, input: smithy_types::Instant) -> Self {
            self.by_created_after = Some(input);
            self
        }
        pub fn set_by_created_after(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.by_created_after = input;
            self
        }
        /// Consumes the builder and constructs a [`ListRecoveryPointsByBackupVaultInput`](crate::input::ListRecoveryPointsByBackupVaultInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListRecoveryPointsByBackupVaultInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListRecoveryPointsByBackupVaultInput {
                backup_vault_name: self.backup_vault_name,
                next_token: self.next_token,
                max_results: self.max_results,
                by_resource_arn: self.by_resource_arn,
                by_resource_type: self.by_resource_type,
                by_backup_plan_id: self.by_backup_plan_id,
                by_created_before: self.by_created_before,
                by_created_after: self.by_created_after,
            })
        }
    }
}
#[doc(hidden)]
pub type ListRecoveryPointsByBackupVaultInputOperationOutputAlias =
    crate::operation::ListRecoveryPointsByBackupVault;
#[doc(hidden)]
pub type ListRecoveryPointsByBackupVaultInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListRecoveryPointsByBackupVaultInput {
    /// Consumes the builder and constructs an Operation<[`ListRecoveryPointsByBackupVault`](crate::operation::ListRecoveryPointsByBackupVault)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::ListRecoveryPointsByBackupVault,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::ListRecoveryPointsByBackupVault::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "ListRecoveryPointsByBackupVault",
                "backup",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let input_63 = &self.backup_vault_name;
        let input_63 =
            input_63
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "backup_vault_name",
                    details: "cannot be empty or unset",
                })?;
        let backup_vault_name = smithy_http::label::fmt_string(input_63, false);
        if backup_vault_name.is_empty() {
            return Err(smithy_http::operation::BuildError::MissingField {
                field: "backup_vault_name",
                details: "cannot be empty or unset",
            });
        }
        write!(
            output,
            "/backup-vaults/{BackupVaultName}/recovery-points",
            BackupVaultName = backup_vault_name
        )
        .expect("formatting should succeed");
        Ok(())
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        if let Some(inner_64) = &self.next_token {
            query.push_kv("nextToken", &smithy_http::query::fmt_string(&inner_64));
        }
        if let Some(inner_65) = &self.max_results {
            query.push_kv(
                "maxResults",
                &smithy_types::primitive::Encoder::from(*inner_65).encode(),
            );
        }
        if let Some(inner_66) = &self.by_resource_arn {
            query.push_kv("resourceArn", &smithy_http::query::fmt_string(&inner_66));
        }
        if let Some(inner_67) = &self.by_resource_type {
            query.push_kv("resourceType", &smithy_http::query::fmt_string(&inner_67));
        }
        if let Some(inner_68) = &self.by_backup_plan_id {
            query.push_kv("backupPlanId", &smithy_http::query::fmt_string(&inner_68));
        }
        if let Some(inner_69) = &self.by_created_before {
            query.push_kv(
                "createdBefore",
                &smithy_http::query::fmt_timestamp(
                    inner_69,
                    smithy_types::instant::Format::DateTime,
                ),
            );
        }
        if let Some(inner_70) = &self.by_created_after {
            query.push_kv(
                "createdAfter",
                &smithy_http::query::fmt_timestamp(
                    inner_70,
                    smithy_types::instant::Format::DateTime,
                ),
            );
        }
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        Ok(builder.method("GET").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListRecoveryPointsByBackupVaultInput`](crate::input::ListRecoveryPointsByBackupVaultInput)
    pub fn builder() -> crate::input::list_recovery_points_by_backup_vault_input::Builder {
        crate::input::list_recovery_points_by_backup_vault_input::Builder::default()
    }
}

/// See [`ListRecoveryPointsByResourceInput`](crate::input::ListRecoveryPointsByResourceInput)
pub mod list_recovery_points_by_resource_input {
    /// A builder for [`ListRecoveryPointsByResourceInput`](crate::input::ListRecoveryPointsByResourceInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>An ARN that uniquely identifies a resource. The format of the ARN depends on the
        /// resource type.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// <p>The next item following a partial list of returned items. For example, if a request is
        /// made to return <code>maxResults</code> number of items, <code>NextToken</code> allows you
        /// to return more items in your list starting at the location pointed to by the next
        /// token.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of items to be returned.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListRecoveryPointsByResourceInput`](crate::input::ListRecoveryPointsByResourceInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListRecoveryPointsByResourceInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListRecoveryPointsByResourceInput {
                resource_arn: self.resource_arn,
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}
#[doc(hidden)]
pub type ListRecoveryPointsByResourceInputOperationOutputAlias =
    crate::operation::ListRecoveryPointsByResource;
#[doc(hidden)]
pub type ListRecoveryPointsByResourceInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListRecoveryPointsByResourceInput {
    /// Consumes the builder and constructs an Operation<[`ListRecoveryPointsByResource`](crate::operation::ListRecoveryPointsByResource)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::ListRecoveryPointsByResource,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::ListRecoveryPointsByResource::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "ListRecoveryPointsByResource",
                "backup",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let input_71 = &self.resource_arn;
        let input_71 =
            input_71
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "resource_arn",
                    details: "cannot be empty or unset",
                })?;
        let resource_arn = smithy_http::label::fmt_string(input_71, false);
        if resource_arn.is_empty() {
            return Err(smithy_http::operation::BuildError::MissingField {
                field: "resource_arn",
                details: "cannot be empty or unset",
            });
        }
        write!(
            output,
            "/resources/{ResourceArn}/recovery-points",
            ResourceArn = resource_arn
        )
        .expect("formatting should succeed");
        Ok(())
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        if let Some(inner_72) = &self.next_token {
            query.push_kv("nextToken", &smithy_http::query::fmt_string(&inner_72));
        }
        if let Some(inner_73) = &self.max_results {
            query.push_kv(
                "maxResults",
                &smithy_types::primitive::Encoder::from(*inner_73).encode(),
            );
        }
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        Ok(builder.method("GET").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListRecoveryPointsByResourceInput`](crate::input::ListRecoveryPointsByResourceInput)
    pub fn builder() -> crate::input::list_recovery_points_by_resource_input::Builder {
        crate::input::list_recovery_points_by_resource_input::Builder::default()
    }
}

/// See [`ListRestoreJobsInput`](crate::input::ListRestoreJobsInput)
pub mod list_restore_jobs_input {
    /// A builder for [`ListRestoreJobsInput`](crate::input::ListRestoreJobsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) by_account_id: std::option::Option<std::string::String>,
        pub(crate) by_created_before: std::option::Option<smithy_types::Instant>,
        pub(crate) by_created_after: std::option::Option<smithy_types::Instant>,
        pub(crate) by_status: std::option::Option<crate::model::RestoreJobStatus>,
    }
    impl Builder {
        /// <p>The next item following a partial list of returned items. For example, if a request is
        /// made to return <code>maxResults</code> number of items, <code>NextToken</code> allows you
        /// to return more items in your list starting at the location pointed to by the next
        /// token.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of items to be returned.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The account ID to list the jobs from. Returns only restore jobs associated with the
        /// specified account ID.</p>
        pub fn by_account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.by_account_id = Some(input.into());
            self
        }
        pub fn set_by_account_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.by_account_id = input;
            self
        }
        /// <p>Returns only restore jobs that were created before the specified date.</p>
        pub fn by_created_before(mut self, input: smithy_types::Instant) -> Self {
            self.by_created_before = Some(input);
            self
        }
        pub fn set_by_created_before(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.by_created_before = input;
            self
        }
        /// <p>Returns only restore jobs that were created after the specified date.</p>
        pub fn by_created_after(mut self, input: smithy_types::Instant) -> Self {
            self.by_created_after = Some(input);
            self
        }
        pub fn set_by_created_after(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.by_created_after = input;
            self
        }
        /// <p>Returns only restore jobs associated with the specified job status.</p>
        pub fn by_status(mut self, input: crate::model::RestoreJobStatus) -> Self {
            self.by_status = Some(input);
            self
        }
        pub fn set_by_status(
            mut self,
            input: std::option::Option<crate::model::RestoreJobStatus>,
        ) -> Self {
            self.by_status = input;
            self
        }
        /// Consumes the builder and constructs a [`ListRestoreJobsInput`](crate::input::ListRestoreJobsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListRestoreJobsInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListRestoreJobsInput {
                next_token: self.next_token,
                max_results: self.max_results,
                by_account_id: self.by_account_id,
                by_created_before: self.by_created_before,
                by_created_after: self.by_created_after,
                by_status: self.by_status,
            })
        }
    }
}
#[doc(hidden)]
pub type ListRestoreJobsInputOperationOutputAlias = crate::operation::ListRestoreJobs;
#[doc(hidden)]
pub type ListRestoreJobsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListRestoreJobsInput {
    /// Consumes the builder and constructs an Operation<[`ListRestoreJobs`](crate::operation::ListRestoreJobs)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::ListRestoreJobs,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::ListRestoreJobs::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "ListRestoreJobs",
                "backup",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/restore-jobs").expect("formatting should succeed");
        Ok(())
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        if let Some(inner_74) = &self.next_token {
            query.push_kv("nextToken", &smithy_http::query::fmt_string(&inner_74));
        }
        if let Some(inner_75) = &self.max_results {
            query.push_kv(
                "maxResults",
                &smithy_types::primitive::Encoder::from(*inner_75).encode(),
            );
        }
        if let Some(inner_76) = &self.by_account_id {
            query.push_kv("accountId", &smithy_http::query::fmt_string(&inner_76));
        }
        if let Some(inner_77) = &self.by_created_before {
            query.push_kv(
                "createdBefore",
                &smithy_http::query::fmt_timestamp(
                    inner_77,
                    smithy_types::instant::Format::DateTime,
                ),
            );
        }
        if let Some(inner_78) = &self.by_created_after {
            query.push_kv(
                "createdAfter",
                &smithy_http::query::fmt_timestamp(
                    inner_78,
                    smithy_types::instant::Format::DateTime,
                ),
            );
        }
        if let Some(inner_79) = &self.by_status {
            query.push_kv("status", &smithy_http::query::fmt_string(&inner_79));
        }
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        Ok(builder.method("GET").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListRestoreJobsInput`](crate::input::ListRestoreJobsInput)
    pub fn builder() -> crate::input::list_restore_jobs_input::Builder {
        crate::input::list_restore_jobs_input::Builder::default()
    }
}

/// See [`ListTagsInput`](crate::input::ListTagsInput)
pub mod list_tags_input {
    /// A builder for [`ListTagsInput`](crate::input::ListTagsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>An Amazon Resource Name (ARN) that uniquely identifies a resource. The format of the ARN
        /// depends on the type of resource. Valid targets for <code>ListTags</code> are recovery
        /// points, backup plans, and backup vaults.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// <p>The next item following a partial list of returned items. For example, if a request is
        /// made to return <code>maxResults</code> number of items, <code>NextToken</code> allows you
        /// to return more items in your list starting at the location pointed to by the next
        /// token.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of items to be returned.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListTagsInput`](crate::input::ListTagsInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::ListTagsInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::ListTagsInput {
                resource_arn: self.resource_arn,
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}
#[doc(hidden)]
pub type ListTagsInputOperationOutputAlias = crate::operation::ListTags;
#[doc(hidden)]
pub type ListTagsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListTagsInput {
    /// Consumes the builder and constructs an Operation<[`ListTags`](crate::operation::ListTags)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::ListTags,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op =
                smithy_http::operation::Operation::new(request, crate::operation::ListTags::new())
                    .with_metadata(smithy_http::operation::Metadata::new("ListTags", "backup"));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let input_80 = &self.resource_arn;
        let input_80 =
            input_80
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "resource_arn",
                    details: "cannot be empty or unset",
                })?;
        let resource_arn = smithy_http::label::fmt_string(input_80, false);
        if resource_arn.is_empty() {
            return Err(smithy_http::operation::BuildError::MissingField {
                field: "resource_arn",
                details: "cannot be empty or unset",
            });
        }
        write!(output, "/tags/{ResourceArn}", ResourceArn = resource_arn)
            .expect("formatting should succeed");
        Ok(())
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        if let Some(inner_81) = &self.next_token {
            query.push_kv("nextToken", &smithy_http::query::fmt_string(&inner_81));
        }
        if let Some(inner_82) = &self.max_results {
            query.push_kv(
                "maxResults",
                &smithy_types::primitive::Encoder::from(*inner_82).encode(),
            );
        }
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        Ok(builder.method("GET").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListTagsInput`](crate::input::ListTagsInput)
    pub fn builder() -> crate::input::list_tags_input::Builder {
        crate::input::list_tags_input::Builder::default()
    }
}

/// See [`PutBackupVaultAccessPolicyInput`](crate::input::PutBackupVaultAccessPolicyInput)
pub mod put_backup_vault_access_policy_input {
    /// A builder for [`PutBackupVaultAccessPolicyInput`](crate::input::PutBackupVaultAccessPolicyInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) backup_vault_name: std::option::Option<std::string::String>,
        pub(crate) policy: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of a logical container where backups are stored. Backup vaults are identified
        /// by names that are unique to the account used to create them and the AWS Region where they
        /// are created. They consist of lowercase letters, numbers, and hyphens.</p>
        pub fn backup_vault_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.backup_vault_name = Some(input.into());
            self
        }
        pub fn set_backup_vault_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.backup_vault_name = input;
            self
        }
        /// <p>The backup vault access policy document in JSON format.</p>
        pub fn policy(mut self, input: impl Into<std::string::String>) -> Self {
            self.policy = Some(input.into());
            self
        }
        pub fn set_policy(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.policy = input;
            self
        }
        /// Consumes the builder and constructs a [`PutBackupVaultAccessPolicyInput`](crate::input::PutBackupVaultAccessPolicyInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::PutBackupVaultAccessPolicyInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::PutBackupVaultAccessPolicyInput {
                backup_vault_name: self.backup_vault_name,
                policy: self.policy,
            })
        }
    }
}
#[doc(hidden)]
pub type PutBackupVaultAccessPolicyInputOperationOutputAlias =
    crate::operation::PutBackupVaultAccessPolicy;
#[doc(hidden)]
pub type PutBackupVaultAccessPolicyInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl PutBackupVaultAccessPolicyInput {
    /// Consumes the builder and constructs an Operation<[`PutBackupVaultAccessPolicy`](crate::operation::PutBackupVaultAccessPolicy)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::PutBackupVaultAccessPolicy,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_put_backup_vault_access_policy(&self)
                    .map_err(|err| {
                        smithy_http::operation::BuildError::SerializationError(err.into())
                    })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::PutBackupVaultAccessPolicy::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "PutBackupVaultAccessPolicy",
                "backup",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let input_83 = &self.backup_vault_name;
        let input_83 =
            input_83
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "backup_vault_name",
                    details: "cannot be empty or unset",
                })?;
        let backup_vault_name = smithy_http::label::fmt_string(input_83, false);
        if backup_vault_name.is_empty() {
            return Err(smithy_http::operation::BuildError::MissingField {
                field: "backup_vault_name",
                details: "cannot be empty or unset",
            });
        }
        write!(
            output,
            "/backup-vaults/{BackupVaultName}/access-policy",
            BackupVaultName = backup_vault_name
        )
        .expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("PUT").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`PutBackupVaultAccessPolicyInput`](crate::input::PutBackupVaultAccessPolicyInput)
    pub fn builder() -> crate::input::put_backup_vault_access_policy_input::Builder {
        crate::input::put_backup_vault_access_policy_input::Builder::default()
    }
}

/// See [`PutBackupVaultNotificationsInput`](crate::input::PutBackupVaultNotificationsInput)
pub mod put_backup_vault_notifications_input {
    /// A builder for [`PutBackupVaultNotificationsInput`](crate::input::PutBackupVaultNotificationsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) backup_vault_name: std::option::Option<std::string::String>,
        pub(crate) sns_topic_arn: std::option::Option<std::string::String>,
        pub(crate) backup_vault_events:
            std::option::Option<std::vec::Vec<crate::model::BackupVaultEvent>>,
    }
    impl Builder {
        /// <p>The name of a logical container where backups are stored. Backup vaults are identified
        /// by names that are unique to the account used to create them and the AWS Region where they
        /// are created. They consist of lowercase letters, numbers, and hyphens.</p>
        pub fn backup_vault_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.backup_vault_name = Some(input.into());
            self
        }
        pub fn set_backup_vault_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.backup_vault_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) that specifies the topic for a backup vaults events; for
        /// example, <code>arn:aws:sns:us-west-2:111122223333:MyVaultTopic</code>.</p>
        pub fn sns_topic_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.sns_topic_arn = Some(input.into());
            self
        }
        pub fn set_sns_topic_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sns_topic_arn = input;
            self
        }
        pub fn backup_vault_events(
            mut self,
            input: impl Into<crate::model::BackupVaultEvent>,
        ) -> Self {
            let mut v = self.backup_vault_events.unwrap_or_default();
            v.push(input.into());
            self.backup_vault_events = Some(v);
            self
        }
        pub fn set_backup_vault_events(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::BackupVaultEvent>>,
        ) -> Self {
            self.backup_vault_events = input;
            self
        }
        /// Consumes the builder and constructs a [`PutBackupVaultNotificationsInput`](crate::input::PutBackupVaultNotificationsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::PutBackupVaultNotificationsInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::PutBackupVaultNotificationsInput {
                backup_vault_name: self.backup_vault_name,
                sns_topic_arn: self.sns_topic_arn,
                backup_vault_events: self.backup_vault_events,
            })
        }
    }
}
#[doc(hidden)]
pub type PutBackupVaultNotificationsInputOperationOutputAlias =
    crate::operation::PutBackupVaultNotifications;
#[doc(hidden)]
pub type PutBackupVaultNotificationsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl PutBackupVaultNotificationsInput {
    /// Consumes the builder and constructs an Operation<[`PutBackupVaultNotifications`](crate::operation::PutBackupVaultNotifications)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::PutBackupVaultNotifications,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_put_backup_vault_notifications(&self)
                    .map_err(|err| {
                        smithy_http::operation::BuildError::SerializationError(err.into())
                    })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::PutBackupVaultNotifications::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "PutBackupVaultNotifications",
                "backup",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let input_84 = &self.backup_vault_name;
        let input_84 =
            input_84
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "backup_vault_name",
                    details: "cannot be empty or unset",
                })?;
        let backup_vault_name = smithy_http::label::fmt_string(input_84, false);
        if backup_vault_name.is_empty() {
            return Err(smithy_http::operation::BuildError::MissingField {
                field: "backup_vault_name",
                details: "cannot be empty or unset",
            });
        }
        write!(
            output,
            "/backup-vaults/{BackupVaultName}/notification-configuration",
            BackupVaultName = backup_vault_name
        )
        .expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("PUT").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`PutBackupVaultNotificationsInput`](crate::input::PutBackupVaultNotificationsInput)
    pub fn builder() -> crate::input::put_backup_vault_notifications_input::Builder {
        crate::input::put_backup_vault_notifications_input::Builder::default()
    }
}

/// See [`StartBackupJobInput`](crate::input::StartBackupJobInput)
pub mod start_backup_job_input {
    /// A builder for [`StartBackupJobInput`](crate::input::StartBackupJobInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) backup_vault_name: std::option::Option<std::string::String>,
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) iam_role_arn: std::option::Option<std::string::String>,
        pub(crate) idempotency_token: std::option::Option<std::string::String>,
        pub(crate) start_window_minutes: std::option::Option<i64>,
        pub(crate) complete_window_minutes: std::option::Option<i64>,
        pub(crate) lifecycle: std::option::Option<crate::model::Lifecycle>,
        pub(crate) recovery_point_tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) backup_options: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The name of a logical container where backups are stored. Backup vaults are identified
        /// by names that are unique to the account used to create them and the AWS Region where they
        /// are created. They consist of lowercase letters, numbers, and hyphens.</p>
        pub fn backup_vault_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.backup_vault_name = Some(input.into());
            self
        }
        pub fn set_backup_vault_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.backup_vault_name = input;
            self
        }
        /// <p>An Amazon Resource Name (ARN) that uniquely identifies a resource. The format of the ARN
        /// depends on the resource type.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// <p>Specifies the IAM role ARN used to create the target recovery point; for example,
        /// <code>arn:aws:iam::123456789012:role/S3Access</code>.</p>
        pub fn iam_role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.iam_role_arn = Some(input.into());
            self
        }
        pub fn set_iam_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.iam_role_arn = input;
            self
        }
        /// <p>A customer chosen string that can be used to distinguish between calls to
        /// <code>StartBackupJob</code>.</p>
        pub fn idempotency_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.idempotency_token = Some(input.into());
            self
        }
        pub fn set_idempotency_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.idempotency_token = input;
            self
        }
        /// <p>A value in minutes after a backup is scheduled before a job will be canceled if it
        /// doesn't start successfully. This value is optional, and the default is 8 hours.</p>
        pub fn start_window_minutes(mut self, input: i64) -> Self {
            self.start_window_minutes = Some(input);
            self
        }
        pub fn set_start_window_minutes(mut self, input: std::option::Option<i64>) -> Self {
            self.start_window_minutes = input;
            self
        }
        /// <p>A value in minutes during which a successfully started backup must complete, or else AWS
        /// Backup will cancel the job. This value is optional. This value begins counting down from
        /// when the backup was scheduled. It does not add additional time for
        /// <code>StartWindowMinutes</code>, or if the backup started later than scheduled.</p>
        pub fn complete_window_minutes(mut self, input: i64) -> Self {
            self.complete_window_minutes = Some(input);
            self
        }
        pub fn set_complete_window_minutes(mut self, input: std::option::Option<i64>) -> Self {
            self.complete_window_minutes = input;
            self
        }
        /// <p>The lifecycle defines when a protected resource is transitioned to cold storage and when
        /// it expires. AWS Backup will transition and expire backups automatically according to the
        /// lifecycle that you define. </p>
        /// <p>Backups transitioned to cold storage must be stored in cold storage for a minimum of 90
        /// days. Therefore, the expire after days setting must be 90 days greater than the
        /// transition to cold after days setting. The transition to cold after days setting cannot
        /// be changed after a backup has been transitioned to cold. </p>
        /// <p>Only Amazon EFS file system backups can be transitioned to cold storage.</p>
        pub fn lifecycle(mut self, input: crate::model::Lifecycle) -> Self {
            self.lifecycle = Some(input);
            self
        }
        pub fn set_lifecycle(
            mut self,
            input: std::option::Option<crate::model::Lifecycle>,
        ) -> Self {
            self.lifecycle = input;
            self
        }
        pub fn recovery_point_tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.recovery_point_tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.recovery_point_tags = Some(hash_map);
            self
        }
        pub fn set_recovery_point_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.recovery_point_tags = input;
            self
        }
        pub fn backup_options(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.backup_options.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.backup_options = Some(hash_map);
            self
        }
        pub fn set_backup_options(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.backup_options = input;
            self
        }
        /// Consumes the builder and constructs a [`StartBackupJobInput`](crate::input::StartBackupJobInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::StartBackupJobInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::StartBackupJobInput {
                backup_vault_name: self.backup_vault_name,
                resource_arn: self.resource_arn,
                iam_role_arn: self.iam_role_arn,
                idempotency_token: self.idempotency_token,
                start_window_minutes: self.start_window_minutes,
                complete_window_minutes: self.complete_window_minutes,
                lifecycle: self.lifecycle,
                recovery_point_tags: self.recovery_point_tags,
                backup_options: self.backup_options,
            })
        }
    }
}
#[doc(hidden)]
pub type StartBackupJobInputOperationOutputAlias = crate::operation::StartBackupJob;
#[doc(hidden)]
pub type StartBackupJobInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl StartBackupJobInput {
    /// Consumes the builder and constructs an Operation<[`StartBackupJob`](crate::operation::StartBackupJob)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::StartBackupJob,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_start_backup_job(&self).map_err(
                |err| smithy_http::operation::BuildError::SerializationError(err.into()),
            )?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::StartBackupJob::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "StartBackupJob",
                "backup",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/backup-jobs").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("PUT").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`StartBackupJobInput`](crate::input::StartBackupJobInput)
    pub fn builder() -> crate::input::start_backup_job_input::Builder {
        crate::input::start_backup_job_input::Builder::default()
    }
}

/// See [`StartCopyJobInput`](crate::input::StartCopyJobInput)
pub mod start_copy_job_input {
    /// A builder for [`StartCopyJobInput`](crate::input::StartCopyJobInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) recovery_point_arn: std::option::Option<std::string::String>,
        pub(crate) source_backup_vault_name: std::option::Option<std::string::String>,
        pub(crate) destination_backup_vault_arn: std::option::Option<std::string::String>,
        pub(crate) iam_role_arn: std::option::Option<std::string::String>,
        pub(crate) idempotency_token: std::option::Option<std::string::String>,
        pub(crate) lifecycle: std::option::Option<crate::model::Lifecycle>,
    }
    impl Builder {
        /// <p>An ARN that uniquely identifies a recovery point to use for the copy job; for example,
        /// arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
        /// </p>
        pub fn recovery_point_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.recovery_point_arn = Some(input.into());
            self
        }
        pub fn set_recovery_point_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.recovery_point_arn = input;
            self
        }
        /// <p>The name of a logical source container where backups are stored. Backup vaults are
        /// identified by names that are unique to the account used to create them and the AWS Region
        /// where they are created. They consist of lowercase letters, numbers, and hyphens.</p>
        pub fn source_backup_vault_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_backup_vault_name = Some(input.into());
            self
        }
        pub fn set_source_backup_vault_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_backup_vault_name = input;
            self
        }
        /// <p>An Amazon Resource Name (ARN) that uniquely identifies a destination backup vault to
        /// copy to; for example,
        /// <code>arn:aws:backup:us-east-1:123456789012:vault:aBackupVault</code>.</p>
        pub fn destination_backup_vault_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.destination_backup_vault_arn = Some(input.into());
            self
        }
        pub fn set_destination_backup_vault_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.destination_backup_vault_arn = input;
            self
        }
        /// <p>Specifies the IAM role ARN used to copy the target recovery point; for example,
        /// <code>arn:aws:iam::123456789012:role/S3Access</code>.</p>
        pub fn iam_role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.iam_role_arn = Some(input.into());
            self
        }
        pub fn set_iam_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.iam_role_arn = input;
            self
        }
        /// <p>A customer chosen string that can be used to distinguish between calls to
        /// <code>StartCopyJob</code>.</p>
        pub fn idempotency_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.idempotency_token = Some(input.into());
            self
        }
        pub fn set_idempotency_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.idempotency_token = input;
            self
        }
        /// <p>Contains an array of <code>Transition</code> objects specifying how long in days before
        /// a recovery point transitions to cold storage or is deleted.</p>
        /// <p>Backups transitioned to cold storage must be stored in cold storage for a minimum of 90
        /// days. Therefore, on the console, the expire after days setting must be 90 days greater
        /// than the transition to cold after days setting. The transition to cold after days
        /// setting cannot be changed after a backup has been transitioned to cold.</p>
        /// <p>Only Amazon EFS file system backups can be transitioned to cold storage.</p>
        pub fn lifecycle(mut self, input: crate::model::Lifecycle) -> Self {
            self.lifecycle = Some(input);
            self
        }
        pub fn set_lifecycle(
            mut self,
            input: std::option::Option<crate::model::Lifecycle>,
        ) -> Self {
            self.lifecycle = input;
            self
        }
        /// Consumes the builder and constructs a [`StartCopyJobInput`](crate::input::StartCopyJobInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::StartCopyJobInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::StartCopyJobInput {
                recovery_point_arn: self.recovery_point_arn,
                source_backup_vault_name: self.source_backup_vault_name,
                destination_backup_vault_arn: self.destination_backup_vault_arn,
                iam_role_arn: self.iam_role_arn,
                idempotency_token: self.idempotency_token,
                lifecycle: self.lifecycle,
            })
        }
    }
}
#[doc(hidden)]
pub type StartCopyJobInputOperationOutputAlias = crate::operation::StartCopyJob;
#[doc(hidden)]
pub type StartCopyJobInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl StartCopyJobInput {
    /// Consumes the builder and constructs an Operation<[`StartCopyJob`](crate::operation::StartCopyJob)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::StartCopyJob,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_start_copy_job(&self).map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::StartCopyJob::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "StartCopyJob",
                "backup",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/copy-jobs").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("PUT").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`StartCopyJobInput`](crate::input::StartCopyJobInput)
    pub fn builder() -> crate::input::start_copy_job_input::Builder {
        crate::input::start_copy_job_input::Builder::default()
    }
}

/// See [`StartRestoreJobInput`](crate::input::StartRestoreJobInput)
pub mod start_restore_job_input {
    /// A builder for [`StartRestoreJobInput`](crate::input::StartRestoreJobInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) recovery_point_arn: std::option::Option<std::string::String>,
        pub(crate) metadata: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) iam_role_arn: std::option::Option<std::string::String>,
        pub(crate) idempotency_token: std::option::Option<std::string::String>,
        pub(crate) resource_type: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>An ARN that uniquely identifies a recovery point; for example,
        /// <code>arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45</code>.</p>
        pub fn recovery_point_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.recovery_point_arn = Some(input.into());
            self
        }
        pub fn set_recovery_point_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.recovery_point_arn = input;
            self
        }
        pub fn metadata(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.metadata.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.metadata = Some(hash_map);
            self
        }
        pub fn set_metadata(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.metadata = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the IAM role that AWS Backup uses to create the target
        /// recovery point; for example, <code>arn:aws:iam::123456789012:role/S3Access</code>.</p>
        pub fn iam_role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.iam_role_arn = Some(input.into());
            self
        }
        pub fn set_iam_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.iam_role_arn = input;
            self
        }
        /// <p>A customer chosen string that can be used to distinguish between calls to
        /// <code>StartRestoreJob</code>.</p>
        pub fn idempotency_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.idempotency_token = Some(input.into());
            self
        }
        pub fn set_idempotency_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.idempotency_token = input;
            self
        }
        /// <p>Starts a job to restore a recovery point for one of the following resources:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>DynamoDB</code> for Amazon DynamoDB</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>EBS</code> for Amazon Elastic Block Store</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>EC2</code> for Amazon Elastic Compute Cloud</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>EFS</code> for Amazon Elastic File System</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>RDS</code> for Amazon Relational Database Service</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Aurora</code> for Amazon Aurora</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Storage Gateway</code> for AWS Storage Gateway</p>
        /// </li>
        /// </ul>
        pub fn resource_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_type = Some(input.into());
            self
        }
        pub fn set_resource_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_type = input;
            self
        }
        /// Consumes the builder and constructs a [`StartRestoreJobInput`](crate::input::StartRestoreJobInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::StartRestoreJobInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::StartRestoreJobInput {
                recovery_point_arn: self.recovery_point_arn,
                metadata: self.metadata,
                iam_role_arn: self.iam_role_arn,
                idempotency_token: self.idempotency_token,
                resource_type: self.resource_type,
            })
        }
    }
}
#[doc(hidden)]
pub type StartRestoreJobInputOperationOutputAlias = crate::operation::StartRestoreJob;
#[doc(hidden)]
pub type StartRestoreJobInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl StartRestoreJobInput {
    /// Consumes the builder and constructs an Operation<[`StartRestoreJob`](crate::operation::StartRestoreJob)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::StartRestoreJob,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_start_restore_job(&self).map_err(
                |err| smithy_http::operation::BuildError::SerializationError(err.into()),
            )?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::StartRestoreJob::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "StartRestoreJob",
                "backup",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/restore-jobs").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("PUT").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`StartRestoreJobInput`](crate::input::StartRestoreJobInput)
    pub fn builder() -> crate::input::start_restore_job_input::Builder {
        crate::input::start_restore_job_input::Builder::default()
    }
}

/// See [`StopBackupJobInput`](crate::input::StopBackupJobInput)
pub mod stop_backup_job_input {
    /// A builder for [`StopBackupJobInput`](crate::input::StopBackupJobInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) backup_job_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Uniquely identifies a request to AWS Backup to back up a resource.</p>
        pub fn backup_job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.backup_job_id = Some(input.into());
            self
        }
        pub fn set_backup_job_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.backup_job_id = input;
            self
        }
        /// Consumes the builder and constructs a [`StopBackupJobInput`](crate::input::StopBackupJobInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::StopBackupJobInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::StopBackupJobInput {
                backup_job_id: self.backup_job_id,
            })
        }
    }
}
#[doc(hidden)]
pub type StopBackupJobInputOperationOutputAlias = crate::operation::StopBackupJob;
#[doc(hidden)]
pub type StopBackupJobInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl StopBackupJobInput {
    /// Consumes the builder and constructs an Operation<[`StopBackupJob`](crate::operation::StopBackupJob)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::StopBackupJob,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::StopBackupJob::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "StopBackupJob",
                "backup",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let input_85 = &self.backup_job_id;
        let input_85 =
            input_85
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "backup_job_id",
                    details: "cannot be empty or unset",
                })?;
        let backup_job_id = smithy_http::label::fmt_string(input_85, false);
        if backup_job_id.is_empty() {
            return Err(smithy_http::operation::BuildError::MissingField {
                field: "backup_job_id",
                details: "cannot be empty or unset",
            });
        }
        write!(
            output,
            "/backup-jobs/{BackupJobId}",
            BackupJobId = backup_job_id
        )
        .expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`StopBackupJobInput`](crate::input::StopBackupJobInput)
    pub fn builder() -> crate::input::stop_backup_job_input::Builder {
        crate::input::stop_backup_job_input::Builder::default()
    }
}

/// See [`TagResourceInput`](crate::input::TagResourceInput)
pub mod tag_resource_input {
    /// A builder for [`TagResourceInput`](crate::input::TagResourceInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>An ARN that uniquely identifies a resource. The format of the ARN depends on the type of
        /// the tagged resource.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`TagResourceInput`](crate::input::TagResourceInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::TagResourceInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::TagResourceInput {
                resource_arn: self.resource_arn,
                tags: self.tags,
            })
        }
    }
}
#[doc(hidden)]
pub type TagResourceInputOperationOutputAlias = crate::operation::TagResource;
#[doc(hidden)]
pub type TagResourceInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl TagResourceInput {
    /// Consumes the builder and constructs an Operation<[`TagResource`](crate::operation::TagResource)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::TagResource,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_tag_resource(&self).map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::TagResource::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "TagResource",
                "backup",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let input_86 = &self.resource_arn;
        let input_86 =
            input_86
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "resource_arn",
                    details: "cannot be empty or unset",
                })?;
        let resource_arn = smithy_http::label::fmt_string(input_86, false);
        if resource_arn.is_empty() {
            return Err(smithy_http::operation::BuildError::MissingField {
                field: "resource_arn",
                details: "cannot be empty or unset",
            });
        }
        write!(output, "/tags/{ResourceArn}", ResourceArn = resource_arn)
            .expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`TagResourceInput`](crate::input::TagResourceInput)
    pub fn builder() -> crate::input::tag_resource_input::Builder {
        crate::input::tag_resource_input::Builder::default()
    }
}

/// See [`UntagResourceInput`](crate::input::UntagResourceInput)
pub mod untag_resource_input {
    /// A builder for [`UntagResourceInput`](crate::input::UntagResourceInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) tag_key_list: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>An ARN that uniquely identifies a resource. The format of the ARN depends on the type of
        /// the tagged resource.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        pub fn tag_key_list(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.tag_key_list.unwrap_or_default();
            v.push(input.into());
            self.tag_key_list = Some(v);
            self
        }
        pub fn set_tag_key_list(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.tag_key_list = input;
            self
        }
        /// Consumes the builder and constructs a [`UntagResourceInput`](crate::input::UntagResourceInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::UntagResourceInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::UntagResourceInput {
                resource_arn: self.resource_arn,
                tag_key_list: self.tag_key_list,
            })
        }
    }
}
#[doc(hidden)]
pub type UntagResourceInputOperationOutputAlias = crate::operation::UntagResource;
#[doc(hidden)]
pub type UntagResourceInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl UntagResourceInput {
    /// Consumes the builder and constructs an Operation<[`UntagResource`](crate::operation::UntagResource)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::UntagResource,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_untag_resource(&self).map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::UntagResource::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "UntagResource",
                "backup",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let input_87 = &self.resource_arn;
        let input_87 =
            input_87
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "resource_arn",
                    details: "cannot be empty or unset",
                })?;
        let resource_arn = smithy_http::label::fmt_string(input_87, false);
        if resource_arn.is_empty() {
            return Err(smithy_http::operation::BuildError::MissingField {
                field: "resource_arn",
                details: "cannot be empty or unset",
            });
        }
        write!(output, "/untag/{ResourceArn}", ResourceArn = resource_arn)
            .expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`UntagResourceInput`](crate::input::UntagResourceInput)
    pub fn builder() -> crate::input::untag_resource_input::Builder {
        crate::input::untag_resource_input::Builder::default()
    }
}

/// See [`UpdateBackupPlanInput`](crate::input::UpdateBackupPlanInput)
pub mod update_backup_plan_input {
    /// A builder for [`UpdateBackupPlanInput`](crate::input::UpdateBackupPlanInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) backup_plan_id: std::option::Option<std::string::String>,
        pub(crate) backup_plan: std::option::Option<crate::model::BackupPlanInput>,
    }
    impl Builder {
        /// <p>Uniquely identifies a backup plan.</p>
        pub fn backup_plan_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.backup_plan_id = Some(input.into());
            self
        }
        pub fn set_backup_plan_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.backup_plan_id = input;
            self
        }
        /// <p>Specifies the body of a backup plan. Includes a <code>BackupPlanName</code> and one or
        /// more sets of <code>Rules</code>.</p>
        pub fn backup_plan(mut self, input: crate::model::BackupPlanInput) -> Self {
            self.backup_plan = Some(input);
            self
        }
        pub fn set_backup_plan(
            mut self,
            input: std::option::Option<crate::model::BackupPlanInput>,
        ) -> Self {
            self.backup_plan = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateBackupPlanInput`](crate::input::UpdateBackupPlanInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UpdateBackupPlanInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UpdateBackupPlanInput {
                backup_plan_id: self.backup_plan_id,
                backup_plan: self.backup_plan,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateBackupPlanInputOperationOutputAlias = crate::operation::UpdateBackupPlan;
#[doc(hidden)]
pub type UpdateBackupPlanInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl UpdateBackupPlanInput {
    /// Consumes the builder and constructs an Operation<[`UpdateBackupPlan`](crate::operation::UpdateBackupPlan)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::UpdateBackupPlan,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_update_backup_plan(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::UpdateBackupPlan::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "UpdateBackupPlan",
                "backup",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let input_88 = &self.backup_plan_id;
        let input_88 =
            input_88
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "backup_plan_id",
                    details: "cannot be empty or unset",
                })?;
        let backup_plan_id = smithy_http::label::fmt_string(input_88, false);
        if backup_plan_id.is_empty() {
            return Err(smithy_http::operation::BuildError::MissingField {
                field: "backup_plan_id",
                details: "cannot be empty or unset",
            });
        }
        write!(
            output,
            "/backup/plans/{BackupPlanId}",
            BackupPlanId = backup_plan_id
        )
        .expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`UpdateBackupPlanInput`](crate::input::UpdateBackupPlanInput)
    pub fn builder() -> crate::input::update_backup_plan_input::Builder {
        crate::input::update_backup_plan_input::Builder::default()
    }
}

/// See [`UpdateGlobalSettingsInput`](crate::input::UpdateGlobalSettingsInput)
pub mod update_global_settings_input {
    /// A builder for [`UpdateGlobalSettingsInput`](crate::input::UpdateGlobalSettingsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) global_settings: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        pub fn global_settings(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.global_settings.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.global_settings = Some(hash_map);
            self
        }
        pub fn set_global_settings(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.global_settings = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateGlobalSettingsInput`](crate::input::UpdateGlobalSettingsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UpdateGlobalSettingsInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UpdateGlobalSettingsInput {
                global_settings: self.global_settings,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateGlobalSettingsInputOperationOutputAlias = crate::operation::UpdateGlobalSettings;
#[doc(hidden)]
pub type UpdateGlobalSettingsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl UpdateGlobalSettingsInput {
    /// Consumes the builder and constructs an Operation<[`UpdateGlobalSettings`](crate::operation::UpdateGlobalSettings)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::UpdateGlobalSettings,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_update_global_settings(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::UpdateGlobalSettings::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "UpdateGlobalSettings",
                "backup",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/global-settings").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("PUT").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`UpdateGlobalSettingsInput`](crate::input::UpdateGlobalSettingsInput)
    pub fn builder() -> crate::input::update_global_settings_input::Builder {
        crate::input::update_global_settings_input::Builder::default()
    }
}

/// See [`UpdateRecoveryPointLifecycleInput`](crate::input::UpdateRecoveryPointLifecycleInput)
pub mod update_recovery_point_lifecycle_input {
    /// A builder for [`UpdateRecoveryPointLifecycleInput`](crate::input::UpdateRecoveryPointLifecycleInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) backup_vault_name: std::option::Option<std::string::String>,
        pub(crate) recovery_point_arn: std::option::Option<std::string::String>,
        pub(crate) lifecycle: std::option::Option<crate::model::Lifecycle>,
    }
    impl Builder {
        /// <p>The name of a logical container where backups are stored. Backup vaults are identified
        /// by names that are unique to the account used to create them and the AWS Region where they
        /// are created. They consist of lowercase letters, numbers, and hyphens.</p>
        pub fn backup_vault_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.backup_vault_name = Some(input.into());
            self
        }
        pub fn set_backup_vault_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.backup_vault_name = input;
            self
        }
        /// <p>An Amazon Resource Name (ARN) that uniquely identifies a recovery point; for example,
        /// <code>arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45</code>.</p>
        pub fn recovery_point_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.recovery_point_arn = Some(input.into());
            self
        }
        pub fn set_recovery_point_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.recovery_point_arn = input;
            self
        }
        /// <p>The lifecycle defines when a protected resource is transitioned to cold storage and when
        /// it expires. AWS Backup transitions and expires backups automatically according to the
        /// lifecycle that you define. </p>
        /// <p>Backups transitioned to cold storage must be stored in cold storage for a minimum of 90
        /// days. Therefore, the expire after days setting must be 90 days greater than the
        /// transition to cold after days setting. The transition to cold after days setting cannot
        /// be changed after a backup has been transitioned to cold. </p>
        pub fn lifecycle(mut self, input: crate::model::Lifecycle) -> Self {
            self.lifecycle = Some(input);
            self
        }
        pub fn set_lifecycle(
            mut self,
            input: std::option::Option<crate::model::Lifecycle>,
        ) -> Self {
            self.lifecycle = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateRecoveryPointLifecycleInput`](crate::input::UpdateRecoveryPointLifecycleInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UpdateRecoveryPointLifecycleInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UpdateRecoveryPointLifecycleInput {
                backup_vault_name: self.backup_vault_name,
                recovery_point_arn: self.recovery_point_arn,
                lifecycle: self.lifecycle,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateRecoveryPointLifecycleInputOperationOutputAlias =
    crate::operation::UpdateRecoveryPointLifecycle;
#[doc(hidden)]
pub type UpdateRecoveryPointLifecycleInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl UpdateRecoveryPointLifecycleInput {
    /// Consumes the builder and constructs an Operation<[`UpdateRecoveryPointLifecycle`](crate::operation::UpdateRecoveryPointLifecycle)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::UpdateRecoveryPointLifecycle,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_update_recovery_point_lifecycle(&self)
                    .map_err(|err| {
                        smithy_http::operation::BuildError::SerializationError(err.into())
                    })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::UpdateRecoveryPointLifecycle::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "UpdateRecoveryPointLifecycle",
                "backup",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let input_89 = &self.backup_vault_name;
        let input_89 =
            input_89
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "backup_vault_name",
                    details: "cannot be empty or unset",
                })?;
        let backup_vault_name = smithy_http::label::fmt_string(input_89, false);
        if backup_vault_name.is_empty() {
            return Err(smithy_http::operation::BuildError::MissingField {
                field: "backup_vault_name",
                details: "cannot be empty or unset",
            });
        }
        let input_90 = &self.recovery_point_arn;
        let input_90 =
            input_90
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "recovery_point_arn",
                    details: "cannot be empty or unset",
                })?;
        let recovery_point_arn = smithy_http::label::fmt_string(input_90, false);
        if recovery_point_arn.is_empty() {
            return Err(smithy_http::operation::BuildError::MissingField {
                field: "recovery_point_arn",
                details: "cannot be empty or unset",
            });
        }
        write!(
            output,
            "/backup-vaults/{BackupVaultName}/recovery-points/{RecoveryPointArn}",
            BackupVaultName = backup_vault_name,
            RecoveryPointArn = recovery_point_arn
        )
        .expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`UpdateRecoveryPointLifecycleInput`](crate::input::UpdateRecoveryPointLifecycleInput)
    pub fn builder() -> crate::input::update_recovery_point_lifecycle_input::Builder {
        crate::input::update_recovery_point_lifecycle_input::Builder::default()
    }
}

/// See [`UpdateRegionSettingsInput`](crate::input::UpdateRegionSettingsInput)
pub mod update_region_settings_input {
    /// A builder for [`UpdateRegionSettingsInput`](crate::input::UpdateRegionSettingsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_type_opt_in_preference:
            std::option::Option<std::collections::HashMap<std::string::String, bool>>,
    }
    impl Builder {
        pub fn resource_type_opt_in_preference(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<bool>,
        ) -> Self {
            let mut hash_map = self.resource_type_opt_in_preference.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.resource_type_opt_in_preference = Some(hash_map);
            self
        }
        pub fn set_resource_type_opt_in_preference(
            mut self,
            input: std::option::Option<std::collections::HashMap<std::string::String, bool>>,
        ) -> Self {
            self.resource_type_opt_in_preference = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateRegionSettingsInput`](crate::input::UpdateRegionSettingsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UpdateRegionSettingsInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UpdateRegionSettingsInput {
                resource_type_opt_in_preference: self.resource_type_opt_in_preference,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateRegionSettingsInputOperationOutputAlias = crate::operation::UpdateRegionSettings;
#[doc(hidden)]
pub type UpdateRegionSettingsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl UpdateRegionSettingsInput {
    /// Consumes the builder and constructs an Operation<[`UpdateRegionSettings`](crate::operation::UpdateRegionSettings)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::UpdateRegionSettings,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_update_region_settings(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::UpdateRegionSettings::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "UpdateRegionSettings",
                "backup",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/account-settings").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("PUT").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`UpdateRegionSettingsInput`](crate::input::UpdateRegionSettingsInput)
    pub fn builder() -> crate::input::update_region_settings_input::Builder {
        crate::input::update_region_settings_input::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateRegionSettingsInput {
    /// <p>Updates the list of services along with the opt-in preferences for the Region.</p>
    pub resource_type_opt_in_preference:
        std::option::Option<std::collections::HashMap<std::string::String, bool>>,
}
impl std::fmt::Debug for UpdateRegionSettingsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateRegionSettingsInput");
        formatter.field(
            "resource_type_opt_in_preference",
            &self.resource_type_opt_in_preference,
        );
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateRecoveryPointLifecycleInput {
    /// <p>The name of a logical container where backups are stored. Backup vaults are identified
    /// by names that are unique to the account used to create them and the AWS Region where they
    /// are created. They consist of lowercase letters, numbers, and hyphens.</p>
    pub backup_vault_name: std::option::Option<std::string::String>,
    /// <p>An Amazon Resource Name (ARN) that uniquely identifies a recovery point; for example,
    /// <code>arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45</code>.</p>
    pub recovery_point_arn: std::option::Option<std::string::String>,
    /// <p>The lifecycle defines when a protected resource is transitioned to cold storage and when
    /// it expires. AWS Backup transitions and expires backups automatically according to the
    /// lifecycle that you define. </p>
    /// <p>Backups transitioned to cold storage must be stored in cold storage for a minimum of 90
    /// days. Therefore, the expire after days setting must be 90 days greater than the
    /// transition to cold after days setting. The transition to cold after days setting cannot
    /// be changed after a backup has been transitioned to cold. </p>
    pub lifecycle: std::option::Option<crate::model::Lifecycle>,
}
impl std::fmt::Debug for UpdateRecoveryPointLifecycleInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateRecoveryPointLifecycleInput");
        formatter.field("backup_vault_name", &self.backup_vault_name);
        formatter.field("recovery_point_arn", &self.recovery_point_arn);
        formatter.field("lifecycle", &self.lifecycle);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateGlobalSettingsInput {
    /// <p>A list of resources along with the opt-in preferences for the account.</p>
    pub global_settings:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl std::fmt::Debug for UpdateGlobalSettingsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateGlobalSettingsInput");
        formatter.field("global_settings", &self.global_settings);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateBackupPlanInput {
    /// <p>Uniquely identifies a backup plan.</p>
    pub backup_plan_id: std::option::Option<std::string::String>,
    /// <p>Specifies the body of a backup plan. Includes a <code>BackupPlanName</code> and one or
    /// more sets of <code>Rules</code>.</p>
    pub backup_plan: std::option::Option<crate::model::BackupPlanInput>,
}
impl std::fmt::Debug for UpdateBackupPlanInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateBackupPlanInput");
        formatter.field("backup_plan_id", &self.backup_plan_id);
        formatter.field("backup_plan", &self.backup_plan);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UntagResourceInput {
    /// <p>An ARN that uniquely identifies a resource. The format of the ARN depends on the type of
    /// the tagged resource.</p>
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p>A list of keys to identify which key-value tags to remove from a resource.</p>
    pub tag_key_list: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for UntagResourceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UntagResourceInput");
        formatter.field("resource_arn", &self.resource_arn);
        formatter.field("tag_key_list", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TagResourceInput {
    /// <p>An ARN that uniquely identifies a resource. The format of the ARN depends on the type of
    /// the tagged resource.</p>
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p>Key-value pairs that are used to help organize your resources. You can assign your own
    /// metadata to the resources you create.</p>
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl std::fmt::Debug for TagResourceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TagResourceInput");
        formatter.field("resource_arn", &self.resource_arn);
        formatter.field("tags", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StopBackupJobInput {
    /// <p>Uniquely identifies a request to AWS Backup to back up a resource.</p>
    pub backup_job_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for StopBackupJobInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StopBackupJobInput");
        formatter.field("backup_job_id", &self.backup_job_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StartRestoreJobInput {
    /// <p>An ARN that uniquely identifies a recovery point; for example,
    /// <code>arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45</code>.</p>
    pub recovery_point_arn: std::option::Option<std::string::String>,
    /// <p>A set of metadata key-value pairs. Contains information, such as a resource name,
    /// required to restore a recovery point.</p>
    /// <p> You can get configuration metadata about a resource at the time it was backed up by
    /// calling <code>GetRecoveryPointRestoreMetadata</code>. However, values in addition to those
    /// provided by <code>GetRecoveryPointRestoreMetadata</code> might be required to restore a
    /// resource. For example, you might need to provide a new resource name if the original
    /// already exists.</p>
    /// <p>You need to specify specific metadata to restore an Amazon Elastic File System (Amazon
    /// EFS) instance:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>file-system-id</code>: The ID of the Amazon EFS file system that is backed
    /// up by AWS Backup. Returned in <code>GetRecoveryPointRestoreMetadata</code>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Encrypted</code>: A Boolean value that, if true, specifies that the file
    /// system is encrypted. If <code>KmsKeyId</code> is specified, <code>Encrypted</code>
    /// must be set to <code>true</code>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>KmsKeyId</code>: Specifies the AWS KMS key that is used to encrypt the
    /// restored file system. You can specify a key from another AWS account provided that
    /// key it is properly shared with your account via AWS KMS.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>PerformanceMode</code>: Specifies the throughput mode of the file
    /// system.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>CreationToken</code>: A user-supplied value that ensures the uniqueness
    /// (idempotency) of the request.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>newFileSystem</code>: A Boolean value that, if true, specifies that the
    /// recovery point is restored to a new Amazon EFS file system.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>ItemsToRestore </code>: An array of one to five strings where each string is
    /// a file path. Use <code>ItemsToRestore</code> to restore specific files or directories
    /// rather than the entire file system. This parameter is optional. For example,
    /// <code>"itemsToRestore":"[\"/my.test\"]"</code>.</p>
    /// </li>
    /// </ul>
    pub metadata:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The Amazon Resource Name (ARN) of the IAM role that AWS Backup uses to create the target
    /// recovery point; for example, <code>arn:aws:iam::123456789012:role/S3Access</code>.</p>
    pub iam_role_arn: std::option::Option<std::string::String>,
    /// <p>A customer chosen string that can be used to distinguish between calls to
    /// <code>StartRestoreJob</code>.</p>
    pub idempotency_token: std::option::Option<std::string::String>,
    /// <p>Starts a job to restore a recovery point for one of the following resources:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>DynamoDB</code> for Amazon DynamoDB</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>EBS</code> for Amazon Elastic Block Store</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>EC2</code> for Amazon Elastic Compute Cloud</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>EFS</code> for Amazon Elastic File System</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>RDS</code> for Amazon Relational Database Service</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Aurora</code> for Amazon Aurora</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Storage Gateway</code> for AWS Storage Gateway</p>
    /// </li>
    /// </ul>
    pub resource_type: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for StartRestoreJobInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StartRestoreJobInput");
        formatter.field("recovery_point_arn", &self.recovery_point_arn);
        formatter.field("metadata", &"*** Sensitive Data Redacted ***");
        formatter.field("iam_role_arn", &self.iam_role_arn);
        formatter.field("idempotency_token", &self.idempotency_token);
        formatter.field("resource_type", &self.resource_type);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StartCopyJobInput {
    /// <p>An ARN that uniquely identifies a recovery point to use for the copy job; for example,
    /// arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
    /// </p>
    pub recovery_point_arn: std::option::Option<std::string::String>,
    /// <p>The name of a logical source container where backups are stored. Backup vaults are
    /// identified by names that are unique to the account used to create them and the AWS Region
    /// where they are created. They consist of lowercase letters, numbers, and hyphens.</p>
    pub source_backup_vault_name: std::option::Option<std::string::String>,
    /// <p>An Amazon Resource Name (ARN) that uniquely identifies a destination backup vault to
    /// copy to; for example,
    /// <code>arn:aws:backup:us-east-1:123456789012:vault:aBackupVault</code>.</p>
    pub destination_backup_vault_arn: std::option::Option<std::string::String>,
    /// <p>Specifies the IAM role ARN used to copy the target recovery point; for example,
    /// <code>arn:aws:iam::123456789012:role/S3Access</code>.</p>
    pub iam_role_arn: std::option::Option<std::string::String>,
    /// <p>A customer chosen string that can be used to distinguish between calls to
    /// <code>StartCopyJob</code>.</p>
    pub idempotency_token: std::option::Option<std::string::String>,
    /// <p>Contains an array of <code>Transition</code> objects specifying how long in days before
    /// a recovery point transitions to cold storage or is deleted.</p>
    /// <p>Backups transitioned to cold storage must be stored in cold storage for a minimum of 90
    /// days. Therefore, on the console, the expire after days setting must be 90 days greater
    /// than the transition to cold after days setting. The transition to cold after days
    /// setting cannot be changed after a backup has been transitioned to cold.</p>
    /// <p>Only Amazon EFS file system backups can be transitioned to cold storage.</p>
    pub lifecycle: std::option::Option<crate::model::Lifecycle>,
}
impl std::fmt::Debug for StartCopyJobInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StartCopyJobInput");
        formatter.field("recovery_point_arn", &self.recovery_point_arn);
        formatter.field("source_backup_vault_name", &self.source_backup_vault_name);
        formatter.field(
            "destination_backup_vault_arn",
            &self.destination_backup_vault_arn,
        );
        formatter.field("iam_role_arn", &self.iam_role_arn);
        formatter.field("idempotency_token", &self.idempotency_token);
        formatter.field("lifecycle", &self.lifecycle);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StartBackupJobInput {
    /// <p>The name of a logical container where backups are stored. Backup vaults are identified
    /// by names that are unique to the account used to create them and the AWS Region where they
    /// are created. They consist of lowercase letters, numbers, and hyphens.</p>
    pub backup_vault_name: std::option::Option<std::string::String>,
    /// <p>An Amazon Resource Name (ARN) that uniquely identifies a resource. The format of the ARN
    /// depends on the resource type.</p>
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p>Specifies the IAM role ARN used to create the target recovery point; for example,
    /// <code>arn:aws:iam::123456789012:role/S3Access</code>.</p>
    pub iam_role_arn: std::option::Option<std::string::String>,
    /// <p>A customer chosen string that can be used to distinguish between calls to
    /// <code>StartBackupJob</code>.</p>
    pub idempotency_token: std::option::Option<std::string::String>,
    /// <p>A value in minutes after a backup is scheduled before a job will be canceled if it
    /// doesn't start successfully. This value is optional, and the default is 8 hours.</p>
    pub start_window_minutes: std::option::Option<i64>,
    /// <p>A value in minutes during which a successfully started backup must complete, or else AWS
    /// Backup will cancel the job. This value is optional. This value begins counting down from
    /// when the backup was scheduled. It does not add additional time for
    /// <code>StartWindowMinutes</code>, or if the backup started later than scheduled.</p>
    pub complete_window_minutes: std::option::Option<i64>,
    /// <p>The lifecycle defines when a protected resource is transitioned to cold storage and when
    /// it expires. AWS Backup will transition and expire backups automatically according to the
    /// lifecycle that you define. </p>
    /// <p>Backups transitioned to cold storage must be stored in cold storage for a minimum of 90
    /// days. Therefore, the expire after days setting must be 90 days greater than the
    /// transition to cold after days setting. The transition to cold after days setting cannot
    /// be changed after a backup has been transitioned to cold. </p>
    /// <p>Only Amazon EFS file system backups can be transitioned to cold storage.</p>
    pub lifecycle: std::option::Option<crate::model::Lifecycle>,
    /// <p>To help organize your resources, you can assign your own metadata to the resources that
    /// you create. Each tag is a key-value pair.</p>
    pub recovery_point_tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>Specifies the backup option for a selected resource. This option is only available for
    /// Windows VSS backup jobs.</p>
    /// <p>Valid values: Set to <code>"WindowsVSS:enabled"</code> to enable WindowsVSS backup
    /// option and create a VSS Windows backup. Set to WindowsVSS:disabled to create a regular
    /// backup. The WindowsVSS option is not enabled by default.</p>
    pub backup_options:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl std::fmt::Debug for StartBackupJobInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StartBackupJobInput");
        formatter.field("backup_vault_name", &self.backup_vault_name);
        formatter.field("resource_arn", &self.resource_arn);
        formatter.field("iam_role_arn", &self.iam_role_arn);
        formatter.field("idempotency_token", &self.idempotency_token);
        formatter.field("start_window_minutes", &self.start_window_minutes);
        formatter.field("complete_window_minutes", &self.complete_window_minutes);
        formatter.field("lifecycle", &self.lifecycle);
        formatter.field("recovery_point_tags", &"*** Sensitive Data Redacted ***");
        formatter.field("backup_options", &self.backup_options);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutBackupVaultNotificationsInput {
    /// <p>The name of a logical container where backups are stored. Backup vaults are identified
    /// by names that are unique to the account used to create them and the AWS Region where they
    /// are created. They consist of lowercase letters, numbers, and hyphens.</p>
    pub backup_vault_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) that specifies the topic for a backup vaults events; for
    /// example, <code>arn:aws:sns:us-west-2:111122223333:MyVaultTopic</code>.</p>
    pub sns_topic_arn: std::option::Option<std::string::String>,
    /// <p>An array of events that indicate the status of jobs to back up resources to the backup
    /// vault.</p>
    pub backup_vault_events: std::option::Option<std::vec::Vec<crate::model::BackupVaultEvent>>,
}
impl std::fmt::Debug for PutBackupVaultNotificationsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutBackupVaultNotificationsInput");
        formatter.field("backup_vault_name", &self.backup_vault_name);
        formatter.field("sns_topic_arn", &self.sns_topic_arn);
        formatter.field("backup_vault_events", &self.backup_vault_events);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutBackupVaultAccessPolicyInput {
    /// <p>The name of a logical container where backups are stored. Backup vaults are identified
    /// by names that are unique to the account used to create them and the AWS Region where they
    /// are created. They consist of lowercase letters, numbers, and hyphens.</p>
    pub backup_vault_name: std::option::Option<std::string::String>,
    /// <p>The backup vault access policy document in JSON format.</p>
    pub policy: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PutBackupVaultAccessPolicyInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutBackupVaultAccessPolicyInput");
        formatter.field("backup_vault_name", &self.backup_vault_name);
        formatter.field("policy", &self.policy);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListTagsInput {
    /// <p>An Amazon Resource Name (ARN) that uniquely identifies a resource. The format of the ARN
    /// depends on the type of resource. Valid targets for <code>ListTags</code> are recovery
    /// points, backup plans, and backup vaults.</p>
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p>The next item following a partial list of returned items. For example, if a request is
    /// made to return <code>maxResults</code> number of items, <code>NextToken</code> allows you
    /// to return more items in your list starting at the location pointed to by the next
    /// token.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of items to be returned.</p>
    pub max_results: std::option::Option<i32>,
}
impl std::fmt::Debug for ListTagsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListTagsInput");
        formatter.field("resource_arn", &self.resource_arn);
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListRestoreJobsInput {
    /// <p>The next item following a partial list of returned items. For example, if a request is
    /// made to return <code>maxResults</code> number of items, <code>NextToken</code> allows you
    /// to return more items in your list starting at the location pointed to by the next
    /// token.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of items to be returned.</p>
    pub max_results: std::option::Option<i32>,
    /// <p>The account ID to list the jobs from. Returns only restore jobs associated with the
    /// specified account ID.</p>
    pub by_account_id: std::option::Option<std::string::String>,
    /// <p>Returns only restore jobs that were created before the specified date.</p>
    pub by_created_before: std::option::Option<smithy_types::Instant>,
    /// <p>Returns only restore jobs that were created after the specified date.</p>
    pub by_created_after: std::option::Option<smithy_types::Instant>,
    /// <p>Returns only restore jobs associated with the specified job status.</p>
    pub by_status: std::option::Option<crate::model::RestoreJobStatus>,
}
impl std::fmt::Debug for ListRestoreJobsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListRestoreJobsInput");
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.field("by_account_id", &self.by_account_id);
        formatter.field("by_created_before", &self.by_created_before);
        formatter.field("by_created_after", &self.by_created_after);
        formatter.field("by_status", &self.by_status);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListRecoveryPointsByResourceInput {
    /// <p>An ARN that uniquely identifies a resource. The format of the ARN depends on the
    /// resource type.</p>
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p>The next item following a partial list of returned items. For example, if a request is
    /// made to return <code>maxResults</code> number of items, <code>NextToken</code> allows you
    /// to return more items in your list starting at the location pointed to by the next
    /// token.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of items to be returned.</p>
    pub max_results: std::option::Option<i32>,
}
impl std::fmt::Debug for ListRecoveryPointsByResourceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListRecoveryPointsByResourceInput");
        formatter.field("resource_arn", &self.resource_arn);
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListRecoveryPointsByBackupVaultInput {
    /// <p>The name of a logical container where backups are stored. Backup vaults are identified
    /// by names that are unique to the account used to create them and the AWS Region where they
    /// are created. They consist of lowercase letters, numbers, and hyphens.</p>
    pub backup_vault_name: std::option::Option<std::string::String>,
    /// <p>The next item following a partial list of returned items. For example, if a request is
    /// made to return <code>maxResults</code> number of items, <code>NextToken</code> allows you
    /// to return more items in your list starting at the location pointed to by the next
    /// token.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of items to be returned.</p>
    pub max_results: std::option::Option<i32>,
    /// <p>Returns only recovery points that match the specified resource Amazon Resource Name
    /// (ARN).</p>
    pub by_resource_arn: std::option::Option<std::string::String>,
    /// <p>Returns only recovery points that match the specified resource type.</p>
    pub by_resource_type: std::option::Option<std::string::String>,
    /// <p>Returns only recovery points that match the specified backup plan ID.</p>
    pub by_backup_plan_id: std::option::Option<std::string::String>,
    /// <p>Returns only recovery points that were created before the specified timestamp.</p>
    pub by_created_before: std::option::Option<smithy_types::Instant>,
    /// <p>Returns only recovery points that were created after the specified timestamp.</p>
    pub by_created_after: std::option::Option<smithy_types::Instant>,
}
impl std::fmt::Debug for ListRecoveryPointsByBackupVaultInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListRecoveryPointsByBackupVaultInput");
        formatter.field("backup_vault_name", &self.backup_vault_name);
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.field("by_resource_arn", &self.by_resource_arn);
        formatter.field("by_resource_type", &self.by_resource_type);
        formatter.field("by_backup_plan_id", &self.by_backup_plan_id);
        formatter.field("by_created_before", &self.by_created_before);
        formatter.field("by_created_after", &self.by_created_after);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListProtectedResourcesInput {
    /// <p>The next item following a partial list of returned items. For example, if a request is
    /// made to return <code>maxResults</code> number of items, <code>NextToken</code> allows you
    /// to return more items in your list starting at the location pointed to by the next
    /// token.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of items to be returned.</p>
    pub max_results: std::option::Option<i32>,
}
impl std::fmt::Debug for ListProtectedResourcesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListProtectedResourcesInput");
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListCopyJobsInput {
    /// <p>The next item following a partial list of returned items. For example, if a request is
    /// made to return maxResults number of items, NextToken allows you to return more items in
    /// your list starting at the location pointed to by the next token. </p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of items to be returned.</p>
    pub max_results: std::option::Option<i32>,
    /// <p>Returns only copy jobs that match the specified resource Amazon Resource Name (ARN).
    /// </p>
    pub by_resource_arn: std::option::Option<std::string::String>,
    /// <p>Returns only copy jobs that are in the specified state.</p>
    pub by_state: std::option::Option<crate::model::CopyJobState>,
    /// <p>Returns only copy jobs that were created before the specified date.</p>
    pub by_created_before: std::option::Option<smithy_types::Instant>,
    /// <p>Returns only copy jobs that were created after the specified date.</p>
    pub by_created_after: std::option::Option<smithy_types::Instant>,
    /// <p>Returns only backup jobs for the specified resources:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>DynamoDB</code> for Amazon DynamoDB</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>EBS</code> for Amazon Elastic Block Store</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>EC2</code> for Amazon Elastic Compute Cloud</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>EFS</code> for Amazon Elastic File System</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>RDS</code> for Amazon Relational Database Service</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Aurora</code> for Amazon Aurora</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Storage Gateway</code> for AWS Storage Gateway</p>
    /// </li>
    /// </ul>
    pub by_resource_type: std::option::Option<std::string::String>,
    /// <p>An Amazon Resource Name (ARN) that uniquely identifies a source backup vault to copy
    /// from; for example, <code>arn:aws:backup:us-east-1:123456789012:vault:aBackupVault</code>.
    /// </p>
    pub by_destination_vault_arn: std::option::Option<std::string::String>,
    /// <p>The account ID to list the jobs from. Returns only copy jobs associated with the
    /// specified account ID.</p>
    pub by_account_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListCopyJobsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListCopyJobsInput");
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.field("by_resource_arn", &self.by_resource_arn);
        formatter.field("by_state", &self.by_state);
        formatter.field("by_created_before", &self.by_created_before);
        formatter.field("by_created_after", &self.by_created_after);
        formatter.field("by_resource_type", &self.by_resource_type);
        formatter.field("by_destination_vault_arn", &self.by_destination_vault_arn);
        formatter.field("by_account_id", &self.by_account_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListBackupVaultsInput {
    /// <p>The next item following a partial list of returned items. For example, if a request is
    /// made to return <code>maxResults</code> number of items, <code>NextToken</code> allows you
    /// to return more items in your list starting at the location pointed to by the next
    /// token.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of items to be returned.</p>
    pub max_results: std::option::Option<i32>,
}
impl std::fmt::Debug for ListBackupVaultsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListBackupVaultsInput");
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListBackupSelectionsInput {
    /// <p>Uniquely identifies a backup plan.</p>
    pub backup_plan_id: std::option::Option<std::string::String>,
    /// <p>The next item following a partial list of returned items. For example, if a request is
    /// made to return <code>maxResults</code> number of items, <code>NextToken</code> allows you
    /// to return more items in your list starting at the location pointed to by the next
    /// token.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of items to be returned.</p>
    pub max_results: std::option::Option<i32>,
}
impl std::fmt::Debug for ListBackupSelectionsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListBackupSelectionsInput");
        formatter.field("backup_plan_id", &self.backup_plan_id);
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListBackupPlanVersionsInput {
    /// <p>Uniquely identifies a backup plan.</p>
    pub backup_plan_id: std::option::Option<std::string::String>,
    /// <p>The next item following a partial list of returned items. For example, if a request is
    /// made to return <code>maxResults</code> number of items, <code>NextToken</code> allows you
    /// to return more items in your list starting at the location pointed to by the next
    /// token.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of items to be returned.</p>
    pub max_results: std::option::Option<i32>,
}
impl std::fmt::Debug for ListBackupPlanVersionsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListBackupPlanVersionsInput");
        formatter.field("backup_plan_id", &self.backup_plan_id);
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListBackupPlanTemplatesInput {
    /// <p>The next item following a partial list of returned items. For example, if a request is
    /// made to return <code>maxResults</code> number of items, <code>NextToken</code> allows you
    /// to return more items in your list starting at the location pointed to by the next
    /// token.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of items to be returned.</p>
    pub max_results: std::option::Option<i32>,
}
impl std::fmt::Debug for ListBackupPlanTemplatesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListBackupPlanTemplatesInput");
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListBackupPlansInput {
    /// <p>The next item following a partial list of returned items. For example, if a request is
    /// made to return <code>maxResults</code> number of items, <code>NextToken</code> allows you
    /// to return more items in your list starting at the location pointed to by the next
    /// token.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of items to be returned.</p>
    pub max_results: std::option::Option<i32>,
    /// <p>A Boolean value with a default value of <code>FALSE</code> that returns deleted backup
    /// plans when set to <code>TRUE</code>.</p>
    pub include_deleted: std::option::Option<bool>,
}
impl std::fmt::Debug for ListBackupPlansInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListBackupPlansInput");
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.field("include_deleted", &self.include_deleted);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListBackupJobsInput {
    /// <p>The next item following a partial list of returned items. For example, if a request is
    /// made to return <code>maxResults</code> number of items, <code>NextToken</code> allows you
    /// to return more items in your list starting at the location pointed to by the next
    /// token.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of items to be returned.</p>
    pub max_results: std::option::Option<i32>,
    /// <p>Returns only backup jobs that match the specified resource Amazon Resource Name
    /// (ARN).</p>
    pub by_resource_arn: std::option::Option<std::string::String>,
    /// <p>Returns only backup jobs that are in the specified state.</p>
    pub by_state: std::option::Option<crate::model::BackupJobState>,
    /// <p>Returns only backup jobs that will be stored in the specified backup vault. Backup
    /// vaults are identified by names that are unique to the account used to create them and the
    /// AWS Region where they are created. They consist of lowercase letters, numbers, and
    /// hyphens.</p>
    pub by_backup_vault_name: std::option::Option<std::string::String>,
    /// <p>Returns only backup jobs that were created before the specified date.</p>
    pub by_created_before: std::option::Option<smithy_types::Instant>,
    /// <p>Returns only backup jobs that were created after the specified date.</p>
    pub by_created_after: std::option::Option<smithy_types::Instant>,
    /// <p>Returns only backup jobs for the specified resources:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>DynamoDB</code> for Amazon DynamoDB</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>EBS</code> for Amazon Elastic Block Store</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>EC2</code> for Amazon Elastic Compute Cloud</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>EFS</code> for Amazon Elastic File System</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>RDS</code> for Amazon Relational Database Service</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Aurora</code> for Amazon Aurora</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Storage Gateway</code> for AWS Storage Gateway</p>
    /// </li>
    /// </ul>
    pub by_resource_type: std::option::Option<std::string::String>,
    /// <p>The account ID to list the jobs from. Returns only backup jobs associated with the
    /// specified account ID.</p>
    /// <p>If used from an AWS Organizations management account, passing <code>*</code> returns all
    /// jobs across the organization.</p>
    pub by_account_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListBackupJobsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListBackupJobsInput");
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.field("by_resource_arn", &self.by_resource_arn);
        formatter.field("by_state", &self.by_state);
        formatter.field("by_backup_vault_name", &self.by_backup_vault_name);
        formatter.field("by_created_before", &self.by_created_before);
        formatter.field("by_created_after", &self.by_created_after);
        formatter.field("by_resource_type", &self.by_resource_type);
        formatter.field("by_account_id", &self.by_account_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetSupportedResourceTypesInput {}
impl std::fmt::Debug for GetSupportedResourceTypesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetSupportedResourceTypesInput");
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetRecoveryPointRestoreMetadataInput {
    /// <p>The name of a logical container where backups are stored. Backup vaults are identified
    /// by names that are unique to the account used to create them and the AWS Region where they
    /// are created. They consist of lowercase letters, numbers, and hyphens.</p>
    pub backup_vault_name: std::option::Option<std::string::String>,
    /// <p>An Amazon Resource Name (ARN) that uniquely identifies a recovery point; for example,
    /// <code>arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45</code>.</p>
    pub recovery_point_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetRecoveryPointRestoreMetadataInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetRecoveryPointRestoreMetadataInput");
        formatter.field("backup_vault_name", &self.backup_vault_name);
        formatter.field("recovery_point_arn", &self.recovery_point_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetBackupVaultNotificationsInput {
    /// <p>The name of a logical container where backups are stored. Backup vaults are identified
    /// by names that are unique to the account used to create them and the AWS Region where they
    /// are created. They consist of lowercase letters, numbers, and hyphens.</p>
    pub backup_vault_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetBackupVaultNotificationsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetBackupVaultNotificationsInput");
        formatter.field("backup_vault_name", &self.backup_vault_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetBackupVaultAccessPolicyInput {
    /// <p>The name of a logical container where backups are stored. Backup vaults are identified
    /// by names that are unique to the account used to create them and the AWS Region where they
    /// are created. They consist of lowercase letters, numbers, and hyphens.</p>
    pub backup_vault_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetBackupVaultAccessPolicyInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetBackupVaultAccessPolicyInput");
        formatter.field("backup_vault_name", &self.backup_vault_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetBackupSelectionInput {
    /// <p>Uniquely identifies a backup plan.</p>
    pub backup_plan_id: std::option::Option<std::string::String>,
    /// <p>Uniquely identifies the body of a request to assign a set of resources to a backup
    /// plan.</p>
    pub selection_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetBackupSelectionInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetBackupSelectionInput");
        formatter.field("backup_plan_id", &self.backup_plan_id);
        formatter.field("selection_id", &self.selection_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetBackupPlanFromTemplateInput {
    /// <p>Uniquely identifies a stored backup plan template.</p>
    pub backup_plan_template_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetBackupPlanFromTemplateInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetBackupPlanFromTemplateInput");
        formatter.field("backup_plan_template_id", &self.backup_plan_template_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetBackupPlanFromJsonInput {
    /// <p>A customer-supplied backup plan document in JSON format.</p>
    pub backup_plan_template_json: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetBackupPlanFromJsonInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetBackupPlanFromJsonInput");
        formatter.field("backup_plan_template_json", &self.backup_plan_template_json);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetBackupPlanInput {
    /// <p>Uniquely identifies a backup plan.</p>
    pub backup_plan_id: std::option::Option<std::string::String>,
    /// <p>Unique, randomly generated, Unicode, UTF-8 encoded strings that are at most 1,024 bytes
    /// long. Version IDs cannot be edited.</p>
    pub version_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetBackupPlanInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetBackupPlanInput");
        formatter.field("backup_plan_id", &self.backup_plan_id);
        formatter.field("version_id", &self.version_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ExportBackupPlanTemplateInput {
    /// <p>Uniquely identifies a backup plan.</p>
    pub backup_plan_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ExportBackupPlanTemplateInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ExportBackupPlanTemplateInput");
        formatter.field("backup_plan_id", &self.backup_plan_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DisassociateRecoveryPointInput {
    /// <p>The unique name of an AWS Backup vault. Required.</p>
    pub backup_vault_name: std::option::Option<std::string::String>,
    /// <p>An Amazon Resource Name (ARN) that uniquely identifies an AWS Backup recovery point.
    /// Required.</p>
    pub recovery_point_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DisassociateRecoveryPointInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DisassociateRecoveryPointInput");
        formatter.field("backup_vault_name", &self.backup_vault_name);
        formatter.field("recovery_point_arn", &self.recovery_point_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeRestoreJobInput {
    /// <p>Uniquely identifies the job that restores a recovery point.</p>
    pub restore_job_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DescribeRestoreJobInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeRestoreJobInput");
        formatter.field("restore_job_id", &self.restore_job_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeRegionSettingsInput {}
impl std::fmt::Debug for DescribeRegionSettingsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeRegionSettingsInput");
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeRecoveryPointInput {
    /// <p>The name of a logical container where backups are stored. Backup vaults are identified
    /// by names that are unique to the account used to create them and the AWS Region where they
    /// are created. They consist of lowercase letters, numbers, and hyphens.</p>
    pub backup_vault_name: std::option::Option<std::string::String>,
    /// <p>An Amazon Resource Name (ARN) that uniquely identifies a recovery point; for example,
    /// <code>arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45</code>.</p>
    pub recovery_point_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DescribeRecoveryPointInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeRecoveryPointInput");
        formatter.field("backup_vault_name", &self.backup_vault_name);
        formatter.field("recovery_point_arn", &self.recovery_point_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeProtectedResourceInput {
    /// <p>An Amazon Resource Name (ARN) that uniquely identifies a resource. The format of the ARN
    /// depends on the resource type.</p>
    pub resource_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DescribeProtectedResourceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeProtectedResourceInput");
        formatter.field("resource_arn", &self.resource_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeGlobalSettingsInput {}
impl std::fmt::Debug for DescribeGlobalSettingsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeGlobalSettingsInput");
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeCopyJobInput {
    /// <p>Uniquely identifies a copy job.</p>
    pub copy_job_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DescribeCopyJobInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeCopyJobInput");
        formatter.field("copy_job_id", &self.copy_job_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeBackupVaultInput {
    /// <p>The name of a logical container where backups are stored. Backup vaults are identified
    /// by names that are unique to the account used to create them and the AWS Region where they
    /// are created. They consist of lowercase letters, numbers, and hyphens.</p>
    pub backup_vault_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DescribeBackupVaultInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeBackupVaultInput");
        formatter.field("backup_vault_name", &self.backup_vault_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeBackupJobInput {
    /// <p>Uniquely identifies a request to AWS Backup to back up a resource.</p>
    pub backup_job_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DescribeBackupJobInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeBackupJobInput");
        formatter.field("backup_job_id", &self.backup_job_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteRecoveryPointInput {
    /// <p>The name of a logical container where backups are stored. Backup vaults are identified
    /// by names that are unique to the account used to create them and the AWS Region where they
    /// are created. They consist of lowercase letters, numbers, and hyphens.</p>
    pub backup_vault_name: std::option::Option<std::string::String>,
    /// <p>An Amazon Resource Name (ARN) that uniquely identifies a recovery point; for example,
    /// <code>arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45</code>.</p>
    pub recovery_point_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteRecoveryPointInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteRecoveryPointInput");
        formatter.field("backup_vault_name", &self.backup_vault_name);
        formatter.field("recovery_point_arn", &self.recovery_point_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteBackupVaultNotificationsInput {
    /// <p>The name of a logical container where backups are stored. Backup vaults are identified
    /// by names that are unique to the account used to create them and the Region where they are
    /// created. They consist of lowercase letters, numbers, and hyphens.</p>
    pub backup_vault_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteBackupVaultNotificationsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteBackupVaultNotificationsInput");
        formatter.field("backup_vault_name", &self.backup_vault_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteBackupVaultAccessPolicyInput {
    /// <p>The name of a logical container where backups are stored. Backup vaults are identified
    /// by names that are unique to the account used to create them and the AWS Region where they
    /// are created. They consist of lowercase letters, numbers, and hyphens.</p>
    pub backup_vault_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteBackupVaultAccessPolicyInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteBackupVaultAccessPolicyInput");
        formatter.field("backup_vault_name", &self.backup_vault_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteBackupVaultInput {
    /// <p>The name of a logical container where backups are stored. Backup vaults are identified
    /// by names that are unique to the account used to create them and the AWS Region where they
    /// are created. They consist of lowercase letters, numbers, and hyphens.</p>
    pub backup_vault_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteBackupVaultInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteBackupVaultInput");
        formatter.field("backup_vault_name", &self.backup_vault_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteBackupSelectionInput {
    /// <p>Uniquely identifies a backup plan.</p>
    pub backup_plan_id: std::option::Option<std::string::String>,
    /// <p>Uniquely identifies the body of a request to assign a set of resources to a backup
    /// plan.</p>
    pub selection_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteBackupSelectionInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteBackupSelectionInput");
        formatter.field("backup_plan_id", &self.backup_plan_id);
        formatter.field("selection_id", &self.selection_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteBackupPlanInput {
    /// <p>Uniquely identifies a backup plan.</p>
    pub backup_plan_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteBackupPlanInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteBackupPlanInput");
        formatter.field("backup_plan_id", &self.backup_plan_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateBackupVaultInput {
    /// <p>The name of a logical container where backups are stored. Backup vaults are identified
    /// by names that are unique to the account used to create them and the AWS Region where they
    /// are created. They consist of letters, numbers, and hyphens.</p>
    pub backup_vault_name: std::option::Option<std::string::String>,
    /// <p>Metadata that you can assign to help organize the resources that you create. Each tag is
    /// a key-value pair.</p>
    pub backup_vault_tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The server-side encryption key that is used to protect your backups; for example,
    /// <code>arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>.</p>
    pub encryption_key_arn: std::option::Option<std::string::String>,
    /// <p>A unique string that identifies the request and allows failed requests to be retried
    /// without the risk of running the operation twice.</p>
    pub creator_request_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CreateBackupVaultInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateBackupVaultInput");
        formatter.field("backup_vault_name", &self.backup_vault_name);
        formatter.field("backup_vault_tags", &"*** Sensitive Data Redacted ***");
        formatter.field("encryption_key_arn", &self.encryption_key_arn);
        formatter.field("creator_request_id", &self.creator_request_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateBackupSelectionInput {
    /// <p>Uniquely identifies the backup plan to be associated with the selection of
    /// resources.</p>
    pub backup_plan_id: std::option::Option<std::string::String>,
    /// <p>Specifies the body of a request to assign a set of resources to a backup plan.</p>
    pub backup_selection: std::option::Option<crate::model::BackupSelection>,
    /// <p>A unique string that identifies the request and allows failed requests to be retried
    /// without the risk of running the operation twice.</p>
    pub creator_request_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CreateBackupSelectionInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateBackupSelectionInput");
        formatter.field("backup_plan_id", &self.backup_plan_id);
        formatter.field("backup_selection", &self.backup_selection);
        formatter.field("creator_request_id", &self.creator_request_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateBackupPlanInput {
    /// <p>Specifies the body of a backup plan. Includes a <code>BackupPlanName</code> and one or
    /// more sets of <code>Rules</code>.</p>
    pub backup_plan: std::option::Option<crate::model::BackupPlanInput>,
    /// <p>To help organize your resources, you can assign your own metadata to the resources that
    /// you create. Each tag is a key-value pair. The specified tags are assigned to all backups
    /// created with this plan.</p>
    pub backup_plan_tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>Identifies the request and allows failed requests to be retried without the risk of
    /// running the operation twice. If the request includes a <code>CreatorRequestId</code> that
    /// matches an existing backup plan, that plan is returned. This parameter is optional.</p>
    pub creator_request_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CreateBackupPlanInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateBackupPlanInput");
        formatter.field("backup_plan", &self.backup_plan);
        formatter.field("backup_plan_tags", &"*** Sensitive Data Redacted ***");
        formatter.field("creator_request_id", &self.creator_request_id);
        formatter.finish()
    }
}
