// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateUserOutput {}
impl std::fmt::Debug for UpdateUserOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateUserOutput");
        formatter.finish()
    }
}
/// See [`UpdateUserOutput`](crate::output::UpdateUserOutput)
pub mod update_user_output {
    /// A builder for [`UpdateUserOutput`](crate::output::UpdateUserOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`UpdateUserOutput`](crate::output::UpdateUserOutput)
        pub fn build(self) -> crate::output::UpdateUserOutput {
            crate::output::UpdateUserOutput {}
        }
    }
}
impl UpdateUserOutput {
    /// Creates a new builder-style object to manufacture [`UpdateUserOutput`](crate::output::UpdateUserOutput)
    pub fn builder() -> crate::output::update_user_output::Builder {
        crate::output::update_user_output::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateConfigurationOutput {
    /// Required. The Amazon Resource Name (ARN) of the configuration.
    pub arn: std::option::Option<std::string::String>,
    /// Required. The date and time of the configuration.
    pub created: std::option::Option<smithy_types::Instant>,
    /// Required. The unique ID that Amazon MQ generates for the configuration.
    pub id: std::option::Option<std::string::String>,
    /// The latest revision of the configuration.
    pub latest_revision: std::option::Option<crate::model::ConfigurationRevision>,
    /// Required. The name of the configuration. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 1-150 characters long.
    pub name: std::option::Option<std::string::String>,
    /// The list of the first 20 warnings about the configuration XML elements or attributes that were sanitized.
    pub warnings: std::option::Option<std::vec::Vec<crate::model::SanitizationWarning>>,
}
impl std::fmt::Debug for UpdateConfigurationOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateConfigurationOutput");
        formatter.field("arn", &self.arn);
        formatter.field("created", &self.created);
        formatter.field("id", &self.id);
        formatter.field("latest_revision", &self.latest_revision);
        formatter.field("name", &self.name);
        formatter.field("warnings", &self.warnings);
        formatter.finish()
    }
}
/// See [`UpdateConfigurationOutput`](crate::output::UpdateConfigurationOutput)
pub mod update_configuration_output {
    /// A builder for [`UpdateConfigurationOutput`](crate::output::UpdateConfigurationOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) created: std::option::Option<smithy_types::Instant>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) latest_revision: std::option::Option<crate::model::ConfigurationRevision>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) warnings: std::option::Option<std::vec::Vec<crate::model::SanitizationWarning>>,
    }
    impl Builder {
        /// Required. The Amazon Resource Name (ARN) of the configuration.
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// Required. The date and time of the configuration.
        pub fn created(mut self, input: smithy_types::Instant) -> Self {
            self.created = Some(input);
            self
        }
        pub fn set_created(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.created = input;
            self
        }
        /// Required. The unique ID that Amazon MQ generates for the configuration.
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// The latest revision of the configuration.
        pub fn latest_revision(mut self, input: crate::model::ConfigurationRevision) -> Self {
            self.latest_revision = Some(input);
            self
        }
        pub fn set_latest_revision(
            mut self,
            input: std::option::Option<crate::model::ConfigurationRevision>,
        ) -> Self {
            self.latest_revision = input;
            self
        }
        /// Required. The name of the configuration. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 1-150 characters long.
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        pub fn warnings(mut self, input: impl Into<crate::model::SanitizationWarning>) -> Self {
            let mut v = self.warnings.unwrap_or_default();
            v.push(input.into());
            self.warnings = Some(v);
            self
        }
        pub fn set_warnings(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SanitizationWarning>>,
        ) -> Self {
            self.warnings = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateConfigurationOutput`](crate::output::UpdateConfigurationOutput)
        pub fn build(self) -> crate::output::UpdateConfigurationOutput {
            crate::output::UpdateConfigurationOutput {
                arn: self.arn,
                created: self.created,
                id: self.id,
                latest_revision: self.latest_revision,
                name: self.name,
                warnings: self.warnings,
            }
        }
    }
}
impl UpdateConfigurationOutput {
    /// Creates a new builder-style object to manufacture [`UpdateConfigurationOutput`](crate::output::UpdateConfigurationOutput)
    pub fn builder() -> crate::output::update_configuration_output::Builder {
        crate::output::update_configuration_output::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateBrokerOutput {
    /// The authentication strategy used to secure the broker.
    pub authentication_strategy: std::option::Option<crate::model::AuthenticationStrategy>,
    /// The new value of automatic upgrades to new minor version for brokers.
    pub auto_minor_version_upgrade: bool,
    /// Required. The unique ID that Amazon MQ generates for the broker.
    pub broker_id: std::option::Option<std::string::String>,
    /// The ID of the updated configuration.
    pub configuration: std::option::Option<crate::model::ConfigurationId>,
    /// The version of the broker engine to upgrade to. For a list of supported engine versions, see https://docs.aws.amazon.com/amazon-mq/latest/developer-guide/broker-engine.html
    pub engine_version: std::option::Option<std::string::String>,
    /// The host instance type of the broker to upgrade to. For a list of supported instance types, see https://docs.aws.amazon.com/amazon-mq/latest/developer-guide//broker.html#broker-instance-types
    pub host_instance_type: std::option::Option<std::string::String>,
    /// The metadata of the LDAP server used to authenticate and authorize connections to the broker.
    pub ldap_server_metadata: std::option::Option<crate::model::LdapServerMetadataOutput>,
    /// The list of information about logs to be enabled for the specified broker.
    pub logs: std::option::Option<crate::model::Logs>,
    /// The list of security groups (1 minimum, 5 maximum) that authorizes connections to brokers.
    pub security_groups: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for UpdateBrokerOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateBrokerOutput");
        formatter.field("authentication_strategy", &self.authentication_strategy);
        formatter.field(
            "auto_minor_version_upgrade",
            &self.auto_minor_version_upgrade,
        );
        formatter.field("broker_id", &self.broker_id);
        formatter.field("configuration", &self.configuration);
        formatter.field("engine_version", &self.engine_version);
        formatter.field("host_instance_type", &self.host_instance_type);
        formatter.field("ldap_server_metadata", &self.ldap_server_metadata);
        formatter.field("logs", &self.logs);
        formatter.field("security_groups", &self.security_groups);
        formatter.finish()
    }
}
/// See [`UpdateBrokerOutput`](crate::output::UpdateBrokerOutput)
pub mod update_broker_output {
    /// A builder for [`UpdateBrokerOutput`](crate::output::UpdateBrokerOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) authentication_strategy:
            std::option::Option<crate::model::AuthenticationStrategy>,
        pub(crate) auto_minor_version_upgrade: std::option::Option<bool>,
        pub(crate) broker_id: std::option::Option<std::string::String>,
        pub(crate) configuration: std::option::Option<crate::model::ConfigurationId>,
        pub(crate) engine_version: std::option::Option<std::string::String>,
        pub(crate) host_instance_type: std::option::Option<std::string::String>,
        pub(crate) ldap_server_metadata:
            std::option::Option<crate::model::LdapServerMetadataOutput>,
        pub(crate) logs: std::option::Option<crate::model::Logs>,
        pub(crate) security_groups: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// The authentication strategy used to secure the broker.
        pub fn authentication_strategy(
            mut self,
            input: crate::model::AuthenticationStrategy,
        ) -> Self {
            self.authentication_strategy = Some(input);
            self
        }
        pub fn set_authentication_strategy(
            mut self,
            input: std::option::Option<crate::model::AuthenticationStrategy>,
        ) -> Self {
            self.authentication_strategy = input;
            self
        }
        /// The new value of automatic upgrades to new minor version for brokers.
        pub fn auto_minor_version_upgrade(mut self, input: bool) -> Self {
            self.auto_minor_version_upgrade = Some(input);
            self
        }
        pub fn set_auto_minor_version_upgrade(mut self, input: std::option::Option<bool>) -> Self {
            self.auto_minor_version_upgrade = input;
            self
        }
        /// Required. The unique ID that Amazon MQ generates for the broker.
        pub fn broker_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.broker_id = Some(input.into());
            self
        }
        pub fn set_broker_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.broker_id = input;
            self
        }
        /// The ID of the updated configuration.
        pub fn configuration(mut self, input: crate::model::ConfigurationId) -> Self {
            self.configuration = Some(input);
            self
        }
        pub fn set_configuration(
            mut self,
            input: std::option::Option<crate::model::ConfigurationId>,
        ) -> Self {
            self.configuration = input;
            self
        }
        /// The version of the broker engine to upgrade to. For a list of supported engine versions, see https://docs.aws.amazon.com/amazon-mq/latest/developer-guide/broker-engine.html
        pub fn engine_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.engine_version = Some(input.into());
            self
        }
        pub fn set_engine_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.engine_version = input;
            self
        }
        /// The host instance type of the broker to upgrade to. For a list of supported instance types, see https://docs.aws.amazon.com/amazon-mq/latest/developer-guide//broker.html#broker-instance-types
        pub fn host_instance_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.host_instance_type = Some(input.into());
            self
        }
        pub fn set_host_instance_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.host_instance_type = input;
            self
        }
        /// The metadata of the LDAP server used to authenticate and authorize connections to the broker.
        pub fn ldap_server_metadata(
            mut self,
            input: crate::model::LdapServerMetadataOutput,
        ) -> Self {
            self.ldap_server_metadata = Some(input);
            self
        }
        pub fn set_ldap_server_metadata(
            mut self,
            input: std::option::Option<crate::model::LdapServerMetadataOutput>,
        ) -> Self {
            self.ldap_server_metadata = input;
            self
        }
        /// The list of information about logs to be enabled for the specified broker.
        pub fn logs(mut self, input: crate::model::Logs) -> Self {
            self.logs = Some(input);
            self
        }
        pub fn set_logs(mut self, input: std::option::Option<crate::model::Logs>) -> Self {
            self.logs = input;
            self
        }
        pub fn security_groups(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.security_groups.unwrap_or_default();
            v.push(input.into());
            self.security_groups = Some(v);
            self
        }
        pub fn set_security_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.security_groups = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateBrokerOutput`](crate::output::UpdateBrokerOutput)
        pub fn build(self) -> crate::output::UpdateBrokerOutput {
            crate::output::UpdateBrokerOutput {
                authentication_strategy: self.authentication_strategy,
                auto_minor_version_upgrade: self.auto_minor_version_upgrade.unwrap_or_default(),
                broker_id: self.broker_id,
                configuration: self.configuration,
                engine_version: self.engine_version,
                host_instance_type: self.host_instance_type,
                ldap_server_metadata: self.ldap_server_metadata,
                logs: self.logs,
                security_groups: self.security_groups,
            }
        }
    }
}
impl UpdateBrokerOutput {
    /// Creates a new builder-style object to manufacture [`UpdateBrokerOutput`](crate::output::UpdateBrokerOutput)
    pub fn builder() -> crate::output::update_broker_output::Builder {
        crate::output::update_broker_output::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RebootBrokerOutput {}
impl std::fmt::Debug for RebootBrokerOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RebootBrokerOutput");
        formatter.finish()
    }
}
/// See [`RebootBrokerOutput`](crate::output::RebootBrokerOutput)
pub mod reboot_broker_output {
    /// A builder for [`RebootBrokerOutput`](crate::output::RebootBrokerOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`RebootBrokerOutput`](crate::output::RebootBrokerOutput)
        pub fn build(self) -> crate::output::RebootBrokerOutput {
            crate::output::RebootBrokerOutput {}
        }
    }
}
impl RebootBrokerOutput {
    /// Creates a new builder-style object to manufacture [`RebootBrokerOutput`](crate::output::RebootBrokerOutput)
    pub fn builder() -> crate::output::reboot_broker_output::Builder {
        crate::output::reboot_broker_output::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListUsersOutput {
    /// Required. The unique ID that Amazon MQ generates for the broker.
    pub broker_id: std::option::Option<std::string::String>,
    /// Required. The maximum number of ActiveMQ users that can be returned per page (20 by default). This value must be an integer from 5 to 100.
    pub max_results: i32,
    /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
    pub next_token: std::option::Option<std::string::String>,
    /// Required. The list of all ActiveMQ usernames for the specified broker.
    pub users: std::option::Option<std::vec::Vec<crate::model::UserSummary>>,
}
impl std::fmt::Debug for ListUsersOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListUsersOutput");
        formatter.field("broker_id", &self.broker_id);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.field("users", &self.users);
        formatter.finish()
    }
}
/// See [`ListUsersOutput`](crate::output::ListUsersOutput)
pub mod list_users_output {
    /// A builder for [`ListUsersOutput`](crate::output::ListUsersOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) broker_id: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) users: std::option::Option<std::vec::Vec<crate::model::UserSummary>>,
    }
    impl Builder {
        /// Required. The unique ID that Amazon MQ generates for the broker.
        pub fn broker_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.broker_id = Some(input.into());
            self
        }
        pub fn set_broker_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.broker_id = input;
            self
        }
        /// Required. The maximum number of ActiveMQ users that can be returned per page (20 by default). This value must be an integer from 5 to 100.
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        pub fn users(mut self, input: impl Into<crate::model::UserSummary>) -> Self {
            let mut v = self.users.unwrap_or_default();
            v.push(input.into());
            self.users = Some(v);
            self
        }
        pub fn set_users(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::UserSummary>>,
        ) -> Self {
            self.users = input;
            self
        }
        /// Consumes the builder and constructs a [`ListUsersOutput`](crate::output::ListUsersOutput)
        pub fn build(self) -> crate::output::ListUsersOutput {
            crate::output::ListUsersOutput {
                broker_id: self.broker_id,
                max_results: self.max_results.unwrap_or_default(),
                next_token: self.next_token,
                users: self.users,
            }
        }
    }
}
impl ListUsersOutput {
    /// Creates a new builder-style object to manufacture [`ListUsersOutput`](crate::output::ListUsersOutput)
    pub fn builder() -> crate::output::list_users_output::Builder {
        crate::output::list_users_output::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListTagsOutput {
    /// The key-value pair for the resource tag.
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl std::fmt::Debug for ListTagsOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListTagsOutput");
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`ListTagsOutput`](crate::output::ListTagsOutput)
pub mod list_tags_output {
    /// A builder for [`ListTagsOutput`](crate::output::ListTagsOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`ListTagsOutput`](crate::output::ListTagsOutput)
        pub fn build(self) -> crate::output::ListTagsOutput {
            crate::output::ListTagsOutput { tags: self.tags }
        }
    }
}
impl ListTagsOutput {
    /// Creates a new builder-style object to manufacture [`ListTagsOutput`](crate::output::ListTagsOutput)
    pub fn builder() -> crate::output::list_tags_output::Builder {
        crate::output::list_tags_output::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListConfigurationsOutput {
    /// The list of all revisions for the specified configuration.
    pub configurations: std::option::Option<std::vec::Vec<crate::model::Configuration>>,
    /// The maximum number of configurations that Amazon MQ can return per page (20 by default). This value must be an integer from 5 to 100.
    pub max_results: i32,
    /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListConfigurationsOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListConfigurationsOutput");
        formatter.field("configurations", &self.configurations);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}
/// See [`ListConfigurationsOutput`](crate::output::ListConfigurationsOutput)
pub mod list_configurations_output {
    /// A builder for [`ListConfigurationsOutput`](crate::output::ListConfigurationsOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) configurations: std::option::Option<std::vec::Vec<crate::model::Configuration>>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn configurations(mut self, input: impl Into<crate::model::Configuration>) -> Self {
            let mut v = self.configurations.unwrap_or_default();
            v.push(input.into());
            self.configurations = Some(v);
            self
        }
        pub fn set_configurations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Configuration>>,
        ) -> Self {
            self.configurations = input;
            self
        }
        /// The maximum number of configurations that Amazon MQ can return per page (20 by default). This value must be an integer from 5 to 100.
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListConfigurationsOutput`](crate::output::ListConfigurationsOutput)
        pub fn build(self) -> crate::output::ListConfigurationsOutput {
            crate::output::ListConfigurationsOutput {
                configurations: self.configurations,
                max_results: self.max_results.unwrap_or_default(),
                next_token: self.next_token,
            }
        }
    }
}
impl ListConfigurationsOutput {
    /// Creates a new builder-style object to manufacture [`ListConfigurationsOutput`](crate::output::ListConfigurationsOutput)
    pub fn builder() -> crate::output::list_configurations_output::Builder {
        crate::output::list_configurations_output::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListConfigurationRevisionsOutput {
    /// The unique ID that Amazon MQ generates for the configuration.
    pub configuration_id: std::option::Option<std::string::String>,
    /// The maximum number of configuration revisions that can be returned per page (20 by default). This value must be an integer from 5 to 100.
    pub max_results: i32,
    /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
    pub next_token: std::option::Option<std::string::String>,
    /// The list of all revisions for the specified configuration.
    pub revisions: std::option::Option<std::vec::Vec<crate::model::ConfigurationRevision>>,
}
impl std::fmt::Debug for ListConfigurationRevisionsOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListConfigurationRevisionsOutput");
        formatter.field("configuration_id", &self.configuration_id);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.field("revisions", &self.revisions);
        formatter.finish()
    }
}
/// See [`ListConfigurationRevisionsOutput`](crate::output::ListConfigurationRevisionsOutput)
pub mod list_configuration_revisions_output {
    /// A builder for [`ListConfigurationRevisionsOutput`](crate::output::ListConfigurationRevisionsOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) configuration_id: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) revisions:
            std::option::Option<std::vec::Vec<crate::model::ConfigurationRevision>>,
    }
    impl Builder {
        /// The unique ID that Amazon MQ generates for the configuration.
        pub fn configuration_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.configuration_id = Some(input.into());
            self
        }
        pub fn set_configuration_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.configuration_id = input;
            self
        }
        /// The maximum number of configuration revisions that can be returned per page (20 by default). This value must be an integer from 5 to 100.
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        pub fn revisions(mut self, input: impl Into<crate::model::ConfigurationRevision>) -> Self {
            let mut v = self.revisions.unwrap_or_default();
            v.push(input.into());
            self.revisions = Some(v);
            self
        }
        pub fn set_revisions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ConfigurationRevision>>,
        ) -> Self {
            self.revisions = input;
            self
        }
        /// Consumes the builder and constructs a [`ListConfigurationRevisionsOutput`](crate::output::ListConfigurationRevisionsOutput)
        pub fn build(self) -> crate::output::ListConfigurationRevisionsOutput {
            crate::output::ListConfigurationRevisionsOutput {
                configuration_id: self.configuration_id,
                max_results: self.max_results.unwrap_or_default(),
                next_token: self.next_token,
                revisions: self.revisions,
            }
        }
    }
}
impl ListConfigurationRevisionsOutput {
    /// Creates a new builder-style object to manufacture [`ListConfigurationRevisionsOutput`](crate::output::ListConfigurationRevisionsOutput)
    pub fn builder() -> crate::output::list_configuration_revisions_output::Builder {
        crate::output::list_configuration_revisions_output::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListBrokersOutput {
    /// A list of information about all brokers.
    pub broker_summaries: std::option::Option<std::vec::Vec<crate::model::BrokerSummary>>,
    /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListBrokersOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListBrokersOutput");
        formatter.field("broker_summaries", &self.broker_summaries);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}
/// See [`ListBrokersOutput`](crate::output::ListBrokersOutput)
pub mod list_brokers_output {
    /// A builder for [`ListBrokersOutput`](crate::output::ListBrokersOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) broker_summaries:
            std::option::Option<std::vec::Vec<crate::model::BrokerSummary>>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn broker_summaries(mut self, input: impl Into<crate::model::BrokerSummary>) -> Self {
            let mut v = self.broker_summaries.unwrap_or_default();
            v.push(input.into());
            self.broker_summaries = Some(v);
            self
        }
        pub fn set_broker_summaries(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::BrokerSummary>>,
        ) -> Self {
            self.broker_summaries = input;
            self
        }
        /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListBrokersOutput`](crate::output::ListBrokersOutput)
        pub fn build(self) -> crate::output::ListBrokersOutput {
            crate::output::ListBrokersOutput {
                broker_summaries: self.broker_summaries,
                next_token: self.next_token,
            }
        }
    }
}
impl ListBrokersOutput {
    /// Creates a new builder-style object to manufacture [`ListBrokersOutput`](crate::output::ListBrokersOutput)
    pub fn builder() -> crate::output::list_brokers_output::Builder {
        crate::output::list_brokers_output::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeUserOutput {
    /// Required. The unique ID that Amazon MQ generates for the broker.
    pub broker_id: std::option::Option<std::string::String>,
    /// Enables access to the the ActiveMQ Web Console for the ActiveMQ user.
    pub console_access: bool,
    /// The list of groups (20 maximum) to which the ActiveMQ user belongs. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long.
    pub groups: std::option::Option<std::vec::Vec<std::string::String>>,
    /// The status of the changes pending for the ActiveMQ user.
    pub pending: std::option::Option<crate::model::UserPendingChanges>,
    /// Required. The username of the ActiveMQ user. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long.
    pub username: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DescribeUserOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeUserOutput");
        formatter.field("broker_id", &self.broker_id);
        formatter.field("console_access", &self.console_access);
        formatter.field("groups", &self.groups);
        formatter.field("pending", &self.pending);
        formatter.field("username", &self.username);
        formatter.finish()
    }
}
/// See [`DescribeUserOutput`](crate::output::DescribeUserOutput)
pub mod describe_user_output {
    /// A builder for [`DescribeUserOutput`](crate::output::DescribeUserOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) broker_id: std::option::Option<std::string::String>,
        pub(crate) console_access: std::option::Option<bool>,
        pub(crate) groups: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) pending: std::option::Option<crate::model::UserPendingChanges>,
        pub(crate) username: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Required. The unique ID that Amazon MQ generates for the broker.
        pub fn broker_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.broker_id = Some(input.into());
            self
        }
        pub fn set_broker_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.broker_id = input;
            self
        }
        /// Enables access to the the ActiveMQ Web Console for the ActiveMQ user.
        pub fn console_access(mut self, input: bool) -> Self {
            self.console_access = Some(input);
            self
        }
        pub fn set_console_access(mut self, input: std::option::Option<bool>) -> Self {
            self.console_access = input;
            self
        }
        pub fn groups(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.groups.unwrap_or_default();
            v.push(input.into());
            self.groups = Some(v);
            self
        }
        pub fn set_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.groups = input;
            self
        }
        /// The status of the changes pending for the ActiveMQ user.
        pub fn pending(mut self, input: crate::model::UserPendingChanges) -> Self {
            self.pending = Some(input);
            self
        }
        pub fn set_pending(
            mut self,
            input: std::option::Option<crate::model::UserPendingChanges>,
        ) -> Self {
            self.pending = input;
            self
        }
        /// Required. The username of the ActiveMQ user. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long.
        pub fn username(mut self, input: impl Into<std::string::String>) -> Self {
            self.username = Some(input.into());
            self
        }
        pub fn set_username(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.username = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeUserOutput`](crate::output::DescribeUserOutput)
        pub fn build(self) -> crate::output::DescribeUserOutput {
            crate::output::DescribeUserOutput {
                broker_id: self.broker_id,
                console_access: self.console_access.unwrap_or_default(),
                groups: self.groups,
                pending: self.pending,
                username: self.username,
            }
        }
    }
}
impl DescribeUserOutput {
    /// Creates a new builder-style object to manufacture [`DescribeUserOutput`](crate::output::DescribeUserOutput)
    pub fn builder() -> crate::output::describe_user_output::Builder {
        crate::output::describe_user_output::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeConfigurationRevisionOutput {
    /// Required. The unique ID that Amazon MQ generates for the configuration.
    pub configuration_id: std::option::Option<std::string::String>,
    /// Required. The date and time of the configuration.
    pub created: std::option::Option<smithy_types::Instant>,
    /// Required. The base64-encoded XML configuration.
    pub data: std::option::Option<std::string::String>,
    /// The description of the configuration.
    pub description: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DescribeConfigurationRevisionOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeConfigurationRevisionOutput");
        formatter.field("configuration_id", &self.configuration_id);
        formatter.field("created", &self.created);
        formatter.field("data", &self.data);
        formatter.field("description", &self.description);
        formatter.finish()
    }
}
/// See [`DescribeConfigurationRevisionOutput`](crate::output::DescribeConfigurationRevisionOutput)
pub mod describe_configuration_revision_output {
    /// A builder for [`DescribeConfigurationRevisionOutput`](crate::output::DescribeConfigurationRevisionOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) configuration_id: std::option::Option<std::string::String>,
        pub(crate) created: std::option::Option<smithy_types::Instant>,
        pub(crate) data: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Required. The unique ID that Amazon MQ generates for the configuration.
        pub fn configuration_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.configuration_id = Some(input.into());
            self
        }
        pub fn set_configuration_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.configuration_id = input;
            self
        }
        /// Required. The date and time of the configuration.
        pub fn created(mut self, input: smithy_types::Instant) -> Self {
            self.created = Some(input);
            self
        }
        pub fn set_created(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.created = input;
            self
        }
        /// Required. The base64-encoded XML configuration.
        pub fn data(mut self, input: impl Into<std::string::String>) -> Self {
            self.data = Some(input.into());
            self
        }
        pub fn set_data(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.data = input;
            self
        }
        /// The description of the configuration.
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeConfigurationRevisionOutput`](crate::output::DescribeConfigurationRevisionOutput)
        pub fn build(self) -> crate::output::DescribeConfigurationRevisionOutput {
            crate::output::DescribeConfigurationRevisionOutput {
                configuration_id: self.configuration_id,
                created: self.created,
                data: self.data,
                description: self.description,
            }
        }
    }
}
impl DescribeConfigurationRevisionOutput {
    /// Creates a new builder-style object to manufacture [`DescribeConfigurationRevisionOutput`](crate::output::DescribeConfigurationRevisionOutput)
    pub fn builder() -> crate::output::describe_configuration_revision_output::Builder {
        crate::output::describe_configuration_revision_output::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeConfigurationOutput {
    /// Required. The ARN of the configuration.
    pub arn: std::option::Option<std::string::String>,
    /// The authentication strategy associated with the configuration.
    pub authentication_strategy: std::option::Option<crate::model::AuthenticationStrategy>,
    /// Required. The date and time of the configuration revision.
    pub created: std::option::Option<smithy_types::Instant>,
    /// Required. The description of the configuration.
    pub description: std::option::Option<std::string::String>,
    /// Required. The type of broker engine. Note: Currently, Amazon MQ supports ACTIVEMQ and RABBITMQ.
    pub engine_type: std::option::Option<crate::model::EngineType>,
    /// Required. The version of the broker engine. For a list of supported engine versions, see https://docs.aws.amazon.com/amazon-mq/latest/developer-guide/broker-engine.html
    pub engine_version: std::option::Option<std::string::String>,
    /// Required. The unique ID that Amazon MQ generates for the configuration.
    pub id: std::option::Option<std::string::String>,
    /// Required. The latest revision of the configuration.
    pub latest_revision: std::option::Option<crate::model::ConfigurationRevision>,
    /// Required. The name of the configuration. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 1-150 characters long.
    pub name: std::option::Option<std::string::String>,
    /// The list of all tags associated with this configuration.
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl std::fmt::Debug for DescribeConfigurationOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeConfigurationOutput");
        formatter.field("arn", &self.arn);
        formatter.field("authentication_strategy", &self.authentication_strategy);
        formatter.field("created", &self.created);
        formatter.field("description", &self.description);
        formatter.field("engine_type", &self.engine_type);
        formatter.field("engine_version", &self.engine_version);
        formatter.field("id", &self.id);
        formatter.field("latest_revision", &self.latest_revision);
        formatter.field("name", &self.name);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`DescribeConfigurationOutput`](crate::output::DescribeConfigurationOutput)
pub mod describe_configuration_output {
    /// A builder for [`DescribeConfigurationOutput`](crate::output::DescribeConfigurationOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) authentication_strategy:
            std::option::Option<crate::model::AuthenticationStrategy>,
        pub(crate) created: std::option::Option<smithy_types::Instant>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) engine_type: std::option::Option<crate::model::EngineType>,
        pub(crate) engine_version: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) latest_revision: std::option::Option<crate::model::ConfigurationRevision>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// Required. The ARN of the configuration.
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// The authentication strategy associated with the configuration.
        pub fn authentication_strategy(
            mut self,
            input: crate::model::AuthenticationStrategy,
        ) -> Self {
            self.authentication_strategy = Some(input);
            self
        }
        pub fn set_authentication_strategy(
            mut self,
            input: std::option::Option<crate::model::AuthenticationStrategy>,
        ) -> Self {
            self.authentication_strategy = input;
            self
        }
        /// Required. The date and time of the configuration revision.
        pub fn created(mut self, input: smithy_types::Instant) -> Self {
            self.created = Some(input);
            self
        }
        pub fn set_created(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.created = input;
            self
        }
        /// Required. The description of the configuration.
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Required. The type of broker engine. Note: Currently, Amazon MQ supports ACTIVEMQ and RABBITMQ.
        pub fn engine_type(mut self, input: crate::model::EngineType) -> Self {
            self.engine_type = Some(input);
            self
        }
        pub fn set_engine_type(
            mut self,
            input: std::option::Option<crate::model::EngineType>,
        ) -> Self {
            self.engine_type = input;
            self
        }
        /// Required. The version of the broker engine. For a list of supported engine versions, see https://docs.aws.amazon.com/amazon-mq/latest/developer-guide/broker-engine.html
        pub fn engine_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.engine_version = Some(input.into());
            self
        }
        pub fn set_engine_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.engine_version = input;
            self
        }
        /// Required. The unique ID that Amazon MQ generates for the configuration.
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// Required. The latest revision of the configuration.
        pub fn latest_revision(mut self, input: crate::model::ConfigurationRevision) -> Self {
            self.latest_revision = Some(input);
            self
        }
        pub fn set_latest_revision(
            mut self,
            input: std::option::Option<crate::model::ConfigurationRevision>,
        ) -> Self {
            self.latest_revision = input;
            self
        }
        /// Required. The name of the configuration. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 1-150 characters long.
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeConfigurationOutput`](crate::output::DescribeConfigurationOutput)
        pub fn build(self) -> crate::output::DescribeConfigurationOutput {
            crate::output::DescribeConfigurationOutput {
                arn: self.arn,
                authentication_strategy: self.authentication_strategy,
                created: self.created,
                description: self.description,
                engine_type: self.engine_type,
                engine_version: self.engine_version,
                id: self.id,
                latest_revision: self.latest_revision,
                name: self.name,
                tags: self.tags,
            }
        }
    }
}
impl DescribeConfigurationOutput {
    /// Creates a new builder-style object to manufacture [`DescribeConfigurationOutput`](crate::output::DescribeConfigurationOutput)
    pub fn builder() -> crate::output::describe_configuration_output::Builder {
        crate::output::describe_configuration_output::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeBrokerInstanceOptionsOutput {
    /// List of available broker instance options.
    pub broker_instance_options:
        std::option::Option<std::vec::Vec<crate::model::BrokerInstanceOption>>,
    /// Required. The maximum number of instance options that can be returned per page (20 by default). This value must be an integer from 5 to 100.
    pub max_results: i32,
    /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DescribeBrokerInstanceOptionsOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeBrokerInstanceOptionsOutput");
        formatter.field("broker_instance_options", &self.broker_instance_options);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}
/// See [`DescribeBrokerInstanceOptionsOutput`](crate::output::DescribeBrokerInstanceOptionsOutput)
pub mod describe_broker_instance_options_output {
    /// A builder for [`DescribeBrokerInstanceOptionsOutput`](crate::output::DescribeBrokerInstanceOptionsOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) broker_instance_options:
            std::option::Option<std::vec::Vec<crate::model::BrokerInstanceOption>>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn broker_instance_options(
            mut self,
            input: impl Into<crate::model::BrokerInstanceOption>,
        ) -> Self {
            let mut v = self.broker_instance_options.unwrap_or_default();
            v.push(input.into());
            self.broker_instance_options = Some(v);
            self
        }
        pub fn set_broker_instance_options(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::BrokerInstanceOption>>,
        ) -> Self {
            self.broker_instance_options = input;
            self
        }
        /// Required. The maximum number of instance options that can be returned per page (20 by default). This value must be an integer from 5 to 100.
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeBrokerInstanceOptionsOutput`](crate::output::DescribeBrokerInstanceOptionsOutput)
        pub fn build(self) -> crate::output::DescribeBrokerInstanceOptionsOutput {
            crate::output::DescribeBrokerInstanceOptionsOutput {
                broker_instance_options: self.broker_instance_options,
                max_results: self.max_results.unwrap_or_default(),
                next_token: self.next_token,
            }
        }
    }
}
impl DescribeBrokerInstanceOptionsOutput {
    /// Creates a new builder-style object to manufacture [`DescribeBrokerInstanceOptionsOutput`](crate::output::DescribeBrokerInstanceOptionsOutput)
    pub fn builder() -> crate::output::describe_broker_instance_options_output::Builder {
        crate::output::describe_broker_instance_options_output::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeBrokerEngineTypesOutput {
    /// List of available engine types and versions.
    pub broker_engine_types: std::option::Option<std::vec::Vec<crate::model::BrokerEngineType>>,
    /// Required. The maximum number of engine types that can be returned per page (20 by default). This value must be an integer from 5 to 100.
    pub max_results: i32,
    /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DescribeBrokerEngineTypesOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeBrokerEngineTypesOutput");
        formatter.field("broker_engine_types", &self.broker_engine_types);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}
/// See [`DescribeBrokerEngineTypesOutput`](crate::output::DescribeBrokerEngineTypesOutput)
pub mod describe_broker_engine_types_output {
    /// A builder for [`DescribeBrokerEngineTypesOutput`](crate::output::DescribeBrokerEngineTypesOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) broker_engine_types:
            std::option::Option<std::vec::Vec<crate::model::BrokerEngineType>>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn broker_engine_types(
            mut self,
            input: impl Into<crate::model::BrokerEngineType>,
        ) -> Self {
            let mut v = self.broker_engine_types.unwrap_or_default();
            v.push(input.into());
            self.broker_engine_types = Some(v);
            self
        }
        pub fn set_broker_engine_types(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::BrokerEngineType>>,
        ) -> Self {
            self.broker_engine_types = input;
            self
        }
        /// Required. The maximum number of engine types that can be returned per page (20 by default). This value must be an integer from 5 to 100.
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeBrokerEngineTypesOutput`](crate::output::DescribeBrokerEngineTypesOutput)
        pub fn build(self) -> crate::output::DescribeBrokerEngineTypesOutput {
            crate::output::DescribeBrokerEngineTypesOutput {
                broker_engine_types: self.broker_engine_types,
                max_results: self.max_results.unwrap_or_default(),
                next_token: self.next_token,
            }
        }
    }
}
impl DescribeBrokerEngineTypesOutput {
    /// Creates a new builder-style object to manufacture [`DescribeBrokerEngineTypesOutput`](crate::output::DescribeBrokerEngineTypesOutput)
    pub fn builder() -> crate::output::describe_broker_engine_types_output::Builder {
        crate::output::describe_broker_engine_types_output::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeBrokerOutput {
    /// The authentication strategy used to secure the broker.
    pub authentication_strategy: std::option::Option<crate::model::AuthenticationStrategy>,
    /// Required. Enables automatic upgrades to new minor versions for brokers, as Apache releases the versions. The automatic upgrades occur during the maintenance window of the broker or after a manual broker reboot.
    pub auto_minor_version_upgrade: bool,
    /// The Amazon Resource Name (ARN) of the broker.
    pub broker_arn: std::option::Option<std::string::String>,
    /// The unique ID that Amazon MQ generates for the broker.
    pub broker_id: std::option::Option<std::string::String>,
    /// A list of information about allocated brokers.
    pub broker_instances: std::option::Option<std::vec::Vec<crate::model::BrokerInstance>>,
    /// The name of the broker. This value must be unique in your AWS account, 1-50 characters long, must contain only letters, numbers, dashes, and underscores, and must not contain whitespaces, brackets, wildcard characters, or special characters.
    pub broker_name: std::option::Option<std::string::String>,
    /// The status of the broker.
    pub broker_state: std::option::Option<crate::model::BrokerState>,
    /// The list of all revisions for the specified configuration.
    pub configurations: std::option::Option<crate::model::Configurations>,
    /// The time when the broker was created.
    pub created: std::option::Option<smithy_types::Instant>,
    /// Required. The deployment mode of the broker.
    pub deployment_mode: std::option::Option<crate::model::DeploymentMode>,
    /// Encryption options for the broker.
    pub encryption_options: std::option::Option<crate::model::EncryptionOptions>,
    /// Required. The type of broker engine. Note: Currently, Amazon MQ supports ACTIVEMQ and RABBITMQ.
    pub engine_type: std::option::Option<crate::model::EngineType>,
    /// The version of the broker engine. For a list of supported engine versions, see https://docs.aws.amazon.com/amazon-mq/latest/developer-guide/broker-engine.html
    pub engine_version: std::option::Option<std::string::String>,
    /// The broker's instance type.
    pub host_instance_type: std::option::Option<std::string::String>,
    /// The metadata of the LDAP server used to authenticate and authorize connections to the broker.
    pub ldap_server_metadata: std::option::Option<crate::model::LdapServerMetadataOutput>,
    /// The list of information about logs currently enabled and pending to be deployed for the specified broker.
    pub logs: std::option::Option<crate::model::LogsSummary>,
    /// The parameters that determine the WeeklyStartTime.
    pub maintenance_window_start_time: std::option::Option<crate::model::WeeklyStartTime>,
    /// The authentication strategy that will be applied when the broker is rebooted.
    pub pending_authentication_strategy: std::option::Option<crate::model::AuthenticationStrategy>,
    /// The version of the broker engine to upgrade to. For a list of supported engine versions, see https://docs.aws.amazon.com/amazon-mq/latest/developer-guide/broker-engine.html
    pub pending_engine_version: std::option::Option<std::string::String>,
    /// The host instance type of the broker to upgrade to. For a list of supported instance types, see https://docs.aws.amazon.com/amazon-mq/latest/developer-guide//broker.html#broker-instance-types
    pub pending_host_instance_type: std::option::Option<std::string::String>,
    /// The metadata of the LDAP server that will be used to authenticate and authorize connections to the broker once it is rebooted.
    pub pending_ldap_server_metadata: std::option::Option<crate::model::LdapServerMetadataOutput>,
    /// The list of pending security groups to authorize connections to brokers.
    pub pending_security_groups: std::option::Option<std::vec::Vec<std::string::String>>,
    /// Required. Enables connections from applications outside of the VPC that hosts the broker's subnets.
    pub publicly_accessible: bool,
    /// The list of security groups (1 minimum, 5 maximum) that authorizes connections to brokers.
    pub security_groups: std::option::Option<std::vec::Vec<std::string::String>>,
    /// The broker's storage type.
    pub storage_type: std::option::Option<crate::model::BrokerStorageType>,
    /// The list of groups that define which subnets and IP ranges the broker can use from different Availability Zones. A SINGLE_INSTANCE deployment requires one subnet (for example, the default subnet). An ACTIVE_STANDBY_MULTI_AZ deployment (ACTIVEMQ) requires two subnets. A CLUSTER_MULTI_AZ deployment (RABBITMQ) has no subnet requirements when deployed with public accessibility, deployment without public accessibility requires at least one subnet.
    pub subnet_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// The list of all tags associated with this broker.
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// The list of all broker usernames for the specified broker.
    pub users: std::option::Option<std::vec::Vec<crate::model::UserSummary>>,
}
impl std::fmt::Debug for DescribeBrokerOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeBrokerOutput");
        formatter.field("authentication_strategy", &self.authentication_strategy);
        formatter.field(
            "auto_minor_version_upgrade",
            &self.auto_minor_version_upgrade,
        );
        formatter.field("broker_arn", &self.broker_arn);
        formatter.field("broker_id", &self.broker_id);
        formatter.field("broker_instances", &self.broker_instances);
        formatter.field("broker_name", &self.broker_name);
        formatter.field("broker_state", &self.broker_state);
        formatter.field("configurations", &self.configurations);
        formatter.field("created", &self.created);
        formatter.field("deployment_mode", &self.deployment_mode);
        formatter.field("encryption_options", &self.encryption_options);
        formatter.field("engine_type", &self.engine_type);
        formatter.field("engine_version", &self.engine_version);
        formatter.field("host_instance_type", &self.host_instance_type);
        formatter.field("ldap_server_metadata", &self.ldap_server_metadata);
        formatter.field("logs", &self.logs);
        formatter.field(
            "maintenance_window_start_time",
            &self.maintenance_window_start_time,
        );
        formatter.field(
            "pending_authentication_strategy",
            &self.pending_authentication_strategy,
        );
        formatter.field("pending_engine_version", &self.pending_engine_version);
        formatter.field(
            "pending_host_instance_type",
            &self.pending_host_instance_type,
        );
        formatter.field(
            "pending_ldap_server_metadata",
            &self.pending_ldap_server_metadata,
        );
        formatter.field("pending_security_groups", &self.pending_security_groups);
        formatter.field("publicly_accessible", &self.publicly_accessible);
        formatter.field("security_groups", &self.security_groups);
        formatter.field("storage_type", &self.storage_type);
        formatter.field("subnet_ids", &self.subnet_ids);
        formatter.field("tags", &self.tags);
        formatter.field("users", &self.users);
        formatter.finish()
    }
}
/// See [`DescribeBrokerOutput`](crate::output::DescribeBrokerOutput)
pub mod describe_broker_output {
    /// A builder for [`DescribeBrokerOutput`](crate::output::DescribeBrokerOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) authentication_strategy:
            std::option::Option<crate::model::AuthenticationStrategy>,
        pub(crate) auto_minor_version_upgrade: std::option::Option<bool>,
        pub(crate) broker_arn: std::option::Option<std::string::String>,
        pub(crate) broker_id: std::option::Option<std::string::String>,
        pub(crate) broker_instances:
            std::option::Option<std::vec::Vec<crate::model::BrokerInstance>>,
        pub(crate) broker_name: std::option::Option<std::string::String>,
        pub(crate) broker_state: std::option::Option<crate::model::BrokerState>,
        pub(crate) configurations: std::option::Option<crate::model::Configurations>,
        pub(crate) created: std::option::Option<smithy_types::Instant>,
        pub(crate) deployment_mode: std::option::Option<crate::model::DeploymentMode>,
        pub(crate) encryption_options: std::option::Option<crate::model::EncryptionOptions>,
        pub(crate) engine_type: std::option::Option<crate::model::EngineType>,
        pub(crate) engine_version: std::option::Option<std::string::String>,
        pub(crate) host_instance_type: std::option::Option<std::string::String>,
        pub(crate) ldap_server_metadata:
            std::option::Option<crate::model::LdapServerMetadataOutput>,
        pub(crate) logs: std::option::Option<crate::model::LogsSummary>,
        pub(crate) maintenance_window_start_time:
            std::option::Option<crate::model::WeeklyStartTime>,
        pub(crate) pending_authentication_strategy:
            std::option::Option<crate::model::AuthenticationStrategy>,
        pub(crate) pending_engine_version: std::option::Option<std::string::String>,
        pub(crate) pending_host_instance_type: std::option::Option<std::string::String>,
        pub(crate) pending_ldap_server_metadata:
            std::option::Option<crate::model::LdapServerMetadataOutput>,
        pub(crate) pending_security_groups: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) publicly_accessible: std::option::Option<bool>,
        pub(crate) security_groups: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) storage_type: std::option::Option<crate::model::BrokerStorageType>,
        pub(crate) subnet_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) users: std::option::Option<std::vec::Vec<crate::model::UserSummary>>,
    }
    impl Builder {
        /// The authentication strategy used to secure the broker.
        pub fn authentication_strategy(
            mut self,
            input: crate::model::AuthenticationStrategy,
        ) -> Self {
            self.authentication_strategy = Some(input);
            self
        }
        pub fn set_authentication_strategy(
            mut self,
            input: std::option::Option<crate::model::AuthenticationStrategy>,
        ) -> Self {
            self.authentication_strategy = input;
            self
        }
        /// Required. Enables automatic upgrades to new minor versions for brokers, as Apache releases the versions. The automatic upgrades occur during the maintenance window of the broker or after a manual broker reboot.
        pub fn auto_minor_version_upgrade(mut self, input: bool) -> Self {
            self.auto_minor_version_upgrade = Some(input);
            self
        }
        pub fn set_auto_minor_version_upgrade(mut self, input: std::option::Option<bool>) -> Self {
            self.auto_minor_version_upgrade = input;
            self
        }
        /// The Amazon Resource Name (ARN) of the broker.
        pub fn broker_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.broker_arn = Some(input.into());
            self
        }
        pub fn set_broker_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.broker_arn = input;
            self
        }
        /// The unique ID that Amazon MQ generates for the broker.
        pub fn broker_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.broker_id = Some(input.into());
            self
        }
        pub fn set_broker_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.broker_id = input;
            self
        }
        pub fn broker_instances(mut self, input: impl Into<crate::model::BrokerInstance>) -> Self {
            let mut v = self.broker_instances.unwrap_or_default();
            v.push(input.into());
            self.broker_instances = Some(v);
            self
        }
        pub fn set_broker_instances(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::BrokerInstance>>,
        ) -> Self {
            self.broker_instances = input;
            self
        }
        /// The name of the broker. This value must be unique in your AWS account, 1-50 characters long, must contain only letters, numbers, dashes, and underscores, and must not contain whitespaces, brackets, wildcard characters, or special characters.
        pub fn broker_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.broker_name = Some(input.into());
            self
        }
        pub fn set_broker_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.broker_name = input;
            self
        }
        /// The status of the broker.
        pub fn broker_state(mut self, input: crate::model::BrokerState) -> Self {
            self.broker_state = Some(input);
            self
        }
        pub fn set_broker_state(
            mut self,
            input: std::option::Option<crate::model::BrokerState>,
        ) -> Self {
            self.broker_state = input;
            self
        }
        /// The list of all revisions for the specified configuration.
        pub fn configurations(mut self, input: crate::model::Configurations) -> Self {
            self.configurations = Some(input);
            self
        }
        pub fn set_configurations(
            mut self,
            input: std::option::Option<crate::model::Configurations>,
        ) -> Self {
            self.configurations = input;
            self
        }
        /// The time when the broker was created.
        pub fn created(mut self, input: smithy_types::Instant) -> Self {
            self.created = Some(input);
            self
        }
        pub fn set_created(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.created = input;
            self
        }
        /// Required. The deployment mode of the broker.
        pub fn deployment_mode(mut self, input: crate::model::DeploymentMode) -> Self {
            self.deployment_mode = Some(input);
            self
        }
        pub fn set_deployment_mode(
            mut self,
            input: std::option::Option<crate::model::DeploymentMode>,
        ) -> Self {
            self.deployment_mode = input;
            self
        }
        /// Encryption options for the broker.
        pub fn encryption_options(mut self, input: crate::model::EncryptionOptions) -> Self {
            self.encryption_options = Some(input);
            self
        }
        pub fn set_encryption_options(
            mut self,
            input: std::option::Option<crate::model::EncryptionOptions>,
        ) -> Self {
            self.encryption_options = input;
            self
        }
        /// Required. The type of broker engine. Note: Currently, Amazon MQ supports ACTIVEMQ and RABBITMQ.
        pub fn engine_type(mut self, input: crate::model::EngineType) -> Self {
            self.engine_type = Some(input);
            self
        }
        pub fn set_engine_type(
            mut self,
            input: std::option::Option<crate::model::EngineType>,
        ) -> Self {
            self.engine_type = input;
            self
        }
        /// The version of the broker engine. For a list of supported engine versions, see https://docs.aws.amazon.com/amazon-mq/latest/developer-guide/broker-engine.html
        pub fn engine_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.engine_version = Some(input.into());
            self
        }
        pub fn set_engine_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.engine_version = input;
            self
        }
        /// The broker's instance type.
        pub fn host_instance_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.host_instance_type = Some(input.into());
            self
        }
        pub fn set_host_instance_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.host_instance_type = input;
            self
        }
        /// The metadata of the LDAP server used to authenticate and authorize connections to the broker.
        pub fn ldap_server_metadata(
            mut self,
            input: crate::model::LdapServerMetadataOutput,
        ) -> Self {
            self.ldap_server_metadata = Some(input);
            self
        }
        pub fn set_ldap_server_metadata(
            mut self,
            input: std::option::Option<crate::model::LdapServerMetadataOutput>,
        ) -> Self {
            self.ldap_server_metadata = input;
            self
        }
        /// The list of information about logs currently enabled and pending to be deployed for the specified broker.
        pub fn logs(mut self, input: crate::model::LogsSummary) -> Self {
            self.logs = Some(input);
            self
        }
        pub fn set_logs(mut self, input: std::option::Option<crate::model::LogsSummary>) -> Self {
            self.logs = input;
            self
        }
        /// The parameters that determine the WeeklyStartTime.
        pub fn maintenance_window_start_time(
            mut self,
            input: crate::model::WeeklyStartTime,
        ) -> Self {
            self.maintenance_window_start_time = Some(input);
            self
        }
        pub fn set_maintenance_window_start_time(
            mut self,
            input: std::option::Option<crate::model::WeeklyStartTime>,
        ) -> Self {
            self.maintenance_window_start_time = input;
            self
        }
        /// The authentication strategy that will be applied when the broker is rebooted.
        pub fn pending_authentication_strategy(
            mut self,
            input: crate::model::AuthenticationStrategy,
        ) -> Self {
            self.pending_authentication_strategy = Some(input);
            self
        }
        pub fn set_pending_authentication_strategy(
            mut self,
            input: std::option::Option<crate::model::AuthenticationStrategy>,
        ) -> Self {
            self.pending_authentication_strategy = input;
            self
        }
        /// The version of the broker engine to upgrade to. For a list of supported engine versions, see https://docs.aws.amazon.com/amazon-mq/latest/developer-guide/broker-engine.html
        pub fn pending_engine_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.pending_engine_version = Some(input.into());
            self
        }
        pub fn set_pending_engine_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.pending_engine_version = input;
            self
        }
        /// The host instance type of the broker to upgrade to. For a list of supported instance types, see https://docs.aws.amazon.com/amazon-mq/latest/developer-guide//broker.html#broker-instance-types
        pub fn pending_host_instance_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.pending_host_instance_type = Some(input.into());
            self
        }
        pub fn set_pending_host_instance_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.pending_host_instance_type = input;
            self
        }
        /// The metadata of the LDAP server that will be used to authenticate and authorize connections to the broker once it is rebooted.
        pub fn pending_ldap_server_metadata(
            mut self,
            input: crate::model::LdapServerMetadataOutput,
        ) -> Self {
            self.pending_ldap_server_metadata = Some(input);
            self
        }
        pub fn set_pending_ldap_server_metadata(
            mut self,
            input: std::option::Option<crate::model::LdapServerMetadataOutput>,
        ) -> Self {
            self.pending_ldap_server_metadata = input;
            self
        }
        pub fn pending_security_groups(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.pending_security_groups.unwrap_or_default();
            v.push(input.into());
            self.pending_security_groups = Some(v);
            self
        }
        pub fn set_pending_security_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.pending_security_groups = input;
            self
        }
        /// Required. Enables connections from applications outside of the VPC that hosts the broker's subnets.
        pub fn publicly_accessible(mut self, input: bool) -> Self {
            self.publicly_accessible = Some(input);
            self
        }
        pub fn set_publicly_accessible(mut self, input: std::option::Option<bool>) -> Self {
            self.publicly_accessible = input;
            self
        }
        pub fn security_groups(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.security_groups.unwrap_or_default();
            v.push(input.into());
            self.security_groups = Some(v);
            self
        }
        pub fn set_security_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.security_groups = input;
            self
        }
        /// The broker's storage type.
        pub fn storage_type(mut self, input: crate::model::BrokerStorageType) -> Self {
            self.storage_type = Some(input);
            self
        }
        pub fn set_storage_type(
            mut self,
            input: std::option::Option<crate::model::BrokerStorageType>,
        ) -> Self {
            self.storage_type = input;
            self
        }
        pub fn subnet_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.subnet_ids.unwrap_or_default();
            v.push(input.into());
            self.subnet_ids = Some(v);
            self
        }
        pub fn set_subnet_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.subnet_ids = input;
            self
        }
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        pub fn users(mut self, input: impl Into<crate::model::UserSummary>) -> Self {
            let mut v = self.users.unwrap_or_default();
            v.push(input.into());
            self.users = Some(v);
            self
        }
        pub fn set_users(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::UserSummary>>,
        ) -> Self {
            self.users = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeBrokerOutput`](crate::output::DescribeBrokerOutput)
        pub fn build(self) -> crate::output::DescribeBrokerOutput {
            crate::output::DescribeBrokerOutput {
                authentication_strategy: self.authentication_strategy,
                auto_minor_version_upgrade: self.auto_minor_version_upgrade.unwrap_or_default(),
                broker_arn: self.broker_arn,
                broker_id: self.broker_id,
                broker_instances: self.broker_instances,
                broker_name: self.broker_name,
                broker_state: self.broker_state,
                configurations: self.configurations,
                created: self.created,
                deployment_mode: self.deployment_mode,
                encryption_options: self.encryption_options,
                engine_type: self.engine_type,
                engine_version: self.engine_version,
                host_instance_type: self.host_instance_type,
                ldap_server_metadata: self.ldap_server_metadata,
                logs: self.logs,
                maintenance_window_start_time: self.maintenance_window_start_time,
                pending_authentication_strategy: self.pending_authentication_strategy,
                pending_engine_version: self.pending_engine_version,
                pending_host_instance_type: self.pending_host_instance_type,
                pending_ldap_server_metadata: self.pending_ldap_server_metadata,
                pending_security_groups: self.pending_security_groups,
                publicly_accessible: self.publicly_accessible.unwrap_or_default(),
                security_groups: self.security_groups,
                storage_type: self.storage_type,
                subnet_ids: self.subnet_ids,
                tags: self.tags,
                users: self.users,
            }
        }
    }
}
impl DescribeBrokerOutput {
    /// Creates a new builder-style object to manufacture [`DescribeBrokerOutput`](crate::output::DescribeBrokerOutput)
    pub fn builder() -> crate::output::describe_broker_output::Builder {
        crate::output::describe_broker_output::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteUserOutput {}
impl std::fmt::Debug for DeleteUserOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteUserOutput");
        formatter.finish()
    }
}
/// See [`DeleteUserOutput`](crate::output::DeleteUserOutput)
pub mod delete_user_output {
    /// A builder for [`DeleteUserOutput`](crate::output::DeleteUserOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`DeleteUserOutput`](crate::output::DeleteUserOutput)
        pub fn build(self) -> crate::output::DeleteUserOutput {
            crate::output::DeleteUserOutput {}
        }
    }
}
impl DeleteUserOutput {
    /// Creates a new builder-style object to manufacture [`DeleteUserOutput`](crate::output::DeleteUserOutput)
    pub fn builder() -> crate::output::delete_user_output::Builder {
        crate::output::delete_user_output::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteTagsOutput {}
impl std::fmt::Debug for DeleteTagsOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteTagsOutput");
        formatter.finish()
    }
}
/// See [`DeleteTagsOutput`](crate::output::DeleteTagsOutput)
pub mod delete_tags_output {
    /// A builder for [`DeleteTagsOutput`](crate::output::DeleteTagsOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`DeleteTagsOutput`](crate::output::DeleteTagsOutput)
        pub fn build(self) -> crate::output::DeleteTagsOutput {
            crate::output::DeleteTagsOutput {}
        }
    }
}
impl DeleteTagsOutput {
    /// Creates a new builder-style object to manufacture [`DeleteTagsOutput`](crate::output::DeleteTagsOutput)
    pub fn builder() -> crate::output::delete_tags_output::Builder {
        crate::output::delete_tags_output::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteBrokerOutput {
    /// The unique ID that Amazon MQ generates for the broker.
    pub broker_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteBrokerOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteBrokerOutput");
        formatter.field("broker_id", &self.broker_id);
        formatter.finish()
    }
}
/// See [`DeleteBrokerOutput`](crate::output::DeleteBrokerOutput)
pub mod delete_broker_output {
    /// A builder for [`DeleteBrokerOutput`](crate::output::DeleteBrokerOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) broker_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// The unique ID that Amazon MQ generates for the broker.
        pub fn broker_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.broker_id = Some(input.into());
            self
        }
        pub fn set_broker_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.broker_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteBrokerOutput`](crate::output::DeleteBrokerOutput)
        pub fn build(self) -> crate::output::DeleteBrokerOutput {
            crate::output::DeleteBrokerOutput {
                broker_id: self.broker_id,
            }
        }
    }
}
impl DeleteBrokerOutput {
    /// Creates a new builder-style object to manufacture [`DeleteBrokerOutput`](crate::output::DeleteBrokerOutput)
    pub fn builder() -> crate::output::delete_broker_output::Builder {
        crate::output::delete_broker_output::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateUserOutput {}
impl std::fmt::Debug for CreateUserOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateUserOutput");
        formatter.finish()
    }
}
/// See [`CreateUserOutput`](crate::output::CreateUserOutput)
pub mod create_user_output {
    /// A builder for [`CreateUserOutput`](crate::output::CreateUserOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`CreateUserOutput`](crate::output::CreateUserOutput)
        pub fn build(self) -> crate::output::CreateUserOutput {
            crate::output::CreateUserOutput {}
        }
    }
}
impl CreateUserOutput {
    /// Creates a new builder-style object to manufacture [`CreateUserOutput`](crate::output::CreateUserOutput)
    pub fn builder() -> crate::output::create_user_output::Builder {
        crate::output::create_user_output::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateTagsOutput {}
impl std::fmt::Debug for CreateTagsOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateTagsOutput");
        formatter.finish()
    }
}
/// See [`CreateTagsOutput`](crate::output::CreateTagsOutput)
pub mod create_tags_output {
    /// A builder for [`CreateTagsOutput`](crate::output::CreateTagsOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`CreateTagsOutput`](crate::output::CreateTagsOutput)
        pub fn build(self) -> crate::output::CreateTagsOutput {
            crate::output::CreateTagsOutput {}
        }
    }
}
impl CreateTagsOutput {
    /// Creates a new builder-style object to manufacture [`CreateTagsOutput`](crate::output::CreateTagsOutput)
    pub fn builder() -> crate::output::create_tags_output::Builder {
        crate::output::create_tags_output::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateConfigurationOutput {
    /// Required. The Amazon Resource Name (ARN) of the configuration.
    pub arn: std::option::Option<std::string::String>,
    /// The authentication strategy associated with the configuration.
    pub authentication_strategy: std::option::Option<crate::model::AuthenticationStrategy>,
    /// Required. The date and time of the configuration.
    pub created: std::option::Option<smithy_types::Instant>,
    /// Required. The unique ID that Amazon MQ generates for the configuration.
    pub id: std::option::Option<std::string::String>,
    /// The latest revision of the configuration.
    pub latest_revision: std::option::Option<crate::model::ConfigurationRevision>,
    /// Required. The name of the configuration. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 1-150 characters long.
    pub name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CreateConfigurationOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateConfigurationOutput");
        formatter.field("arn", &self.arn);
        formatter.field("authentication_strategy", &self.authentication_strategy);
        formatter.field("created", &self.created);
        formatter.field("id", &self.id);
        formatter.field("latest_revision", &self.latest_revision);
        formatter.field("name", &self.name);
        formatter.finish()
    }
}
/// See [`CreateConfigurationOutput`](crate::output::CreateConfigurationOutput)
pub mod create_configuration_output {
    /// A builder for [`CreateConfigurationOutput`](crate::output::CreateConfigurationOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) authentication_strategy:
            std::option::Option<crate::model::AuthenticationStrategy>,
        pub(crate) created: std::option::Option<smithy_types::Instant>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) latest_revision: std::option::Option<crate::model::ConfigurationRevision>,
        pub(crate) name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Required. The Amazon Resource Name (ARN) of the configuration.
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// The authentication strategy associated with the configuration.
        pub fn authentication_strategy(
            mut self,
            input: crate::model::AuthenticationStrategy,
        ) -> Self {
            self.authentication_strategy = Some(input);
            self
        }
        pub fn set_authentication_strategy(
            mut self,
            input: std::option::Option<crate::model::AuthenticationStrategy>,
        ) -> Self {
            self.authentication_strategy = input;
            self
        }
        /// Required. The date and time of the configuration.
        pub fn created(mut self, input: smithy_types::Instant) -> Self {
            self.created = Some(input);
            self
        }
        pub fn set_created(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.created = input;
            self
        }
        /// Required. The unique ID that Amazon MQ generates for the configuration.
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// The latest revision of the configuration.
        pub fn latest_revision(mut self, input: crate::model::ConfigurationRevision) -> Self {
            self.latest_revision = Some(input);
            self
        }
        pub fn set_latest_revision(
            mut self,
            input: std::option::Option<crate::model::ConfigurationRevision>,
        ) -> Self {
            self.latest_revision = input;
            self
        }
        /// Required. The name of the configuration. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 1-150 characters long.
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateConfigurationOutput`](crate::output::CreateConfigurationOutput)
        pub fn build(self) -> crate::output::CreateConfigurationOutput {
            crate::output::CreateConfigurationOutput {
                arn: self.arn,
                authentication_strategy: self.authentication_strategy,
                created: self.created,
                id: self.id,
                latest_revision: self.latest_revision,
                name: self.name,
            }
        }
    }
}
impl CreateConfigurationOutput {
    /// Creates a new builder-style object to manufacture [`CreateConfigurationOutput`](crate::output::CreateConfigurationOutput)
    pub fn builder() -> crate::output::create_configuration_output::Builder {
        crate::output::create_configuration_output::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateBrokerOutput {
    /// The Amazon Resource Name (ARN) of the broker.
    pub broker_arn: std::option::Option<std::string::String>,
    /// The unique ID that Amazon MQ generates for the broker.
    pub broker_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CreateBrokerOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateBrokerOutput");
        formatter.field("broker_arn", &self.broker_arn);
        formatter.field("broker_id", &self.broker_id);
        formatter.finish()
    }
}
/// See [`CreateBrokerOutput`](crate::output::CreateBrokerOutput)
pub mod create_broker_output {
    /// A builder for [`CreateBrokerOutput`](crate::output::CreateBrokerOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) broker_arn: std::option::Option<std::string::String>,
        pub(crate) broker_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// The Amazon Resource Name (ARN) of the broker.
        pub fn broker_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.broker_arn = Some(input.into());
            self
        }
        pub fn set_broker_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.broker_arn = input;
            self
        }
        /// The unique ID that Amazon MQ generates for the broker.
        pub fn broker_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.broker_id = Some(input.into());
            self
        }
        pub fn set_broker_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.broker_id = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateBrokerOutput`](crate::output::CreateBrokerOutput)
        pub fn build(self) -> crate::output::CreateBrokerOutput {
            crate::output::CreateBrokerOutput {
                broker_arn: self.broker_arn,
                broker_id: self.broker_id,
            }
        }
    }
}
impl CreateBrokerOutput {
    /// Creates a new builder-style object to manufacture [`CreateBrokerOutput`](crate::output::CreateBrokerOutput)
    pub fn builder() -> crate::output::create_broker_output::Builder {
        crate::output::create_broker_output::Builder::default()
    }
}
