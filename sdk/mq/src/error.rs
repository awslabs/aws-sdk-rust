// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateBrokerError {
    pub kind: CreateBrokerErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateBrokerErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateBrokerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateBrokerErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateBrokerErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateBrokerErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            CreateBrokerErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            CreateBrokerErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            CreateBrokerErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateBrokerError {
    fn code(&self) -> Option<&str> {
        CreateBrokerError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateBrokerError {
    pub fn new(kind: CreateBrokerErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateBrokerErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateBrokerErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, CreateBrokerErrorKind::BadRequestException(_))
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, CreateBrokerErrorKind::ConflictException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, CreateBrokerErrorKind::ForbiddenException(_))
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateBrokerErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, CreateBrokerErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for CreateBrokerError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateBrokerErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateBrokerErrorKind::ConflictException(_inner) => Some(_inner),
            CreateBrokerErrorKind::ForbiddenException(_inner) => Some(_inner),
            CreateBrokerErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            CreateBrokerErrorKind::UnauthorizedException(_inner) => Some(_inner),
            CreateBrokerErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateConfigurationError {
    pub kind: CreateConfigurationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateConfigurationErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateConfigurationErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateConfigurationErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateConfigurationErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            CreateConfigurationErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            CreateConfigurationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateConfigurationError {
    fn code(&self) -> Option<&str> {
        CreateConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateConfigurationError {
    pub fn new(kind: CreateConfigurationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateConfigurationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateConfigurationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateConfigurationErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateConfigurationErrorKind::ConflictException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateConfigurationErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateConfigurationErrorKind::InternalServerErrorException(_)
        )
    }
}
impl std::error::Error for CreateConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateConfigurationErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateConfigurationErrorKind::ConflictException(_inner) => Some(_inner),
            CreateConfigurationErrorKind::ForbiddenException(_inner) => Some(_inner),
            CreateConfigurationErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            CreateConfigurationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateTagsError {
    pub kind: CreateTagsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateTagsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateTagsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateTagsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateTagsErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            CreateTagsErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            CreateTagsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            CreateTagsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateTagsError {
    fn code(&self) -> Option<&str> {
        CreateTagsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateTagsError {
    pub fn new(kind: CreateTagsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateTagsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateTagsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, CreateTagsErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, CreateTagsErrorKind::ForbiddenException(_))
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateTagsErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, CreateTagsErrorKind::NotFoundException(_))
    }
}
impl std::error::Error for CreateTagsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateTagsErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateTagsErrorKind::ForbiddenException(_inner) => Some(_inner),
            CreateTagsErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            CreateTagsErrorKind::NotFoundException(_inner) => Some(_inner),
            CreateTagsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateUserError {
    pub kind: CreateUserErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateUserErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateUserError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateUserErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateUserErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateUserErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            CreateUserErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            CreateUserErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            CreateUserErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateUserError {
    fn code(&self) -> Option<&str> {
        CreateUserError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateUserError {
    pub fn new(kind: CreateUserErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateUserErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateUserErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, CreateUserErrorKind::BadRequestException(_))
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, CreateUserErrorKind::ConflictException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, CreateUserErrorKind::ForbiddenException(_))
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUserErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, CreateUserErrorKind::NotFoundException(_))
    }
}
impl std::error::Error for CreateUserError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateUserErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateUserErrorKind::ConflictException(_inner) => Some(_inner),
            CreateUserErrorKind::ForbiddenException(_inner) => Some(_inner),
            CreateUserErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            CreateUserErrorKind::NotFoundException(_inner) => Some(_inner),
            CreateUserErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteBrokerError {
    pub kind: DeleteBrokerErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteBrokerErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteBrokerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteBrokerErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteBrokerErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DeleteBrokerErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            DeleteBrokerErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteBrokerErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteBrokerError {
    fn code(&self) -> Option<&str> {
        DeleteBrokerError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteBrokerError {
    pub fn new(kind: DeleteBrokerErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteBrokerErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteBrokerErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, DeleteBrokerErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, DeleteBrokerErrorKind::ForbiddenException(_))
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteBrokerErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeleteBrokerErrorKind::NotFoundException(_))
    }
}
impl std::error::Error for DeleteBrokerError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteBrokerErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteBrokerErrorKind::ForbiddenException(_inner) => Some(_inner),
            DeleteBrokerErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            DeleteBrokerErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteBrokerErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteTagsError {
    pub kind: DeleteTagsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteTagsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteTagsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteTagsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteTagsErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DeleteTagsErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            DeleteTagsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteTagsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteTagsError {
    fn code(&self) -> Option<&str> {
        DeleteTagsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteTagsError {
    pub fn new(kind: DeleteTagsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteTagsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteTagsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, DeleteTagsErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, DeleteTagsErrorKind::ForbiddenException(_))
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteTagsErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeleteTagsErrorKind::NotFoundException(_))
    }
}
impl std::error::Error for DeleteTagsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteTagsErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteTagsErrorKind::ForbiddenException(_inner) => Some(_inner),
            DeleteTagsErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            DeleteTagsErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteTagsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteUserError {
    pub kind: DeleteUserErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteUserErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteUserError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteUserErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteUserErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DeleteUserErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            DeleteUserErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteUserErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteUserError {
    fn code(&self) -> Option<&str> {
        DeleteUserError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteUserError {
    pub fn new(kind: DeleteUserErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteUserErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteUserErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, DeleteUserErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, DeleteUserErrorKind::ForbiddenException(_))
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteUserErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeleteUserErrorKind::NotFoundException(_))
    }
}
impl std::error::Error for DeleteUserError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteUserErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteUserErrorKind::ForbiddenException(_inner) => Some(_inner),
            DeleteUserErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            DeleteUserErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteUserErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeBrokerError {
    pub kind: DescribeBrokerErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeBrokerErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeBrokerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeBrokerErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DescribeBrokerErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DescribeBrokerErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            DescribeBrokerErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DescribeBrokerErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeBrokerError {
    fn code(&self) -> Option<&str> {
        DescribeBrokerError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeBrokerError {
    pub fn new(kind: DescribeBrokerErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeBrokerErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeBrokerErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, DescribeBrokerErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, DescribeBrokerErrorKind::ForbiddenException(_))
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeBrokerErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DescribeBrokerErrorKind::NotFoundException(_))
    }
}
impl std::error::Error for DescribeBrokerError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeBrokerErrorKind::BadRequestException(_inner) => Some(_inner),
            DescribeBrokerErrorKind::ForbiddenException(_inner) => Some(_inner),
            DescribeBrokerErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            DescribeBrokerErrorKind::NotFoundException(_inner) => Some(_inner),
            DescribeBrokerErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeBrokerEngineTypesError {
    pub kind: DescribeBrokerEngineTypesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeBrokerEngineTypesErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeBrokerEngineTypesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeBrokerEngineTypesErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DescribeBrokerEngineTypesErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DescribeBrokerEngineTypesErrorKind::InternalServerErrorException(_inner) => {
                _inner.fmt(f)
            }
            DescribeBrokerEngineTypesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeBrokerEngineTypesError {
    fn code(&self) -> Option<&str> {
        DescribeBrokerEngineTypesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeBrokerEngineTypesError {
    pub fn new(kind: DescribeBrokerEngineTypesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeBrokerEngineTypesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeBrokerEngineTypesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeBrokerEngineTypesErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeBrokerEngineTypesErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeBrokerEngineTypesErrorKind::InternalServerErrorException(_)
        )
    }
}
impl std::error::Error for DescribeBrokerEngineTypesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeBrokerEngineTypesErrorKind::BadRequestException(_inner) => Some(_inner),
            DescribeBrokerEngineTypesErrorKind::ForbiddenException(_inner) => Some(_inner),
            DescribeBrokerEngineTypesErrorKind::InternalServerErrorException(_inner) => {
                Some(_inner)
            }
            DescribeBrokerEngineTypesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeBrokerInstanceOptionsError {
    pub kind: DescribeBrokerInstanceOptionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeBrokerInstanceOptionsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeBrokerInstanceOptionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeBrokerInstanceOptionsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DescribeBrokerInstanceOptionsErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DescribeBrokerInstanceOptionsErrorKind::InternalServerErrorException(_inner) => {
                _inner.fmt(f)
            }
            DescribeBrokerInstanceOptionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeBrokerInstanceOptionsError {
    fn code(&self) -> Option<&str> {
        DescribeBrokerInstanceOptionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeBrokerInstanceOptionsError {
    pub fn new(kind: DescribeBrokerInstanceOptionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeBrokerInstanceOptionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeBrokerInstanceOptionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeBrokerInstanceOptionsErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeBrokerInstanceOptionsErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeBrokerInstanceOptionsErrorKind::InternalServerErrorException(_)
        )
    }
}
impl std::error::Error for DescribeBrokerInstanceOptionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeBrokerInstanceOptionsErrorKind::BadRequestException(_inner) => Some(_inner),
            DescribeBrokerInstanceOptionsErrorKind::ForbiddenException(_inner) => Some(_inner),
            DescribeBrokerInstanceOptionsErrorKind::InternalServerErrorException(_inner) => {
                Some(_inner)
            }
            DescribeBrokerInstanceOptionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeConfigurationError {
    pub kind: DescribeConfigurationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeConfigurationErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeConfigurationErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DescribeConfigurationErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DescribeConfigurationErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            DescribeConfigurationErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DescribeConfigurationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeConfigurationError {
    fn code(&self) -> Option<&str> {
        DescribeConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeConfigurationError {
    pub fn new(kind: DescribeConfigurationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeConfigurationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeConfigurationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeConfigurationErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeConfigurationErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeConfigurationErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeConfigurationErrorKind::NotFoundException(_)
        )
    }
}
impl std::error::Error for DescribeConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeConfigurationErrorKind::BadRequestException(_inner) => Some(_inner),
            DescribeConfigurationErrorKind::ForbiddenException(_inner) => Some(_inner),
            DescribeConfigurationErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            DescribeConfigurationErrorKind::NotFoundException(_inner) => Some(_inner),
            DescribeConfigurationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeConfigurationRevisionError {
    pub kind: DescribeConfigurationRevisionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeConfigurationRevisionErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeConfigurationRevisionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeConfigurationRevisionErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DescribeConfigurationRevisionErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DescribeConfigurationRevisionErrorKind::InternalServerErrorException(_inner) => {
                _inner.fmt(f)
            }
            DescribeConfigurationRevisionErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DescribeConfigurationRevisionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeConfigurationRevisionError {
    fn code(&self) -> Option<&str> {
        DescribeConfigurationRevisionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeConfigurationRevisionError {
    pub fn new(kind: DescribeConfigurationRevisionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeConfigurationRevisionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeConfigurationRevisionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeConfigurationRevisionErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeConfigurationRevisionErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeConfigurationRevisionErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeConfigurationRevisionErrorKind::NotFoundException(_)
        )
    }
}
impl std::error::Error for DescribeConfigurationRevisionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeConfigurationRevisionErrorKind::BadRequestException(_inner) => Some(_inner),
            DescribeConfigurationRevisionErrorKind::ForbiddenException(_inner) => Some(_inner),
            DescribeConfigurationRevisionErrorKind::InternalServerErrorException(_inner) => {
                Some(_inner)
            }
            DescribeConfigurationRevisionErrorKind::NotFoundException(_inner) => Some(_inner),
            DescribeConfigurationRevisionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeUserError {
    pub kind: DescribeUserErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeUserErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeUserError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeUserErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DescribeUserErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DescribeUserErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            DescribeUserErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DescribeUserErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeUserError {
    fn code(&self) -> Option<&str> {
        DescribeUserError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeUserError {
    pub fn new(kind: DescribeUserErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeUserErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeUserErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, DescribeUserErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, DescribeUserErrorKind::ForbiddenException(_))
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeUserErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DescribeUserErrorKind::NotFoundException(_))
    }
}
impl std::error::Error for DescribeUserError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeUserErrorKind::BadRequestException(_inner) => Some(_inner),
            DescribeUserErrorKind::ForbiddenException(_inner) => Some(_inner),
            DescribeUserErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            DescribeUserErrorKind::NotFoundException(_inner) => Some(_inner),
            DescribeUserErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListBrokersError {
    pub kind: ListBrokersErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListBrokersErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListBrokersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListBrokersErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListBrokersErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            ListBrokersErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            ListBrokersErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListBrokersError {
    fn code(&self) -> Option<&str> {
        ListBrokersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListBrokersError {
    pub fn new(kind: ListBrokersErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListBrokersErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListBrokersErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, ListBrokersErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, ListBrokersErrorKind::ForbiddenException(_))
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListBrokersErrorKind::InternalServerErrorException(_)
        )
    }
}
impl std::error::Error for ListBrokersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListBrokersErrorKind::BadRequestException(_inner) => Some(_inner),
            ListBrokersErrorKind::ForbiddenException(_inner) => Some(_inner),
            ListBrokersErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            ListBrokersErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListConfigurationRevisionsError {
    pub kind: ListConfigurationRevisionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListConfigurationRevisionsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListConfigurationRevisionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListConfigurationRevisionsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListConfigurationRevisionsErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            ListConfigurationRevisionsErrorKind::InternalServerErrorException(_inner) => {
                _inner.fmt(f)
            }
            ListConfigurationRevisionsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            ListConfigurationRevisionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListConfigurationRevisionsError {
    fn code(&self) -> Option<&str> {
        ListConfigurationRevisionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListConfigurationRevisionsError {
    pub fn new(kind: ListConfigurationRevisionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListConfigurationRevisionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListConfigurationRevisionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListConfigurationRevisionsErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListConfigurationRevisionsErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListConfigurationRevisionsErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListConfigurationRevisionsErrorKind::NotFoundException(_)
        )
    }
}
impl std::error::Error for ListConfigurationRevisionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListConfigurationRevisionsErrorKind::BadRequestException(_inner) => Some(_inner),
            ListConfigurationRevisionsErrorKind::ForbiddenException(_inner) => Some(_inner),
            ListConfigurationRevisionsErrorKind::InternalServerErrorException(_inner) => {
                Some(_inner)
            }
            ListConfigurationRevisionsErrorKind::NotFoundException(_inner) => Some(_inner),
            ListConfigurationRevisionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListConfigurationsError {
    pub kind: ListConfigurationsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListConfigurationsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListConfigurationsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListConfigurationsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListConfigurationsErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            ListConfigurationsErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            ListConfigurationsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListConfigurationsError {
    fn code(&self) -> Option<&str> {
        ListConfigurationsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListConfigurationsError {
    pub fn new(kind: ListConfigurationsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListConfigurationsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListConfigurationsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListConfigurationsErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListConfigurationsErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListConfigurationsErrorKind::InternalServerErrorException(_)
        )
    }
}
impl std::error::Error for ListConfigurationsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListConfigurationsErrorKind::BadRequestException(_inner) => Some(_inner),
            ListConfigurationsErrorKind::ForbiddenException(_inner) => Some(_inner),
            ListConfigurationsErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            ListConfigurationsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTagsError {
    pub kind: ListTagsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTagsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListTagsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTagsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListTagsErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            ListTagsErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            ListTagsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            ListTagsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListTagsError {
    fn code(&self) -> Option<&str> {
        ListTagsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTagsError {
    pub fn new(kind: ListTagsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListTagsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListTagsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, ListTagsErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, ListTagsErrorKind::ForbiddenException(_))
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, ListTagsErrorKind::NotFoundException(_))
    }
}
impl std::error::Error for ListTagsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTagsErrorKind::BadRequestException(_inner) => Some(_inner),
            ListTagsErrorKind::ForbiddenException(_inner) => Some(_inner),
            ListTagsErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            ListTagsErrorKind::NotFoundException(_inner) => Some(_inner),
            ListTagsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListUsersError {
    pub kind: ListUsersErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListUsersErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListUsersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListUsersErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListUsersErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            ListUsersErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            ListUsersErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            ListUsersErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListUsersError {
    fn code(&self) -> Option<&str> {
        ListUsersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListUsersError {
    pub fn new(kind: ListUsersErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListUsersErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListUsersErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, ListUsersErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, ListUsersErrorKind::ForbiddenException(_))
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListUsersErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, ListUsersErrorKind::NotFoundException(_))
    }
}
impl std::error::Error for ListUsersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListUsersErrorKind::BadRequestException(_inner) => Some(_inner),
            ListUsersErrorKind::ForbiddenException(_inner) => Some(_inner),
            ListUsersErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            ListUsersErrorKind::NotFoundException(_inner) => Some(_inner),
            ListUsersErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RebootBrokerError {
    pub kind: RebootBrokerErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RebootBrokerErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RebootBrokerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RebootBrokerErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            RebootBrokerErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            RebootBrokerErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            RebootBrokerErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            RebootBrokerErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RebootBrokerError {
    fn code(&self) -> Option<&str> {
        RebootBrokerError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RebootBrokerError {
    pub fn new(kind: RebootBrokerErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RebootBrokerErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RebootBrokerErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, RebootBrokerErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, RebootBrokerErrorKind::ForbiddenException(_))
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            RebootBrokerErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, RebootBrokerErrorKind::NotFoundException(_))
    }
}
impl std::error::Error for RebootBrokerError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RebootBrokerErrorKind::BadRequestException(_inner) => Some(_inner),
            RebootBrokerErrorKind::ForbiddenException(_inner) => Some(_inner),
            RebootBrokerErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            RebootBrokerErrorKind::NotFoundException(_inner) => Some(_inner),
            RebootBrokerErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateBrokerError {
    pub kind: UpdateBrokerErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateBrokerErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateBrokerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateBrokerErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateBrokerErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateBrokerErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            UpdateBrokerErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            UpdateBrokerErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateBrokerErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateBrokerError {
    fn code(&self) -> Option<&str> {
        UpdateBrokerError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateBrokerError {
    pub fn new(kind: UpdateBrokerErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateBrokerErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateBrokerErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, UpdateBrokerErrorKind::BadRequestException(_))
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, UpdateBrokerErrorKind::ConflictException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, UpdateBrokerErrorKind::ForbiddenException(_))
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateBrokerErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, UpdateBrokerErrorKind::NotFoundException(_))
    }
}
impl std::error::Error for UpdateBrokerError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateBrokerErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateBrokerErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateBrokerErrorKind::ForbiddenException(_inner) => Some(_inner),
            UpdateBrokerErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            UpdateBrokerErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateBrokerErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateConfigurationError {
    pub kind: UpdateConfigurationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateConfigurationErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateConfigurationErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateConfigurationErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateConfigurationErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            UpdateConfigurationErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            UpdateConfigurationErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateConfigurationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateConfigurationError {
    fn code(&self) -> Option<&str> {
        UpdateConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateConfigurationError {
    pub fn new(kind: UpdateConfigurationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateConfigurationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateConfigurationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateConfigurationErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateConfigurationErrorKind::ConflictException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateConfigurationErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateConfigurationErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateConfigurationErrorKind::NotFoundException(_)
        )
    }
}
impl std::error::Error for UpdateConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateConfigurationErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateConfigurationErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateConfigurationErrorKind::ForbiddenException(_inner) => Some(_inner),
            UpdateConfigurationErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            UpdateConfigurationErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateConfigurationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateUserError {
    pub kind: UpdateUserErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateUserErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateUserError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateUserErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateUserErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateUserErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            UpdateUserErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            UpdateUserErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateUserErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateUserError {
    fn code(&self) -> Option<&str> {
        UpdateUserError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateUserError {
    pub fn new(kind: UpdateUserErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateUserErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateUserErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, UpdateUserErrorKind::BadRequestException(_))
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, UpdateUserErrorKind::ConflictException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, UpdateUserErrorKind::ForbiddenException(_))
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, UpdateUserErrorKind::NotFoundException(_))
    }
}
impl std::error::Error for UpdateUserError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateUserErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateUserErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateUserErrorKind::ForbiddenException(_inner) => Some(_inner),
            UpdateUserErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            UpdateUserErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateUserErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// <p>Returns information about an error.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NotFoundException {
    /// <p>The attribute which caused the error.</p>
    pub error_attribute: std::option::Option<std::string::String>,
    /// <p>The explanation of the error.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for NotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NotFoundException");
        formatter.field("error_attribute", &self.error_attribute);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl NotFoundException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for NotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NotFoundException")?;
        if let Some(inner_1) = &self.message {
            write!(f, ": {}", inner_1)?;
        }
        Ok(())
    }
}
impl std::error::Error for NotFoundException {}
/// See [`NotFoundException`](crate::error::NotFoundException)
pub mod not_found_exception {
    /// A builder for [`NotFoundException`](crate::error::NotFoundException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) error_attribute: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The attribute which caused the error.</p>
        pub fn error_attribute(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_attribute = Some(input.into());
            self
        }
        pub fn set_error_attribute(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.error_attribute = input;
            self
        }
        /// <p>The explanation of the error.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`NotFoundException`](crate::error::NotFoundException)
        pub fn build(self) -> crate::error::NotFoundException {
            crate::error::NotFoundException {
                error_attribute: self.error_attribute,
                message: self.message,
            }
        }
    }
}
impl NotFoundException {
    /// Creates a new builder-style object to manufacture [`NotFoundException`](crate::error::NotFoundException)
    pub fn builder() -> crate::error::not_found_exception::Builder {
        crate::error::not_found_exception::Builder::default()
    }
}

/// <p>Returns information about an error.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InternalServerErrorException {
    /// <p>The attribute which caused the error.</p>
    pub error_attribute: std::option::Option<std::string::String>,
    /// <p>The explanation of the error.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InternalServerErrorException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InternalServerErrorException");
        formatter.field("error_attribute", &self.error_attribute);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InternalServerErrorException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InternalServerErrorException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InternalServerErrorException")?;
        if let Some(inner_2) = &self.message {
            write!(f, ": {}", inner_2)?;
        }
        Ok(())
    }
}
impl std::error::Error for InternalServerErrorException {}
/// See [`InternalServerErrorException`](crate::error::InternalServerErrorException)
pub mod internal_server_error_exception {
    /// A builder for [`InternalServerErrorException`](crate::error::InternalServerErrorException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) error_attribute: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The attribute which caused the error.</p>
        pub fn error_attribute(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_attribute = Some(input.into());
            self
        }
        pub fn set_error_attribute(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.error_attribute = input;
            self
        }
        /// <p>The explanation of the error.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InternalServerErrorException`](crate::error::InternalServerErrorException)
        pub fn build(self) -> crate::error::InternalServerErrorException {
            crate::error::InternalServerErrorException {
                error_attribute: self.error_attribute,
                message: self.message,
            }
        }
    }
}
impl InternalServerErrorException {
    /// Creates a new builder-style object to manufacture [`InternalServerErrorException`](crate::error::InternalServerErrorException)
    pub fn builder() -> crate::error::internal_server_error_exception::Builder {
        crate::error::internal_server_error_exception::Builder::default()
    }
}

/// <p>Returns information about an error.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ForbiddenException {
    /// <p>The attribute which caused the error.</p>
    pub error_attribute: std::option::Option<std::string::String>,
    /// <p>The explanation of the error.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ForbiddenException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ForbiddenException");
        formatter.field("error_attribute", &self.error_attribute);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ForbiddenException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ForbiddenException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ForbiddenException")?;
        if let Some(inner_3) = &self.message {
            write!(f, ": {}", inner_3)?;
        }
        Ok(())
    }
}
impl std::error::Error for ForbiddenException {}
/// See [`ForbiddenException`](crate::error::ForbiddenException)
pub mod forbidden_exception {
    /// A builder for [`ForbiddenException`](crate::error::ForbiddenException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) error_attribute: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The attribute which caused the error.</p>
        pub fn error_attribute(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_attribute = Some(input.into());
            self
        }
        pub fn set_error_attribute(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.error_attribute = input;
            self
        }
        /// <p>The explanation of the error.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ForbiddenException`](crate::error::ForbiddenException)
        pub fn build(self) -> crate::error::ForbiddenException {
            crate::error::ForbiddenException {
                error_attribute: self.error_attribute,
                message: self.message,
            }
        }
    }
}
impl ForbiddenException {
    /// Creates a new builder-style object to manufacture [`ForbiddenException`](crate::error::ForbiddenException)
    pub fn builder() -> crate::error::forbidden_exception::Builder {
        crate::error::forbidden_exception::Builder::default()
    }
}

/// <p>Returns information about an error.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ConflictException {
    /// <p>The attribute which caused the error.</p>
    pub error_attribute: std::option::Option<std::string::String>,
    /// <p>The explanation of the error.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ConflictException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ConflictException");
        formatter.field("error_attribute", &self.error_attribute);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ConflictException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ConflictException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ConflictException")?;
        if let Some(inner_4) = &self.message {
            write!(f, ": {}", inner_4)?;
        }
        Ok(())
    }
}
impl std::error::Error for ConflictException {}
/// See [`ConflictException`](crate::error::ConflictException)
pub mod conflict_exception {
    /// A builder for [`ConflictException`](crate::error::ConflictException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) error_attribute: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The attribute which caused the error.</p>
        pub fn error_attribute(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_attribute = Some(input.into());
            self
        }
        pub fn set_error_attribute(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.error_attribute = input;
            self
        }
        /// <p>The explanation of the error.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ConflictException`](crate::error::ConflictException)
        pub fn build(self) -> crate::error::ConflictException {
            crate::error::ConflictException {
                error_attribute: self.error_attribute,
                message: self.message,
            }
        }
    }
}
impl ConflictException {
    /// Creates a new builder-style object to manufacture [`ConflictException`](crate::error::ConflictException)
    pub fn builder() -> crate::error::conflict_exception::Builder {
        crate::error::conflict_exception::Builder::default()
    }
}

/// <p>Returns information about an error.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BadRequestException {
    /// <p>The attribute which caused the error.</p>
    pub error_attribute: std::option::Option<std::string::String>,
    /// <p>The explanation of the error.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for BadRequestException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BadRequestException");
        formatter.field("error_attribute", &self.error_attribute);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl BadRequestException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for BadRequestException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "BadRequestException")?;
        if let Some(inner_5) = &self.message {
            write!(f, ": {}", inner_5)?;
        }
        Ok(())
    }
}
impl std::error::Error for BadRequestException {}
/// See [`BadRequestException`](crate::error::BadRequestException)
pub mod bad_request_exception {
    /// A builder for [`BadRequestException`](crate::error::BadRequestException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) error_attribute: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The attribute which caused the error.</p>
        pub fn error_attribute(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_attribute = Some(input.into());
            self
        }
        pub fn set_error_attribute(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.error_attribute = input;
            self
        }
        /// <p>The explanation of the error.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`BadRequestException`](crate::error::BadRequestException)
        pub fn build(self) -> crate::error::BadRequestException {
            crate::error::BadRequestException {
                error_attribute: self.error_attribute,
                message: self.message,
            }
        }
    }
}
impl BadRequestException {
    /// Creates a new builder-style object to manufacture [`BadRequestException`](crate::error::BadRequestException)
    pub fn builder() -> crate::error::bad_request_exception::Builder {
        crate::error::bad_request_exception::Builder::default()
    }
}

/// <p>Returns information about an error.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UnauthorizedException {
    /// <p>The attribute which caused the error.</p>
    pub error_attribute: std::option::Option<std::string::String>,
    /// <p>The explanation of the error.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UnauthorizedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UnauthorizedException");
        formatter.field("error_attribute", &self.error_attribute);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl UnauthorizedException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for UnauthorizedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "UnauthorizedException")?;
        if let Some(inner_6) = &self.message {
            write!(f, ": {}", inner_6)?;
        }
        Ok(())
    }
}
impl std::error::Error for UnauthorizedException {}
/// See [`UnauthorizedException`](crate::error::UnauthorizedException)
pub mod unauthorized_exception {
    /// A builder for [`UnauthorizedException`](crate::error::UnauthorizedException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) error_attribute: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The attribute which caused the error.</p>
        pub fn error_attribute(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_attribute = Some(input.into());
            self
        }
        pub fn set_error_attribute(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.error_attribute = input;
            self
        }
        /// <p>The explanation of the error.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`UnauthorizedException`](crate::error::UnauthorizedException)
        pub fn build(self) -> crate::error::UnauthorizedException {
            crate::error::UnauthorizedException {
                error_attribute: self.error_attribute,
                message: self.message,
            }
        }
    }
}
impl UnauthorizedException {
    /// Creates a new builder-style object to manufacture [`UnauthorizedException`](crate::error::UnauthorizedException)
    pub fn builder() -> crate::error::unauthorized_exception::Builder {
        crate::error::unauthorized_exception::Builder::default()
    }
}
