// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[derive(std::fmt::Debug)]
pub(crate) struct Handle<C = aws_hyper::DynConnector> {
    client: aws_hyper::Client<C>,
    conf: crate::Config,
}

#[derive(Clone, std::fmt::Debug)]
pub struct Client<C = aws_hyper::DynConnector> {
    handle: std::sync::Arc<Handle<C>>,
}
impl<C> Client<C> {
    pub fn from_conf_conn(conf: crate::Config, conn: C) -> Self {
        let client = aws_hyper::Client::new(conn);
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }

    pub fn conf(&self) -> &crate::Config {
        &self.handle.conf
    }
}
impl Client {
    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_env() -> Self {
        Self::from_conf(crate::Config::builder().build())
    }

    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_conf(conf: crate::Config) -> Self {
        let client = aws_hyper::Client::https();
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
impl<C> Client<C>
where
    C: aws_hyper::SmithyConnector,
{
    pub fn create_broker(&self) -> fluent_builders::CreateBroker<C> {
        fluent_builders::CreateBroker::new(self.handle.clone())
    }
    pub fn create_configuration(&self) -> fluent_builders::CreateConfiguration<C> {
        fluent_builders::CreateConfiguration::new(self.handle.clone())
    }
    pub fn create_tags(&self) -> fluent_builders::CreateTags<C> {
        fluent_builders::CreateTags::new(self.handle.clone())
    }
    pub fn create_user(&self) -> fluent_builders::CreateUser<C> {
        fluent_builders::CreateUser::new(self.handle.clone())
    }
    pub fn delete_broker(&self) -> fluent_builders::DeleteBroker<C> {
        fluent_builders::DeleteBroker::new(self.handle.clone())
    }
    pub fn delete_tags(&self) -> fluent_builders::DeleteTags<C> {
        fluent_builders::DeleteTags::new(self.handle.clone())
    }
    pub fn delete_user(&self) -> fluent_builders::DeleteUser<C> {
        fluent_builders::DeleteUser::new(self.handle.clone())
    }
    pub fn describe_broker(&self) -> fluent_builders::DescribeBroker<C> {
        fluent_builders::DescribeBroker::new(self.handle.clone())
    }
    pub fn describe_broker_engine_types(&self) -> fluent_builders::DescribeBrokerEngineTypes<C> {
        fluent_builders::DescribeBrokerEngineTypes::new(self.handle.clone())
    }
    pub fn describe_broker_instance_options(
        &self,
    ) -> fluent_builders::DescribeBrokerInstanceOptions<C> {
        fluent_builders::DescribeBrokerInstanceOptions::new(self.handle.clone())
    }
    pub fn describe_configuration(&self) -> fluent_builders::DescribeConfiguration<C> {
        fluent_builders::DescribeConfiguration::new(self.handle.clone())
    }
    pub fn describe_configuration_revision(
        &self,
    ) -> fluent_builders::DescribeConfigurationRevision<C> {
        fluent_builders::DescribeConfigurationRevision::new(self.handle.clone())
    }
    pub fn describe_user(&self) -> fluent_builders::DescribeUser<C> {
        fluent_builders::DescribeUser::new(self.handle.clone())
    }
    pub fn list_brokers(&self) -> fluent_builders::ListBrokers<C> {
        fluent_builders::ListBrokers::new(self.handle.clone())
    }
    pub fn list_configuration_revisions(&self) -> fluent_builders::ListConfigurationRevisions<C> {
        fluent_builders::ListConfigurationRevisions::new(self.handle.clone())
    }
    pub fn list_configurations(&self) -> fluent_builders::ListConfigurations<C> {
        fluent_builders::ListConfigurations::new(self.handle.clone())
    }
    pub fn list_tags(&self) -> fluent_builders::ListTags<C> {
        fluent_builders::ListTags::new(self.handle.clone())
    }
    pub fn list_users(&self) -> fluent_builders::ListUsers<C> {
        fluent_builders::ListUsers::new(self.handle.clone())
    }
    pub fn reboot_broker(&self) -> fluent_builders::RebootBroker<C> {
        fluent_builders::RebootBroker::new(self.handle.clone())
    }
    pub fn update_broker(&self) -> fluent_builders::UpdateBroker<C> {
        fluent_builders::UpdateBroker::new(self.handle.clone())
    }
    pub fn update_configuration(&self) -> fluent_builders::UpdateConfiguration<C> {
        fluent_builders::UpdateConfiguration::new(self.handle.clone())
    }
    pub fn update_user(&self) -> fluent_builders::UpdateUser<C> {
        fluent_builders::UpdateUser::new(self.handle.clone())
    }
}
pub mod fluent_builders {
    #[derive(std::fmt::Debug)]
    pub struct CreateBroker<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_broker_input::Builder,
    }
    impl<C> CreateBroker<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateBrokerOutput,
            smithy_http::result::SdkError<crate::error::CreateBrokerError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// The authentication strategy used to secure the broker.
        pub fn authentication_strategy(
            mut self,
            input: crate::model::AuthenticationStrategy,
        ) -> Self {
            self.inner = self.inner.authentication_strategy(input);
            self
        }
        pub fn set_authentication_strategy(
            mut self,
            input: std::option::Option<crate::model::AuthenticationStrategy>,
        ) -> Self {
            self.inner = self.inner.set_authentication_strategy(input);
            self
        }
        /// Required. Enables automatic upgrades to new minor versions for brokers, as Apache releases the versions. The automatic upgrades occur during the maintenance window of the broker or after a manual broker reboot.
        pub fn auto_minor_version_upgrade(mut self, input: bool) -> Self {
            self.inner = self.inner.auto_minor_version_upgrade(input);
            self
        }
        pub fn set_auto_minor_version_upgrade(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_auto_minor_version_upgrade(input);
            self
        }
        /// Required. The name of the broker. This value must be unique in your AWS account, 1-50 characters long, must contain only letters, numbers, dashes, and underscores, and must not contain whitespaces, brackets, wildcard characters, or special characters.
        pub fn broker_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.broker_name(input);
            self
        }
        pub fn set_broker_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_broker_name(input);
            self
        }
        /// A list of information about the configuration.
        pub fn configuration(mut self, input: crate::model::ConfigurationId) -> Self {
            self.inner = self.inner.configuration(input);
            self
        }
        pub fn set_configuration(
            mut self,
            input: std::option::Option<crate::model::ConfigurationId>,
        ) -> Self {
            self.inner = self.inner.set_configuration(input);
            self
        }
        /// The unique ID that the requester receives for the created broker. Amazon MQ passes your ID with the API action. Note: We recommend using a Universally Unique Identifier (UUID) for the creatorRequestId. You may omit the creatorRequestId if your application doesn't require idempotency.
        pub fn creator_request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.creator_request_id(input);
            self
        }
        pub fn set_creator_request_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_creator_request_id(input);
            self
        }
        /// Required. The deployment mode of the broker.
        pub fn deployment_mode(mut self, input: crate::model::DeploymentMode) -> Self {
            self.inner = self.inner.deployment_mode(input);
            self
        }
        pub fn set_deployment_mode(
            mut self,
            input: std::option::Option<crate::model::DeploymentMode>,
        ) -> Self {
            self.inner = self.inner.set_deployment_mode(input);
            self
        }
        /// Encryption options for the broker.
        pub fn encryption_options(mut self, input: crate::model::EncryptionOptions) -> Self {
            self.inner = self.inner.encryption_options(input);
            self
        }
        pub fn set_encryption_options(
            mut self,
            input: std::option::Option<crate::model::EncryptionOptions>,
        ) -> Self {
            self.inner = self.inner.set_encryption_options(input);
            self
        }
        /// Required. The type of broker engine. Note: Currently, Amazon MQ supports ACTIVEMQ and RABBITMQ.
        pub fn engine_type(mut self, input: crate::model::EngineType) -> Self {
            self.inner = self.inner.engine_type(input);
            self
        }
        pub fn set_engine_type(
            mut self,
            input: std::option::Option<crate::model::EngineType>,
        ) -> Self {
            self.inner = self.inner.set_engine_type(input);
            self
        }
        /// Required. The version of the broker engine. For a list of supported engine versions, see https://docs.aws.amazon.com/amazon-mq/latest/developer-guide/broker-engine.html
        pub fn engine_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.engine_version(input);
            self
        }
        pub fn set_engine_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_engine_version(input);
            self
        }
        /// Required. The broker's instance type.
        pub fn host_instance_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.host_instance_type(input);
            self
        }
        pub fn set_host_instance_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_host_instance_type(input);
            self
        }
        /// The metadata of the LDAP server used to authenticate and authorize connections to the broker.
        pub fn ldap_server_metadata(
            mut self,
            input: crate::model::LdapServerMetadataInput,
        ) -> Self {
            self.inner = self.inner.ldap_server_metadata(input);
            self
        }
        pub fn set_ldap_server_metadata(
            mut self,
            input: std::option::Option<crate::model::LdapServerMetadataInput>,
        ) -> Self {
            self.inner = self.inner.set_ldap_server_metadata(input);
            self
        }
        /// Enables Amazon CloudWatch logging for brokers.
        pub fn logs(mut self, input: crate::model::Logs) -> Self {
            self.inner = self.inner.logs(input);
            self
        }
        pub fn set_logs(mut self, input: std::option::Option<crate::model::Logs>) -> Self {
            self.inner = self.inner.set_logs(input);
            self
        }
        /// The parameters that determine the WeeklyStartTime.
        pub fn maintenance_window_start_time(
            mut self,
            input: crate::model::WeeklyStartTime,
        ) -> Self {
            self.inner = self.inner.maintenance_window_start_time(input);
            self
        }
        pub fn set_maintenance_window_start_time(
            mut self,
            input: std::option::Option<crate::model::WeeklyStartTime>,
        ) -> Self {
            self.inner = self.inner.set_maintenance_window_start_time(input);
            self
        }
        /// Required. Enables connections from applications outside of the VPC that hosts the broker's subnets.
        pub fn publicly_accessible(mut self, input: bool) -> Self {
            self.inner = self.inner.publicly_accessible(input);
            self
        }
        pub fn set_publicly_accessible(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_publicly_accessible(input);
            self
        }
        /// The list of security groups (1 minimum, 5 maximum) that authorizes connections to brokers.
        pub fn security_groups(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.security_groups(inp);
            self
        }
        pub fn set_security_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_security_groups(input);
            self
        }
        /// The broker's storage type.
        pub fn storage_type(mut self, input: crate::model::BrokerStorageType) -> Self {
            self.inner = self.inner.storage_type(input);
            self
        }
        pub fn set_storage_type(
            mut self,
            input: std::option::Option<crate::model::BrokerStorageType>,
        ) -> Self {
            self.inner = self.inner.set_storage_type(input);
            self
        }
        /// The list of groups that define which subnets and IP ranges the broker can use from different Availability Zones. A SINGLE_INSTANCE deployment requires one subnet (for example, the default subnet). An ACTIVE_STANDBY_MULTI_AZ deployment (ACTIVEMQ) requires two subnets. A CLUSTER_MULTI_AZ deployment (RABBITMQ) has no subnet requirements when deployed with public accessibility, deployment without public accessibility requires at least one subnet.
        pub fn subnet_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.subnet_ids(inp);
            self
        }
        pub fn set_subnet_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_subnet_ids(input);
            self
        }
        /// Create tags when creating the broker.
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.tags(k, v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
        /// Required. The list of broker users (persons or applications) who can access queues and topics. For RabbitMQ brokers, one and only one administrative user is accepted and created when a broker is first provisioned. All subsequent broker users are created by making RabbitMQ API calls directly to brokers or via the RabbitMQ Web Console. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long.
        pub fn users(mut self, inp: impl Into<crate::model::User>) -> Self {
            self.inner = self.inner.users(inp);
            self
        }
        pub fn set_users(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::User>>,
        ) -> Self {
            self.inner = self.inner.set_users(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateConfiguration<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_configuration_input::Builder,
    }
    impl<C> CreateConfiguration<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateConfigurationOutput,
            smithy_http::result::SdkError<crate::error::CreateConfigurationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// The authentication strategy associated with the configuration.
        pub fn authentication_strategy(
            mut self,
            input: crate::model::AuthenticationStrategy,
        ) -> Self {
            self.inner = self.inner.authentication_strategy(input);
            self
        }
        pub fn set_authentication_strategy(
            mut self,
            input: std::option::Option<crate::model::AuthenticationStrategy>,
        ) -> Self {
            self.inner = self.inner.set_authentication_strategy(input);
            self
        }
        /// Required. The type of broker engine. Note: Currently, Amazon MQ supports ACTIVEMQ and RABBITMQ.
        pub fn engine_type(mut self, input: crate::model::EngineType) -> Self {
            self.inner = self.inner.engine_type(input);
            self
        }
        pub fn set_engine_type(
            mut self,
            input: std::option::Option<crate::model::EngineType>,
        ) -> Self {
            self.inner = self.inner.set_engine_type(input);
            self
        }
        /// Required. The version of the broker engine. For a list of supported engine versions, see https://docs.aws.amazon.com/amazon-mq/latest/developer-guide/broker-engine.html
        pub fn engine_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.engine_version(input);
            self
        }
        pub fn set_engine_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_engine_version(input);
            self
        }
        /// Required. The name of the configuration. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 1-150 characters long.
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// Create tags when creating the configuration.
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.tags(k, v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateTags<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_tags_input::Builder,
    }
    impl<C> CreateTags<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateTagsOutput,
            smithy_http::result::SdkError<crate::error::CreateTagsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// The Amazon Resource Name (ARN) of the resource tag.
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// The key-value pair for the resource tag.
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.tags(k, v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateUser<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_user_input::Builder,
    }
    impl<C> CreateUser<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateUserOutput,
            smithy_http::result::SdkError<crate::error::CreateUserError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// The unique ID that Amazon MQ generates for the broker.
        pub fn broker_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.broker_id(input);
            self
        }
        pub fn set_broker_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_broker_id(input);
            self
        }
        /// Enables access to the the ActiveMQ Web Console for the ActiveMQ user.
        pub fn console_access(mut self, input: bool) -> Self {
            self.inner = self.inner.console_access(input);
            self
        }
        pub fn set_console_access(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_console_access(input);
            self
        }
        /// The list of groups (20 maximum) to which the ActiveMQ user belongs. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long.
        pub fn groups(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.groups(inp);
            self
        }
        pub fn set_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_groups(input);
            self
        }
        /// Required. The password of the user. This value must be at least 12 characters long, must contain at least 4 unique characters, and must not contain commas.
        pub fn password(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.password(input);
            self
        }
        pub fn set_password(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_password(input);
            self
        }
        /// The username of the ActiveMQ user. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long.
        pub fn username(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.username(input);
            self
        }
        pub fn set_username(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_username(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteBroker<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_broker_input::Builder,
    }
    impl<C> DeleteBroker<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteBrokerOutput,
            smithy_http::result::SdkError<crate::error::DeleteBrokerError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// The unique ID that Amazon MQ generates for the broker.
        pub fn broker_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.broker_id(input);
            self
        }
        pub fn set_broker_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_broker_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteTags<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_tags_input::Builder,
    }
    impl<C> DeleteTags<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteTagsOutput,
            smithy_http::result::SdkError<crate::error::DeleteTagsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// The Amazon Resource Name (ARN) of the resource tag.
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// An array of tag keys to delete
        pub fn tag_keys(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tag_keys(inp);
            self
        }
        pub fn set_tag_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_tag_keys(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteUser<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_user_input::Builder,
    }
    impl<C> DeleteUser<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteUserOutput,
            smithy_http::result::SdkError<crate::error::DeleteUserError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// The unique ID that Amazon MQ generates for the broker.
        pub fn broker_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.broker_id(input);
            self
        }
        pub fn set_broker_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_broker_id(input);
            self
        }
        /// The username of the ActiveMQ user. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long.
        pub fn username(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.username(input);
            self
        }
        pub fn set_username(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_username(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeBroker<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_broker_input::Builder,
    }
    impl<C> DescribeBroker<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeBrokerOutput,
            smithy_http::result::SdkError<crate::error::DescribeBrokerError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// The name of the broker. This value must be unique in your AWS account, 1-50 characters long, must contain only letters, numbers, dashes, and underscores, and must not contain whitespaces, brackets, wildcard characters, or special characters.
        pub fn broker_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.broker_id(input);
            self
        }
        pub fn set_broker_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_broker_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeBrokerEngineTypes<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_broker_engine_types_input::Builder,
    }
    impl<C> DescribeBrokerEngineTypes<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeBrokerEngineTypesOutput,
            smithy_http::result::SdkError<crate::error::DescribeBrokerEngineTypesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// Filter response by engine type.
        pub fn engine_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.engine_type(input);
            self
        }
        pub fn set_engine_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_engine_type(input);
            self
        }
        /// The maximum number of engine types that Amazon MQ can return per page (20 by default). This value must be an integer from 5 to 100.
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeBrokerInstanceOptions<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_broker_instance_options_input::Builder,
    }
    impl<C> DescribeBrokerInstanceOptions<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeBrokerInstanceOptionsOutput,
            smithy_http::result::SdkError<crate::error::DescribeBrokerInstanceOptionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// Filter response by engine type.
        pub fn engine_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.engine_type(input);
            self
        }
        pub fn set_engine_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_engine_type(input);
            self
        }
        /// Filter response by host instance type.
        pub fn host_instance_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.host_instance_type(input);
            self
        }
        pub fn set_host_instance_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_host_instance_type(input);
            self
        }
        /// The maximum number of instance options that Amazon MQ can return per page (20 by default). This value must be an integer from 5 to 100.
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// Filter response by storage type.
        pub fn storage_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.storage_type(input);
            self
        }
        pub fn set_storage_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_storage_type(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeConfiguration<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_configuration_input::Builder,
    }
    impl<C> DescribeConfiguration<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeConfigurationOutput,
            smithy_http::result::SdkError<crate::error::DescribeConfigurationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// The unique ID that Amazon MQ generates for the configuration.
        pub fn configuration_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.configuration_id(input);
            self
        }
        pub fn set_configuration_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_configuration_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeConfigurationRevision<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_configuration_revision_input::Builder,
    }
    impl<C> DescribeConfigurationRevision<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeConfigurationRevisionOutput,
            smithy_http::result::SdkError<crate::error::DescribeConfigurationRevisionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// The unique ID that Amazon MQ generates for the configuration.
        pub fn configuration_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.configuration_id(input);
            self
        }
        pub fn set_configuration_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_configuration_id(input);
            self
        }
        /// The revision of the configuration.
        pub fn configuration_revision(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.configuration_revision(input);
            self
        }
        pub fn set_configuration_revision(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_configuration_revision(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeUser<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_user_input::Builder,
    }
    impl<C> DescribeUser<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeUserOutput,
            smithy_http::result::SdkError<crate::error::DescribeUserError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// The unique ID that Amazon MQ generates for the broker.
        pub fn broker_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.broker_id(input);
            self
        }
        pub fn set_broker_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_broker_id(input);
            self
        }
        /// The username of the ActiveMQ user. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long.
        pub fn username(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.username(input);
            self
        }
        pub fn set_username(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_username(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListBrokers<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_brokers_input::Builder,
    }
    impl<C> ListBrokers<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListBrokersOutput,
            smithy_http::result::SdkError<crate::error::ListBrokersError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// The maximum number of brokers that Amazon MQ can return per page (20 by default). This value must be an integer from 5 to 100.
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListConfigurationRevisions<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_configuration_revisions_input::Builder,
    }
    impl<C> ListConfigurationRevisions<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListConfigurationRevisionsOutput,
            smithy_http::result::SdkError<crate::error::ListConfigurationRevisionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// The unique ID that Amazon MQ generates for the configuration.
        pub fn configuration_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.configuration_id(input);
            self
        }
        pub fn set_configuration_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_configuration_id(input);
            self
        }
        /// The maximum number of configurations that Amazon MQ can return per page (20 by default). This value must be an integer from 5 to 100.
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListConfigurations<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_configurations_input::Builder,
    }
    impl<C> ListConfigurations<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListConfigurationsOutput,
            smithy_http::result::SdkError<crate::error::ListConfigurationsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// The maximum number of configurations that Amazon MQ can return per page (20 by default). This value must be an integer from 5 to 100.
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListTags<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_tags_input::Builder,
    }
    impl<C> ListTags<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListTagsOutput,
            smithy_http::result::SdkError<crate::error::ListTagsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// The Amazon Resource Name (ARN) of the resource tag.
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListUsers<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_users_input::Builder,
    }
    impl<C> ListUsers<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListUsersOutput,
            smithy_http::result::SdkError<crate::error::ListUsersError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// The unique ID that Amazon MQ generates for the broker.
        pub fn broker_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.broker_id(input);
            self
        }
        pub fn set_broker_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_broker_id(input);
            self
        }
        /// The maximum number of ActiveMQ users that can be returned per page (20 by default). This value must be an integer from 5 to 100.
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RebootBroker<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::reboot_broker_input::Builder,
    }
    impl<C> RebootBroker<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RebootBrokerOutput,
            smithy_http::result::SdkError<crate::error::RebootBrokerError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// The unique ID that Amazon MQ generates for the broker.
        pub fn broker_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.broker_id(input);
            self
        }
        pub fn set_broker_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_broker_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateBroker<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_broker_input::Builder,
    }
    impl<C> UpdateBroker<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateBrokerOutput,
            smithy_http::result::SdkError<crate::error::UpdateBrokerError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// The authentication strategy used to secure the broker.
        pub fn authentication_strategy(
            mut self,
            input: crate::model::AuthenticationStrategy,
        ) -> Self {
            self.inner = self.inner.authentication_strategy(input);
            self
        }
        pub fn set_authentication_strategy(
            mut self,
            input: std::option::Option<crate::model::AuthenticationStrategy>,
        ) -> Self {
            self.inner = self.inner.set_authentication_strategy(input);
            self
        }
        /// Enables automatic upgrades to new minor versions for brokers, as Apache releases the versions. The automatic upgrades occur during the maintenance window of the broker or after a manual broker reboot.
        pub fn auto_minor_version_upgrade(mut self, input: bool) -> Self {
            self.inner = self.inner.auto_minor_version_upgrade(input);
            self
        }
        pub fn set_auto_minor_version_upgrade(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_auto_minor_version_upgrade(input);
            self
        }
        /// The unique ID that Amazon MQ generates for the broker.
        pub fn broker_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.broker_id(input);
            self
        }
        pub fn set_broker_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_broker_id(input);
            self
        }
        /// A list of information about the configuration.
        pub fn configuration(mut self, input: crate::model::ConfigurationId) -> Self {
            self.inner = self.inner.configuration(input);
            self
        }
        pub fn set_configuration(
            mut self,
            input: std::option::Option<crate::model::ConfigurationId>,
        ) -> Self {
            self.inner = self.inner.set_configuration(input);
            self
        }
        /// The version of the broker engine. For a list of supported engine versions, see https://docs.aws.amazon.com/amazon-mq/latest/developer-guide/broker-engine.html
        pub fn engine_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.engine_version(input);
            self
        }
        pub fn set_engine_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_engine_version(input);
            self
        }
        /// The host instance type of the broker to upgrade to. For a list of supported instance types, see https://docs.aws.amazon.com/amazon-mq/latest/developer-guide//broker.html#broker-instance-types
        pub fn host_instance_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.host_instance_type(input);
            self
        }
        pub fn set_host_instance_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_host_instance_type(input);
            self
        }
        /// The metadata of the LDAP server used to authenticate and authorize connections to the broker.
        pub fn ldap_server_metadata(
            mut self,
            input: crate::model::LdapServerMetadataInput,
        ) -> Self {
            self.inner = self.inner.ldap_server_metadata(input);
            self
        }
        pub fn set_ldap_server_metadata(
            mut self,
            input: std::option::Option<crate::model::LdapServerMetadataInput>,
        ) -> Self {
            self.inner = self.inner.set_ldap_server_metadata(input);
            self
        }
        /// Enables Amazon CloudWatch logging for brokers.
        pub fn logs(mut self, input: crate::model::Logs) -> Self {
            self.inner = self.inner.logs(input);
            self
        }
        pub fn set_logs(mut self, input: std::option::Option<crate::model::Logs>) -> Self {
            self.inner = self.inner.set_logs(input);
            self
        }
        /// The list of security groups (1 minimum, 5 maximum) that authorizes connections to brokers.
        pub fn security_groups(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.security_groups(inp);
            self
        }
        pub fn set_security_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_security_groups(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateConfiguration<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_configuration_input::Builder,
    }
    impl<C> UpdateConfiguration<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateConfigurationOutput,
            smithy_http::result::SdkError<crate::error::UpdateConfigurationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// The unique ID that Amazon MQ generates for the configuration.
        pub fn configuration_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.configuration_id(input);
            self
        }
        pub fn set_configuration_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_configuration_id(input);
            self
        }
        /// Required. The base64-encoded XML configuration.
        pub fn data(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.data(input);
            self
        }
        pub fn set_data(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_data(input);
            self
        }
        /// The description of the configuration.
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateUser<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_user_input::Builder,
    }
    impl<C> UpdateUser<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateUserOutput,
            smithy_http::result::SdkError<crate::error::UpdateUserError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// The unique ID that Amazon MQ generates for the broker.
        pub fn broker_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.broker_id(input);
            self
        }
        pub fn set_broker_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_broker_id(input);
            self
        }
        /// Enables access to the the ActiveMQ Web Console for the ActiveMQ user.
        pub fn console_access(mut self, input: bool) -> Self {
            self.inner = self.inner.console_access(input);
            self
        }
        pub fn set_console_access(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_console_access(input);
            self
        }
        /// The list of groups (20 maximum) to which the ActiveMQ user belongs. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long.
        pub fn groups(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.groups(inp);
            self
        }
        pub fn set_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_groups(input);
            self
        }
        /// The password of the user. This value must be at least 12 characters long, must contain at least 4 unique characters, and must not contain commas.
        pub fn password(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.password(input);
            self
        }
        pub fn set_password(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_password(input);
            self
        }
        /// Required. The username of the ActiveMQ user. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long.
        pub fn username(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.username(input);
            self
        }
        pub fn set_username(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_username(input);
            self
        }
    }
}
