/*
 * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * SPDX-License-Identifier: Apache-2.0.
 */

//! Subcommand for fixing manifest dependency version numbers.
//!
//! Finds all of the version numbers for every crate in the repo crate path, and then
//! finds all references to the crates in that path and updates them to have the correct
//! version numbers in addition to the dependency path.

use crate::fs::Fs;
use crate::package::{discover_package_manifests, parse_version};
use crate::repo::discover_repository;
use crate::{REPO_CRATE_PATH, REPO_NAME};
use anyhow::{bail, Context, Result};
use semver::Version;
use std::collections::BTreeMap;
use std::path::PathBuf;
use toml::value::Table;
use tracing::info;

#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum Mode {
    Check,
    Execute,
}

pub async fn subcommand_fix_manifests(mode: Mode) -> Result<()> {
    let repo = discover_repository(REPO_NAME, REPO_CRATE_PATH)?;
    let manifest_paths = discover_package_manifests(&repo.crates_root).await?;
    let mut manifests = read_manifests(Fs::Real, manifest_paths).await?;
    let versions = package_versions(&manifests)?;
    fix_manifests(Fs::Real, &versions, &mut manifests, mode).await?;
    Ok(())
}

struct Manifest {
    path: PathBuf,
    metadata: toml::Value,
}

async fn read_manifests(fs: Fs, manifest_paths: Vec<PathBuf>) -> Result<Vec<Manifest>> {
    let mut result = Vec::new();
    for path in manifest_paths {
        let contents = fs.read_file(&path).await?;
        let metadata = toml::from_slice(&contents)
            .with_context(|| format!("failed to load package manifest for {:?}", &path))?;
        result.push(Manifest { path, metadata });
    }
    Ok(result)
}

/// Returns a map of crate name to semver version number
fn package_versions(manifests: &[Manifest]) -> Result<BTreeMap<String, Version>> {
    let mut versions = BTreeMap::new();
    for manifest in manifests {
        let name = manifest.metadata["package"]["name"]
            .as_str()
            .ok_or_else(|| {
                anyhow::Error::msg(format!("{:?} is missing a package name", manifest.path))
            })?;
        let version = manifest.metadata["package"]["version"]
            .as_str()
            .ok_or_else(|| {
                anyhow::Error::msg(format!("{:?} is missing a package version", manifest.path))
            })?;
        let version = parse_version(&manifest.path, version)?;
        versions.insert(name.into(), version);
    }
    Ok(versions)
}

fn fix_dep_set(
    versions: &BTreeMap<String, Version>,
    key: &str,
    metadata: &mut toml::Value,
) -> Result<usize> {
    let mut changed = 0;
    if let Some(dependencies) = metadata.as_table_mut().unwrap().get_mut(key) {
        if let Some(dependencies) = dependencies.as_table_mut() {
            for (dep_name, dep) in dependencies.iter_mut() {
                changed += match dep.as_table_mut() {
                    None => {
                        if !dep.is_str() {
                            bail!("unexpected dependency (must be table or string): {:?}", dep)
                        }
                        0
                    }
                    Some(ref mut table) => update_dep(table, dep_name, versions)?,
                };
            }
        }
    }
    Ok(changed)
}

fn update_dep(
    table: &mut Table,
    dep_name: &str,
    versions: &BTreeMap<String, Version>,
) -> Result<usize> {
    if !table.contains_key("path") {
        return Ok(0);
    }
    let package_version = match versions.get(dep_name) {
        Some(version) => version.to_string(),
        None => bail!("version not found for crate {}", dep_name),
    };
    let previous_version = table.insert(
        "version".into(),
        toml::Value::String(package_version.to_string()),
    );
    match previous_version {
        None => Ok(1),
        Some(prev_version) if prev_version.as_str() == Some(&package_version) => Ok(0),
        Some(mismatched_version) => {
            tracing::warn!(expected = ?package_version, actual = ?mismatched_version, "version was set but it did not match");
            Ok(1)
        }
    }
}

fn fix_dep_sets(versions: &BTreeMap<String, Version>, metadata: &mut toml::Value) -> Result<usize> {
    let mut changed = fix_dep_set(versions, "dependencies", metadata)?;
    changed += fix_dep_set(versions, "dev-dependencies", metadata)?;
    changed += fix_dep_set(versions, "build-dependencies", metadata)?;
    Ok(changed)
}

async fn fix_manifests(
    fs: Fs,
    versions: &BTreeMap<String, Version>,
    manifests: &mut Vec<Manifest>,
    mode: Mode,
) -> Result<()> {
    for manifest in manifests {
        let changed = fix_dep_sets(versions, &mut manifest.metadata)?;
        if changed > 0 {
            let contents =
                "# Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.\n"
                    .to_string()
                    + &toml::to_string(&manifest.metadata).with_context(|| {
                        format!("failed to serialize to toml for {:?}", manifest.path)
                    })?;
            match mode {
                Mode::Execute => {
                    fs.write_file(&manifest.path, contents.as_bytes()).await?;
                    info!("Changed {} dependencies in {:?}.", changed, manifest.path);
                }
                Mode::Check => {
                    bail!(
                        "{manifest:?} contained invalid versions",
                        manifest = manifest.path
                    )
                }
            }
        }
    }
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_fix_dep_sets() {
        let manifest = br#"
            [package]
            name = "test"
            version = "1.2.0-preview"

            [build-dependencies]
            build_something = "1.3"
            local_build_something = { path = "../local_build_something", version = "0.4.0-different" }

            [dev-dependencies]
            dev_something = "1.1"
            local_dev_something = { path = "../local_dev_something" }

            [dependencies]
            something = "1.0"
            local_something = { path = "../local_something" }
        "#;
        let metadata = toml::from_slice(manifest).unwrap();
        let mut manifest = Manifest {
            path: "test".into(),
            metadata,
        };
        let versions = vec![
            ("local_build_something", "0.2.0"),
            ("local_dev_something", "0.1.0"),
            ("local_something", "1.1.3"),
        ]
        .into_iter()
        .map(|e| (e.0.to_string(), Version::parse(e.1).unwrap()))
        .collect();

        fix_dep_sets(&versions, &mut manifest.metadata).expect("success");

        let actual_deps = &manifest.metadata["dependencies"];
        assert_eq!(
            "\
                something = \"1.0\"\n\
                \n\
                [local_something]\n\
                path = \"../local_something\"\n\
                version = \"1.1.3\"\n\
            ",
            actual_deps.to_string()
        );

        let actual_dev_deps = &manifest.metadata["dev-dependencies"];
        assert_eq!(
            "\
                dev_something = \"1.1\"\n\
                \n\
                [local_dev_something]\n\
                path = \"../local_dev_something\"\n\
                version = \"0.1.0\"\n\
            ",
            actual_dev_deps.to_string()
        );

        let actual_build_deps = &manifest.metadata["build-dependencies"];
        assert_eq!(
            "\
                build_something = \"1.3\"\n\
                \n\
                [local_build_something]\n\
                path = \"../local_build_something\"\n\
                version = \"0.2.0\"\n\
            ",
            actual_build_deps.to_string()
        );
    }
}
